
Levels A n' AB
2008-2009
4TH EDITION
Roselyn Teukolsky, M.S.
 Four full-length AP practice exams,
two each fo' Levels A n' AB
 All thangs answered n' explained
 Extensive subject review
 Over 500 multiple-choice thangs
 New up in dis edition: Da GridWorld
Case Study
®AP n' Advanced Pl acement Program is registered trademarkz of tha College
Entrizzle Examination Board, which was not involved up in tha thang of, n' do
not endorse dis book.

BARRON'S
co U ,R
SCIENCE
Levels A n' AB
4TH EDITION
Roselyn Teukolsky, M.S.
Ithaca High School
Ithaca, New York
BARRON'S
Th~s One
1111111111111111111111111111111111111111111111111
FCRK-B19-382N
® AP be a registered trademark of tha College Entrizzle Examination Board. Y'all KNOW dat shit, muthafucka! which was not involved up in tha thang of, n' do not endorse, dis book.
© Copyright 2007 by Barronz Ejaculationizzle Series, Inc.
Previous editions © Copyright 2003 under tha title
How tha fuck ta Prepare fo' tha AP Computa Science Advanced
Placement Examination, JAVA Version, n' 2001
under tha title How tha fuck ta Prepare fo' tha AP Computer
Science Advanced Placement Examination
by Barronz Ejaculationizzle Series, Inc.
All muthafuckin rights reserved.
No part of dis book may be reproduced in
any form, by photostat, microfilm, xerography,
or any other means, or incorporated tha fuck into any
information retrieval system, electronic or
mechanical, without tha freestyled permission
of tha copyright baller.
All inquiries should be addressed to:
Barronz Ejaculationizzle Series, Inc.
250 Wireless Boulevard
Hauppauge, New York 11788
http://www.barronseduc.com
ISBN-13: 978-0-7641-3709-9
ISBN-I0: 0-7641-3709-3
ISBN-13 (with CD-ROM): 978-0-7641-9350-7
ISBN-I0 (with CD-ROM): 0-7641-9350-3
Library of Congress Control Number: 2006102317
Library of Congress Cataloging-in-Publication Data
Teukolsky, Roselyn.
Barronz AP computa science: Levels A n' AB / Roselyn Teukolsky.
-4th ed.
p.cm.
Includes index.
ISBN-13: 978-0-7641-3709-9
ISBN-I0: 0-7641-3709-3
1. Computa science-Examinations, thangs, etc. I. Title:
QA76.28.T482007
004'.076-dc22
PRINTED IN THE UNITED STATES OF AMERICA
9876543
2006102317
Contents
Preface xi
Introduction xiii
General Hype Bout tha Exam          .   .          X111
Hints fo' Takin tha Exam. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. xiv
Da Multiple-Choice Section . . . . . . . . . . . . . . . . . . . . . . . . . . . . XIV
Da Free-Response Section .............................. XIV
How tha fuck ta Use This Book ................................. xv
Practice Exam One I Level A Diagnostic Test 1
Computa Science A Section I. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
Computa Science A Section Pt II  .         . . .      .         30
Answer Key (Section I) ................................. 38
Diagnostic Chart fo' Level A Exam   .    . . .        .     .   38
Answers Explained . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 40
Practice Exam Two I Level AB Diagnostic Test 51
Computa Science AB Section I. . . . . . . . . . . . . . . . . . . . . . . . . . .. 55
Computa Science AB Section Pt II                           89
Answer Key (Section I) .............. 101
Diagnostic Chart fo' Level AB Exam .      .          .    .  . 101
Answers Explained . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 103
Chapta 1. Introductory Java Language Features 115
Packages n' Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 115
Types n' Identifiers .................. . ' .............. .. 117
Identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
Built-in Types ...................................... 117
Storage of Numbers .................................. 118
Hexadecimal Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
Final Variablez ...................................... 120
Operators .................... . . . . . . . . . . . . . . . . . .. . . .. 120
Arithmetic Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
RelationalOperators ................................. 121
Logical Operators ................................... 122
Assignment Operators ................................ 123
Increment n' Decrement Operators . . . . . . . . . . . . . . . . . . . . . . . 124
Operator Precedence ................................. 124
Input/Output ....................................... 124
Input ............................................ 124
Output .......................................... 125
Escape Sequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
iii
Iv Contents
Control Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 126
Decision-Makin Control Structures ....................... .126
Iteration. I aint talkin' bout chicken n' gravy biatch. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
Errors n' Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 132
Multiple-Choice Thangs on Introductory Java Language Concepts  134
Answer Key . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 145
Answers Explained . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 145
Chapta 2. Classes n' Objects 149
Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 149
Classes ............................................ 150
Public, Private, n' Static  150
Methodz .......... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 151
Headaz . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
Typez of Methodz ................................... 151
Method Overloadin ................................. 155
Scope ............................................. 155
Da dis Keyword .................................. 156
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 156
Reference vs. Primitizzle Data Types ........................ 156
Da Null Reference .................................. 158
Method Parametas .................................. 158
Multiple-Choice Thangs on Classes n' Objects, n' you can put dat on yo' toast.              166
Answer Key . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 181
Answers Explained . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 181
Chapta 3. Inheritizzle n' Polymorphizzle 186
Inheritizzle ......................................... 186
Superclass n' Subclass ................................ 186
Inheritizzle Hierarchy ................................. 186
Implementin Subclasses ............................... 187
Declarin Subclass Objects .............................. 192
Polymorphizzle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 193
Dynamic Bindin (Late Binding) . . . . . . . . . . . . . . . . . . . . . . . . . . 193
Type Compatibilitizzle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 194
Downcasting. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
Da ClassCastException ............................ 195
Abstract Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 196
Abstract Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
Da abstract Keyword ............................... 196
Interfaces .......................................... 198
Interface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
Definin a Interface ................................. 198
Da implements Keyword ............................. 199
Da Comparable Interface .............................. 199
Multiple-Choice Thangs on Inheritizzle n' Polymorphism.       203
Answer Key . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 220
Answers Explained . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
Contents v
Chapta 4. Right back up in yo muthafuckin ass. Some Standard Classes 225
Da Object Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
Da Universal Superclass ............................... 225
Methodz up in Object .................................. 225
Da Strin Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 228
Strin Objects ..................................... 228
Constructin Strin Objects ........................... 228
Da Concatenation Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229
Comparison of Strin Objects .......................... 229
Other Strin Methodz ................................ 230
Wrapper Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 231
Da Integer Class .................................. 232
Da Double Class ................................... 233
Da Ka th Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 234
Random Numbers ................................... 235
Multiple-Choice Thangs on Standard Classes.  .               238
Answer Key . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 253
Answers Explained . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 253
Chapta 5. Program Design n' Analysis 260
Da Software Development Life Cycle   .   .  . . . .   .          260
Da Waterfall Model.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
Program Justification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
Program Design. I aint talkin' bout chicken n' gravy biatch. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
Program Implementation .............................. 261
Testin n' Debuggin ................................ 261
Program Maintenance. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
Object-Oriented Program Design    .     . .                 263
Identifyin Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
Identifyin Behaviors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
Encapsulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
Determinin Relationships Between Classes .................. 263
UML Diagrams ..................................... 264
Implementin Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
Implementin Methodz . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
Vocabulary Summary ................................. 268
Program Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 269
Program Correctnizz ................................. 269
Assertions ........................................ 269
Efficiency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
Big-O Notation ..................................... 271
Multiple-Choice Thangs on Program Design n' Analysis.        274
Answer Key . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284
Answers Explained . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 284
Chapta 6 fo' realz. Arrays n' Array Lists 288
One-Dimensionizzle Arrays . . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . 288
Initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288
Length of Array. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289
Traversin a Array .................................. 290
vi Contents
Arrays as Parametas ....................... .......... 290
Array Variablez up in a Class .............................. 293
Array of Class Objects ............................. ... 294
Analyzin Array Algorithms . . . . . . . . . . . . . . . . . . . . . . . ..... 295
Array Lists, n' you can put dat on yo' toast.                       ,.                   296
Da ArrayList Class ................................. 297
Generics ......................................... 297
Da Methodz of ArrayList ............................. 297
Auto-Boxin n' -Unboxing. . . . . . . . . . . . . . . . . . . . . . . . ..... 298
Usin ArrayList ................................... 299
Two-Dimensionizzle Arrays  '.     299
Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ......... 300
Processin a Two-Dimensionizzle Array ....................... 300
Two-Dimensionizzle Array as Parameta ...................... 301
Multiple-Choice Thangs on Arrays n' Array Lists  303
Answer Key                                          332
Answers Explained                                     332
Chapta 7. Recursion 338
Recursive Methodz                                     338
General Form of Simple Recursive Methodz                   339
Freestylin Recursive Methodz  ~.                  341
Analysiz of Recursive Methodz                         342
Sortin Algorithms That Use Recursion  343
Recursive Helper Methodz                                343
Recursion up in Two-Dimensionizzle Grids.                        346
Multiple-Choice Thangs on Recursion                     349
Answer Key                          .               359
Answers Explained                                     359
Chapta 8. Linked Lists 363
Linked List  .36.3
Linear Linked Lists                                    .36.3
Featurez of a Linked List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 363
Da ListNode Class .................................. 364
A Linear Linked List Class. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367
Circular Linked Lists, n' you can put dat on yo' toast.                                  .371
Implementin a Circular Linked List ....................... 371
Doubly Linked Lists                                    .37.3
Why Doubly Linked Lists, biatch? ............................. 373
Header n' Traila Nodes .............................. 373
Implementin Doubly Linked Lists ........................ 374
Run Time of Linked List vs fo' realz. Array Algorithms                 379
Multiple-Choice Thangs on Linked Lists                    380
Answer Key                                         398
Answers Explained                                    398
Contents
Chapta 9. Right back up in yo muthafuckin ass. Stacks n' Queues 403
Stacks              .    . .     . . . . . .  . .  . .   .       403
What Is a Stack, biatch? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 403
Da Stack<e> Class .................................. 403
When ta Use a Stack .................................. 405
Queues  . . . . .  . . . .      .  .  . . . . . . . . . . . .  . . . . . . . . . .. 406
What Is a Queue, biatch? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406
Da Queue<e> Interface ...................... . . . . . . . .. 407
Queue Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 407
When ta Use a Queue ................................. 408
Prioritizzle Queues                       .   .   .          409
What Is a Prioritizzle Queue, biatch? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409
Da Priori tyQueue<e> Class . . . . . . . . . . . . . . . . . . . . . . . . . . . 409
Implementation of a Prioritizzle Queue .. . . . . . . . . . . . . . . . . . . . . . 409
When ta Use a Prioritizzle Queue ........................... 410
Run Time of Stack, Queue, n' Prioritizzle Queue Operations . 412
Multiple-Choice Thangs on Stacks n' Queues         .     . 413
Answer Key              .   .          . .    .     .   . 426
Answers Explained                    .                426
Chapta 10. Trees 432
Binary Trees ............... 432
Definitions ........................................ 432
Implementation of Binary Trees .......................... 433
Da TreeNode Class .................................. 433
A BinaryTree Class ................................. 435
Binary Search Trees.                 .                  436
A BinarySearchTree Class ............................ 436
Insertin a Element tha fuck into a Binary Search Tree ................ 437
Findin a Target Element up in a Binary Search Tree ............... 438
Creatin a Binary Search Tree ............................ 439
Tree Traversal . 440
Three Methodz of Traversal ............................. 440
Implementin tha Traversal Algorithms ..................... 441
Recursive Tree Algorithms. Boy it's gettin hot, yes indeed it is.         .      .    .          . 442
Recursion That Altas tha Tree Structure .................... 444
Binary Expression Trees.                      .          446
Infix, Postfix, n' Prefix Expressions . . . . . . . . . . . . . . . . . . . . . . . 446
Binary Expression Tree ................................ 447
Evaluatin a Binary Expression Tree ....................... 448
A Binary Expression Tree Program ........................ 450
Run Time of Binary Search Tree (BST) Algorithms .     . . .     453
Multiple-Choice Thangs on Trees . 454
Answer Key   .                                      466
Answers Explained   .     .     .    . .            .     . 466
vii
viii Contents
Chapta 11. Collections 472
Collections up in Java .................................... 472
What Is a Collection, biatch? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 472
Da Collections API. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 472
Da Collections Hierarchy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 473
Collections n' Generics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 474
Collections n' Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 475
Definizzle of a Iterator ....... . . . . . . . . . . . . . . . . . . . . . . . . 475
Da Iterable<e> Interface ............................. 475
Da Iterator<e> Interface ............................. 475
Usin a Generic Iterator ............................... 476
Da Listlterator<e> Interface ......................... 477
Usin tha ListIterator<e> Interface ...................... 478
Da List-&lt;£&gt; Interface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 479
Da Methodz of List<e> .............................. 480
Da ArrayList<e> Class .............................. 480
Usin ArrayList<e> ................................. 481
Da LinkedList<e> Class ............................. 483
Usin LinkedList<e> ................................ 484
Freestylin General Code. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 484
ArrayList vs. LinkedList                               485
Da Set <i> Interface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 486
Da Methodz of Set<e> ............................... 487
Da HashSet<e> Class ............................... 487
Da TreeSet<e> Class ................................ 488
Examplez wit HashSet<e> n' TreeSet<e> ................. 488
Da lIap«, V&gt; Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 492
Da Methodz of Kap<k, v="">. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 492
Da HashKap<k, v=""> Class .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 493
Da TreeMap<k, v=""> Class .............................. 494
Iteratin over Maps .................................. 494
Examplez wit HashKap<k, v=""> n' TreeMap<k, v="">. . . . . . .. '. . . . . . 495
Run Time of Set n' Map Operations  498
Multiple-Choice Thangs on Collections  :  500
Answer Key . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 519
Answers Explained . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 519
Chapta 12. Right back up in yo muthafuckin ass. Sortin n' Searchin 524
O(n2) Sorts: Selection n' Insertion Sorts  524
Selection Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .... 524
Insertion Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .... 525
Recursive Sorts: Mergesort n' Quicksort                    526
Mergesort. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .... 526
Quicksort ........................................ 527
A Binary Tree Sort: Heapsort                             528
Sortin Algorithms up in Java. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 531
Sequential Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 535
Binary Search. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 535
Hash Codin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 536
Description ....................................... 536
Contents
Resolvin Collisions .................................. 537
Note Bout Collections       . .   .  .   .  . . . . .    .  .     538
Run Time of Sortin Algorithms . 539
Run Time of Searchin Algorithms ... 539
Multiple-Choice Thangs on Sortin n' Searchin        .     541
Answer Key            .    . . .   .              .      557
Answers Explained               .        .    .        .0. 557
Chapta 13. Da GridGhetto Case Study 564
Overview ...... 564
Da Classes  564
Da Playas.            .       . . .   .     . .   .       . 565
Da Location Class .... 566
Description ....................................... 566
Methods. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 568
Da Playa Class        .                               568
Description ....................................... 568
Methods. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 569
Da Rock n' Flower Classes        .      .    . .         . 570
Da Rock Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 570
Da Flower Class ................................... 570
Da Bug Class. . . . . . . . . . . .  . . .   .  .   . .   . .  . . . . .   . .. 570
Description ....................................... 570
Methodz .......................................... 571
Da BoxBug Class                . .   . . .     .    .       572
Description ....................................... 572
Methods. . . . . . . . . . . . . . . . . . . . . . . . .'. . . . . . . . . . . . . . . . . 573
Da Critta Class  573
Description ....................................... 573
Methodz .......................................... 574
Da ChameleonCri tta Class              . .    .         .  575
Description ....................................... 575
Methodz .......................................... 576
Da Grid<e> Interface.  . .    . .     .        . . .    .      576
Methodz .......................................... 576
Da AbstractGrid<e> Class.              .               576
Description ....................................... 576
Methods. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 577
Da BouncledGrid<e> n' UnbouncledGrid<e> Classes ... 578
Description ....................................... 578
Methods. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 579
Run-Time Analysiz of Grid Methodz .. 582
Bounded Grid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 582
Unbounded Grid .................................... 582
Big-O Summary of Grid Methodz                          583
Da Case Study n' tha AP Exam       .    . .   . .   . . . .  . .. 583
Multiple-Choice Thangs on tha Case Study  585
Answer Key       .          .              .   . . . .  . .. 60 1
Answers Explained                              .     .  60 1
ix
x Contents
Practice Exam Three 607
Computa Science A Section I.                            609
Computa Science A Section Pt II                  .          633
Answer Key (Section I) ................................. 642
Answers Explained . . . . . . . . . . . . . . . . . . . ...... : . . . . . . . . .. 642
Practice Exam Four 653
Computa Science AB Section I.   .  . .   .                  655
Computa Science AB Section Pt II    . . . .  .                  683
Answer Key (Section I) ................................ 691
Answers Explained . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 691
Appendix A. Glossary of Useful Computa Terms 705
Appendix B. Right back up in yo muthafuckin ass. Supplementary Code fo' Evaluatin a Binary
Expression Tree 708
Index 711
Preface
~ .. ~
This book be aimed at hustlas reviewin fo' tha AP Computa Science exam. Well shiiiit, it would
normally be used all up in tha completion of a AP course. But fuck dat shiznit yo, tha word on tha street is dat it gotz nuff a cold-ass lil complete
summary of all topics fo' both Level A n' AB exams, n' it can be used fo' self-study
if accompanied by a suitable textbook.
Da book serves up a review of object-oriented programming, algorithm analysis,
and data structures. Well shiiiit, it can therefore be used as a supplement ta first-year college
courses where Java is tha programmin language, n' as a resource fo' mackdaddys of
high school n' introductory college courses.
This fourth edizzle includes some freshly smoked up featurez of Java 5.0 dat was first tested
on tha May 2007 exam: generic collection classes n' tha enhanced fo' loop. Right back up in yo muthafuckin ass. Static
imports n' auto-boxin n' -un boxin is also discussed up in tha book yo, but these topics
will not be tested on tha AP exam. Da material on object-oriented programmin and
design has been expanded ta reflect tha changin emphasiz of tha AP exam. Right back up in yo muthafuckin ass. Similar
small chizzlez n' improvements done been made all up in tha book.
Each review chapta is followed by AP exam-style multiple-choice thangs with
detailed explanationz of tha lyrics.
There be a similarly thorough review of tha GridGhetto Case Study.
There is four complete practice exams, two Level A n' two Level AB. These
exams done been revised ta be mo' up in keepin wit tha evolution of tha actual exams.
Da exams follow tha format of tha AP exam, wit multiple-choice n' free-response
sections. Two is presented afta tha introduction ta tha book fo' possible use as
diagnostic tests, n' you can put dat on yo' toast. Diagnostic charts accompany these tests, n' you can put dat on yo' toast. Detailed solutions with
explanations is provided fo' all exams. Boy it's gettin hot, yes indeed it is. Two additionizzle exams is provided on the
optionizzle CD-ROM. This edizzle gotz nuff nuff muthafuckin freshly smoked up thangs. There is no overlap
of thangs between tha exams.
_'1.,-:.-'
ACKNOWLEDGMENTS
. -' ...... ""
I owe props ta nuff playas whoz ass helped up in tha creation of dis book.
A special thank-you ta Chris Nevison n' Slick Rick Kick fo' tha care they took in
readin tha freshly smoked up sectionz of tha manuscript. Their detailed comments n' lyrics were
invaluable ta mah dirty ass.
I be most grateful ta mah pimpin editor, Linda Turner, of Barron's, fo' her bumpin'
guidizzle n' moral support all up in dis project. Thanks too ta Sara Black fo' her
superlatizzle thang of copyeditin a tough manuscript. I also give props ta Frank Pasquale n' all
the other thugz of tha Barronz staff whoz ass hit dat shiznit on tha thang of tha book.
Thanks too ta Tyla DeWall fo' his thugged-out lil' patience n' perseverizzle up in tha pimpment of
theCD-ROM.
I be grateful ta Steven Andrianoff n' Dizzy Levine of St. Bonaventure University,
New York, fo' they outstandin workshops over tha muthafuckin years dat gave me a leg up in
computa science. Many scams from they Java workshop found they way tha fuck into this
book.
xi
xii Preface
A big-ass thank-you goes ta mah AP computa science hustlas whoz ass helped up in tha debugging
of problems. Boy it's gettin hot, yes indeed it is. Right back up in yo muthafuckin ass. Special props ta Lil' Bow Wow Zax n' Ian Lenz fo' contributin their
hours n' expertise, n' ta Johnathon Schultz n' Daniel Birman fo' pluggin a cold-ass lil couple
of smart-ass algorithms.
There be a special place up in mah ass fo' Ray-Ray Zax whoz ass did a dunkadelic thang of
checkin tha practice exams, tha GridGhetto case study chapter, n' tha CD-ROM.
Her lyrics n' solid suggestions is dotted throughout.
Thank-you ta Nicole Bohannon of Uptown High School up in Maryland, fo' spotting
a flaw up in a gangbangin' finger-lickin' hard as fuck question, n' takin tha shiznit ta contact me bout dat shit.
Nuff props ta all of tha computa science mackdaddys all up in tha ghetto who
took time ta write ta me wit suggestions fo' dis freshly smoked up edition.
My fuckin homeboy, Saul, continues ta be mah partner up in dis project-typesettin the
manuscript, producin tha figures, n' givin lyrics n' moral support every last muthafuckin step
of tha way. This book be all bout his muthafuckin ass.
Roselyn Teukolsky
Ithaca, NY
March 2007
In trod llction
Computa Science: Da borin art
of copin wit a big-ass number of trivialities.
-Stan Kelly-Bootie, Da Devilz DP Doggtionary {1981}
GENERAL INFORMATION ABOUT THE EXAM
,. ':":' f' '~";: .-s-:.
Da AP Computa Science exam be a three-hour freestyled exam. No books, calculators,
or computas is allowed hommie! Da exam consistz of two parts dat have equal weight:
 Section I: 40 multiple-choice thangs up in 1 minute n' 15 minutes.
 Section Pt II: 4 free-response thangs up in 1 minute n' 45 minutes.
Section I is banged up by machine-you will bubble yo' lyrics wit a pencil on a
mark-sense sheet. Each question erectly answered is worth 1 point, while incorrect
answers git ~ of a point deducted; a question left blank is ignored.
Section Pt II is banged up by human readers-you will write yo' lyrics up in a funky-ass booklet
provided. Y'all KNOW dat shit, muthafucka! Free-response thangs typically involve freestylin methodz up in Java ta solve
a given problem. Right back up in yo muthafuckin ass. Sometimes there be thangs analyzin algorithms or designing
and modifyin data structures. Yo ass may be axed ta write or design a entire class.
To ensure consistency up in tha grading, each grader bigs up tha same ol' dirty rubric, n' each
of yo' four lyrics may be examined by mo' than one reader n' shit. Each question is
worth 9 points, wit partial credit awarded where applicable. Yo crazy-ass name n' school
are hidden from tha readers.
Yo crazy-ass raw score fo' both sections is converted ta a integer score from 1 ta 5, where 1
represents "Not at all qualified" n' 5 represents "Extremely well qualified." Be aware
that tha awardin of AP credit varies enormously from college ta college.
Da exam can be taken at two levels: Level A covers roughly a one-semesta introductory
college course, while Level AB covers roughly a two-semesta course, including
data structures. In termz of gettin credit at colleges, it make mo' sense ta git a
4 or 5 on tha Level A exam than a 2 or 3 on tha Level AB exam.
Da language of tha AP exam is Java. Only a subset of tha Java language will be
tested on tha exam. In freestylin yo' solutions ta tha free-response thangs, however,
you may use any Java features, includin dem dat is not up in tha AP subset.
For a cold-ass lil complete description of dis subset, peep tha College Board joint at
http://www.collegeboard.comjstudent/testingjapjsubjects.html. Every language topic
in dis review book is part of tha AP Java subset unless explicitly stated otherwise.
Note dat tha entire subset is covered up in tha book, includin some freshly smoked up features
ofJava 5.0 dat is ghon be tested on tha AP exam, startin up in May 2007.
At least one free-response n' five multiple-choice thangs is ghon be based on the
GridGhetto Case Study. Da full text of tha case study can be found all up in tha College
Board joint.
xiii
xiv Introduction
At tha exam, yo big-ass booty is ghon be given
 A copy of tha testable case .study code.
 A quick reference ta tha intercourses n' "black box" classez of tha case study, with
listz of they required methods.
 A quick reference ta tha standard Java intercourses n' classes wit listz of their
required methods.
 (Level AB only) A copy of tha ListNode n' TreeNode classes.
HINTS FOR TAKING THE EXAM
Da Multiple-Choice Section
 Since ~ of a point is deducted fo' each wack answer, don't guess unless you can
eliminizzle at least one chizzle.
 Yo ass gotz a lil less than two minutes per question, so don't waste time on any
given question. I aint talkin' bout chicken n' gravy biatch. Yo ass can always come back ta it if you have time all up in tha end.
 Seemingly fucked up array thangs can often be solved by hand tracin the
code wit a lil' small-ass array, two or three elements, n' you can put dat on yo' toast. Da same is legit fo' other data
structures like fuckin matrices, stacks, queues, or linked lists.
 Many thangs ask you ta compare two piecez of code dat supposedly implement
the same algorithm. Often one program segment will fail cuz it don't
handle endpoint conditions properly (e.g., num == 0 or list == nUll). Be aware
of endpoint conditions all up in tha exam.
 Since tha mark-sense shizzle is scanned by machine, make shizzle dat you erase straight-up
if you chizzle a answer.
Da Free-Response Section.
 Each free-response question is worth 9 points, n' you can put dat on yo' toast. Take a minute ta read through
the whole exam so dat you can start wit a question dat you feel confident
about. Well shiiiit, it gives you a psychedelic leg up ta git a solid question up in tha bag.
 Don't omit a question just cuz you can't come up wit a cold-ass lil complete solution.
. Remember, partial credit be awarded. Y'all KNOW dat shit, muthafucka! Also, if you can't do part (a) of a question,
don't omit part (b)-they is graded independently ..
 In freestylin solutions ta a question, you must use tha hood methodz of classes
provided up in dat question wherever possible. If you write a thugged-out dope chunk of
code dat can be replaced by a cold-ass lil call ta one of these methods, yo big-ass booty is ghon probably
not receive full credit fo' tha question.
 If a algorithm is suggested ta solve a problem, just follow dat shit. Don't reinvent the
wheel.
 Don't waste time freestylin comments: tha gradaz generally ignore dem wild-ass muthafuckas. The
occasionizzle brief comment dat clarifies a segment of code is OK.
 Points is not deducted fo' inefficient code unless efficiency be a issue up in the
question.
Introduction
 Most of tha standard Java library methodz is not included up in tha AP subset.
They is accepted on tha exam if you use dem erectly. But fuck dat shiznit yo, tha word on tha street is dat there is
always a alternatizzle solution dat uses tha AP subset n' you should try ta find
it.
 Don't cross up a answer until you have freestyled a replacement. Gradaz are
instructed not ta read anythang crossed out, even if it would have gotten credit.
 Have some awarenizz dat dis section is graded by humans. Well shiiiit, it is up in yo' interest
to have tha gradaz KNOW yo' solutions. With dis up in mind,
- Use a gangbangin' finger-lickin' dirty-ass sharp pencil, write legibly, space yo' lyrics, n' indent erectly.
- Use self-documentin names fo' variables, methods, n' so on.
- Use tha identifiers dat is given up in a question. I aint talkin' bout chicken n' gravy biatch. Yo ass will lose a usage point
if you persist up in rockin tha wack names.
- Write clear readable code. This is yo' goal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Don't write one obscure
convoluted statement when you can write two short clear statements, n' you can put dat on yo' toast. The
APCS exam aint tha place ta demonstrate dat you a  smart-ass .
HOW TO USE THIS BOOK -
Each chapta up in tha book gotz nuff a cold-ass lil comprehensive review of a topic, multiple-choice
questions dat focus on tha topic, n' detailed explanationz of lyrics. These focus
questions help yo.u ta review partz of tha Java subset dat you should know fo' realz. A few
questions is not typical AP exam thangs-for example, thangs dat test lowlevel
detailz of syntax. Most of tha focus thangs, however, n' all tha multiplechoice
questions up in tha practice exams is representatizzle of actual exam thangs.
Yo ass should also note dat nuff muthafuckin crewz of focus thangs is preceded by a single
piece of code ta which tha thangs refer n' shit. Be aware dat tha AP exam will usually
restrict tha number of thangs per code example ta two.
In both tha text n' thangs/explanations, a special code font is used fo' parts of
the text dat is Java code.
IIThis be a example of code font
A different font is used fo' pseudo-code.
&lt; Here is pseudo-code font. &gt;
Sections up in tha text n' multiple-choice thangs dat is pimped up at Level AB only
are clearly marked as such. Unmarked text n' thangs is suitable fo' both Levels
A n' AB. Chaptas 8-11 is fo' Level AB only. This is stated on tha straight-up original gangsta page of each
of these chapters.
Six complete practice exams is provided, three each fo' Level A n' level AB. Two
of tha exams is all up in tha start of tha book n' may be used as diagnostic tests, n' you can put dat on yo' toast. They are
accompanied by diagnostic charts dat refer you ta related topics up in tha review book.
Two of tha exams is on tha optionizzle CD-ROM provided wit tha book. Da final
two exams follow tha review chaptas near tha end of tha book.
Each of tha six exams has a answer key, complete solutions n' explanations fo' the
free-response thangs, n' detailed explanations fo' tha multiple-choice thangs.
There is no overlap up in tha thangs, so Level AB hustlas can use tha Level A exams
xv
xvi Introduction
for additionizzle practice. Right back up in yo muthafuckin ass. Some thangs up in tha Level AB exams is also fair game for
Level A hustlas. These is clearly marked as such up in tha non-CD-ROM exams.
Each practice exam gotz nuff at least five multiple-choice thangs n' one freeresponse
question on tha GridGhetto Case Study.
An answer shizzle is provided fo' tha Section I thangz of each exam. When you
have completed a entire exam, n' have checked yo' lyrics, you may wish ta .
calculate yo' approximate AP score. Use tha scorin workshizzle provided on the
back of tha answer sheet.
There is two appendices all up in tha end of tha book fo' realz. Appendix A be a glossary of
computa terms dat occasionally crop up on tha exam fo' realz. Appendix B gotz nuff'supplementary
material dat aint required fo' tha exam.
A final hint bout tha book: Try tha thangs before you peek all up in tha lyrics.
Dope luck!
Practice Exam One / Level A Diagnostic Test
PRACTICE EXAM ONE I LEVEL A DIAGNOSTIC TEST
Da exam dat bigs up has tha same ol' dirty format as dat used on tha actual AP exam. There
are two ways you may use it:
1 fo' realz. As a gangbangin' finger-lickin' diagnostic test before you start reviewing. Peepin tha answer key be a
diagnostic chart dat relates each question ta sections dat you should review.
In addition, complete explanations is provided fo' each solution.
2 fo' realz. As a practice exam when you have completed yo' review.
Complete solutions wit explanations is provided fo' tha free-response
questions.
1
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
Answer Sheet: Practice Exam One
1. ®®©@® 15. ®®©@® 29. ®®©@®
2. ®®©@® 16. ®®©@® 30. ®®©@®
3. ®®©@® 17. ®®©@® 31. ®®©@®
4. ®®©@® 18. ®®©@® 32. ®®©@®
5. ®®©@® 19. ®®©@® 33. ®®©@®
6. ®®©@® 20. ®®©@® 34. ®®©@®
7. ®®©@® 21. ®®©@® 35. ®®©@®
8. ®®©@® 22. ®®©@® 36. ®®©@®
9. ®®©@® 23. ®®©@® 37. ®®©@®
10. ®®©@® 24. ®®©@® 38. ®®©@®
11. ®®©@® 25. ®®©@® 39. ®®©@®
12. ®®©@® 26. ®®©©® 40. ®®©©®
13. ®®©©® 27. ®®©©®
14. ®®©©® 28. ®®©@®
How tha fuck ta Calculate Yo crazy-ass (Approximate) AP Score - AP Computa Science Level A
Multiple Chizzle
Number erect (out of 40)
1/4 x number wrong
Raw score = line 1 - line 2
Jacked Response
Question 1
(out of 9)
Question 2
(out of 9)
Question 3
(out of 9)
Question 4
(out of 9)
Total
Final Score
+
Multiple- Free-
ChOIce Response
Score Score
-= Multiple-Choice Score
(Do not round. Y'all KNOW dat shit, muthafucka! H less
than zero, enta zero.)
x 1.11
Final Score
(Round ta nearest
whole number.)
Chart ta Convert ta AP Grade
Computa Science A
Final AP Grade"
Score Range
60-80 5
45-59 4
33-44 3
25-32 2
0-24 1
aDa score range correspondin to
each grade varies from exam ta exam
and be approximate.
-= Free-Response Score
(Do not round.)
Practice Exam One I Level A Diagnostic Test
Practice Exam One
COMPUTER SCIENCE A
SECTION I
Time-1 minute n' 15 minutes
Number of thangs-40
Percent of total grade-50
Directions: Determine tha answer ta each of tha followin thangs or incomplete
statements, rockin tha available space fo' any necessary scratch work.
Then decizzle which is tha dopest of tha chizzlez given n' fill up in tha corresponding
oval on tha answer sheet. Do not spend too much time on mah playas problem.
Notes:
 Assume dat tha classes up in tha Quick Reference done been imported where
needed.
 Assume dat variablez n' methodz is declared within tha context of an
enclosin class.
 Assume dat method calls dat have no object or class name prefixed, and
that is not shown within a cold-ass lil complete class definition, step tha fuck up within the
context of a enclosin class.
 Assume dat parametas up in method calls is not null unless otherwise
stated.
5
6 Practice Exams
1. Consider dis inheritizzle hierarchy, up in which Novel n' Textbook is subclasses
of Book.
Which of tha followin be afalse statement bout tha classes shown?
(A) Da Textbook class can have private instizzle variablez dat is neither in
Book nor Novel.
(B) Each of tha classes-Book, Novel, n' Textbook-can gotz a method
computeShelfLife, whose code up in Book n' Novel is identical yo, but different
from tha code up in Textbook.
(C) If tha Book class has private instizzle variablez myTitle n' myAuthor, then
Novel n' Textbook inherit dem but cannot directly access dem wild-ass muthafuckas.
(D) Both Novel n' Textbook inherit tha constructors up in Book.
(E) If tha Book class has a private method called reaciFile, dis method may not
be accessed up in either tha Novel or Textbook classes.
GO ON TO THE NEXT PAGE.
Practice Exam One / Level A Diagnostic Test
2 fo' realz. A programmer is designin a program ta catalog all books up in a library yo. Dude plans
to gotz a Book class dat stores featurez of each book: lyricist, title, isOnShelf,
and so on, wit operations like getAuthor, getTitle, getShelfInfo, and
setShelfInfo fo' realz. Another class, LibraryList, will store a array of Book objects.
Da LibraryList class will include operations like fuckin listAllBooks, addBook,
removeBook, n' searchForBook. Da programmer plans ta implement n' test
the Book class first, before implementin tha LibraryList class. Da programmer's
plan ta write tha Book class first be a example of
(A) top-down pimpment.
(B) bottom-up pimpment.
(C) procedural abstraction.
(0) shiznit hiding.
(E) a thugged-out driver program.
GO ON TO THE NEXT PAGE.
7
8
Thangs 3-5 refer ta tha Card n' Deck classes shown below.
hood class Card
{
}
private Strin mySuit;
private int myValue; 110 ta 12
hood Card (Strin suit, int value)
{ 1* implementation *1 }
hood Strin getSuit()
{ return mySuit; }
hood int getValue()
{ return myValue; }
hood Strin toString()
{
}
Strin faceValue = '"';
if (myValue == 11)
faceValue = "J";
else if (myValue == 12)
faceValue = "Q";
else if (myValue == 0)
faceValue = "K";
else if (myValue == 1)
faceValue = "A";
if (myValue &gt;= 2 tt myValue &lt;= 10)
return myValue + " of " + mySuit;
else
return faceValue + " of " + mySuit;
hood class Deck
{
}
private Card[] myDeck;
hood final static int NUMCARDS = 52;
hood DeckO
{ ...
IISimulate shufflin tha deck.
hood void shuffle()
{ ...
Ilother methodz not shown ...
Practice Exams
GO ON TO THE NExt PAGE.
Practice Exam One / Level A Diagnostic Test
3. Which of tha followin represents erect 1* implementation *1 code fo' tha construcror
in tha Card class?
(A) mySui t = suit;
myValue = value;
(B) suit = mySuit;
value = myValue;
(C) Card = freshly smoked up Card(mySuit, myValue);
OJ) Card = freshly smoked up Card(suit, value);
(E) mySuit = getSuit();
myValue = getValue();
4. Consider dis description of tha Deck constructor:
A Deck object is ghon be constructed as bigs up:
myDeck[O] ... myDeck[12] will contain tha spade suit
myDeck[13] ... myDeck[25] will contain tha ass suit
myDeck [26] ... myDeck [38] will contain tha diamond suit
myDeck [39] ... myDeck [51] will contain tha club suit
In each suit tha card joints range from 0 ta 12. (these is converted ta actual
card joints up in tha toStrin method of tha Card class.) Here is tha constructor
for tha Deck class:
hood Deck 0
{
}
&lt; declaration of tha myDeck array&gt;
for (int i = 0; i &lt; NUMCARDS; i++)
{
}
1* code ta bang tha spade cardz tha fuck into myDeck *1
1* code ta bang tha ass cardz tha fuck into myDeck *1
1* code ta bang tha diamond cardz tha fuck into myDeck *1
1* code ta bang tha club cardz tha fuck into myDeck *1
Which of tha followin be a cold-ass lil erect replacement fo' 1* code ta bang tha ass cards
into myDeck * I, so dat tha justification fo' tha myDeck array is satisfied?
(A) if (i I 13 == 1)
myDeck [i I 13] = freshly smoked up Card("hearts", i Yo 13);
(B) if (i &gt;= 13 tt i &lt;= 25)
myDeck[i Yo 13] = freshly smoked up Card (llhearts Pt II , i Yo 13);
(C) if (i I 13 == 1)
myDeck[i] = freshly smoked up Card ("hearts" , i Yo 13);
OJ) if (i &gt;= 13 tt i &lt;= 25)
myDeck[i] = freshly smoked up Card("hearts", i I 13);
(E) if (i I 13 == 1)
myDeck[i Yo 13] = freshly smoked up Card("hearts", i Yo 13);
GO ON TO THE NEXT PAGE.
9
10 Practice Exams
5. Consider tha implementation of a wri teDeck method dat be added ta tha Deck
class.
IIWrite tha cardz up in myDeck, one per line.
hood void writeDeck()
{
1* implementation code *1
}
Which of tha followin is erect 1* implementation code */?
I System.out.println(myDeck);
II fo' (Card card : myDeck)
System.out.println(card);
III fo' (Card card : myDeck)
System.out.println«String) card);
(A) I only
(B) Pt II only
(C) Pt III only
(0) I n' Pt III only
(E) Pt II n' Pt III only
GO ON TO THE NEXT PAGE.
Practice Exam One / Level A Diagnostic Test
Refer ta tha followin class fo' Thangs 6 n' 7.
hood class Tester
{
}
private int[] testArray = {3, 4, 5};
//Add 1 ta n.
hood void increment (int n)
{ n++; }
hood void firstTestMethod()
{
}
for (int i = 0; i &lt; testArray.length; i++)
{
}
increment(testArray[i]);
System.out.print(testArray[i] + Pt II ");
hood void secondTestMethod()
{
}
for (int element : testArray)
{
}
increment(element);
System.out.print(element + Pt II ");
6. What output is ghon be produced by invokin !irstTestMethod fo' a Testa object?
(A) 3 4 5
(B) 4 5 6
(C) 5 6 7
(D) 0 0 0
(E) No output is ghon be produced. Y'all KNOW dat shit, muthafucka! An ArraylndexOutOfBoundsException will
be thrown.
7. What output is ghon be produced by invokin secondTestMethod fo' a Testa object,
assumin dat testArray gotz nuff 3,4, 5?
(A) 3 4 5
(B) 4 5 6
(C) 5 6 7
(0) 0 0 0
(E) No output is ghon be produced. Y'all KNOW dat shit, muthafucka! An ArraylndexOutOfBoundsException will
be thrown.
GO ON TO THE NEXT PAGE.
11
12 Practice Exams
8. Consider tha followin loop, where n is some positizzle integer.
for (int i = OJ i &lt; nj i += 2)
{
if U* test */)
1* big-ass up some action *1
}
In termz of n, which Java expression represents tha maximum number of times
that
1* big-ass up some action *1 could be executed?
(A) n I 2
(B) (n + 1) I 2
(C) n
(0) n - 1
(E) (n - 1) I 2
9 fo' realz. A method is ta be freestyled ta search a array fo' a value dat is larger than a
given item n' return its index. Da problem justification do not indicate
what should be returned if there be nuff muthafuckin such joints up in tha array. Which of
the followin actions would be best?
(A) Da method should be freestyled on tha assumption dat there is only one
value up in tha array dat is larger than tha given item.
(B) Da method should be freestyled so as ta return tha index of every last muthafuckin occurrence
of a larger value.
(C) Da justification should be modified ta indicate what tha fuck should be done if
there is mo' than one index of larger joints.
(0) Da method should be freestyled ta output a message if mo' than one larger
value is found.
(E) Da method should be freestyled ta delete all subsequent larger shit afta a
suitable index is returned.
GO ON TO THE NEXT PAGE.
Practice Exam One / Level A Diagnostic Test
10. When will method whatIslt cause a stack overflow (i.e., cause computa memory
to be exhausted)?
hood static int whatIslt(int x, int y)
{
}
if (x &gt; y)
return x * y;
else
return whatIslt(x - 1, y);
(A) Only when x &lt; y
(B) Only when x:::: y
(C) Only when x &gt; y
(0) For all jointz of x n' y
(E) Da method aint NEVER gonna cause a stack overflow.
11. Da boolean expression a [i] == max I I ! (max ! = a [i] ) can be simplified to
(A) a [i] == max
(B) a[i] != max
(C) a[i] &lt; max I I a[i] &gt; max
(0) true
(E) false
12. Right back up in yo muthafuckin ass. Suppose tha charactas 0,1, ... ,8,9,A,B,C,D,E,F is used ta represent a hexadecimal
(base-16) number n' shiznit yo. Here A = 10, B = 11, ... ,F = 15. What tha fuck iz tha phattest
base-10 integer dat can be represented wit a two-digit hexadecimal number,
like fuckin 14 or 3A?
(A) 32
(B) 225
(C) 255
(0) 256
(E) 272
13. Consider a Clown class dat has a thugged-out default constructor. Shiiit, dis aint no joke. Right back up in yo muthafuckin ass. Suppose a list
ArrayList<clown> list is initialized. Y'all KNOW dat shit, muthafucka! Which of tha followin aint gonna cause an
IndexOutOfBoundsExceptiontobethrown?
(A) fo' (int i = 0; i &lt;= list.size(); i++)
list.set(i, freshly smoked up Clown());
(B) list.add(list.size(), freshly smoked up Clown());
(C) Clown c = list.get(list.size());
(0) Clown c = list.remove(list.size());
(E) list.add(-1, freshly smoked up Clown());
GO ON TO THE NEXT PAGE.
13
14 Practice Exams
Thangs 14-16 refer ta tha Point, Quadrilateral, n' Rectangle classes below:
hood class Point
{
}
private int xCoord;
private int yCoord;
//constructor
hood Point(int x, int y)
{
}
//accessors
hood int get_xC)
{
}
hood int get_y()
{
}
/ / other methodz not shown ...
hood abstract class Quadrilateral
{
private Strin myLabels; Ile.g., "ABeD"
}
//constructor
hood Quadrilateral(Strin labels)
{ myLabels = labels; }
hood Strin getLabels()
{ return myLabels; }
hood abstract int perimeter();
hood abstract int area();
GO ON TO THE NEXT PAGE.
Practice Exam One I Level A Diagnostic Test
hood class Rectangle extendz Quadrilateral
{
}
private Point myTopLeft;
private Point myBotRight;
II constructor
Ilcoordz of top left corner
Ilcoordz of bottom right corner
hood Rectangle(Strin labels, Point topLeft, Point botRight)
{ 1* implementation code *1 }
hood int perimeter()
{ 1* implementation not shown *1 }
hood int area()
{ 1* implementation not shbwn *1 }
Ilother methodz not shown ...
14. Which statement bout tha Quadrilateral class isfalse?
(A) Da perimeta n' area methodz is abstract cuz there be a no suitable
default code fo' dem wild-ass muthafuckas.
(B) Da getLabels method aint abstract cuz any subclasses of
Quadrilateral gonna git tha same code fo' dis method.
(C) If tha Quadrilateral class is used up in a program, it must be used as a superclass
for at least one other class.
(D) No instancez of a Quadrilateral object can be pimped up in a program.
(E) Any subclassez of tha Quadrilateral class must provide implementation
code fo' tha perimeta n' area methods.
15. Which represents erect 1* implementation code *1 fo' tha Rectangle constructor?
I super(labels);
II super(labels, topLeft, botRight);
III super(labels);
myTopLeft = topLeft;
myBotRight = botRight;
(A) Ionly
(B) Pt II only
(C) Pt III only
(D) I n' Pt II only
(E) Pt II n' Pt III only
GO ON TO THE NEXT PAGE.
15
16
16. Refer ta tha Parallelogram n' Square classes below.
hood class Parallelogram extendz Quadrilateral
{
Practice Exams
Ilprivate instizzle variablez n' constructor not shown
hood int perimeter()
{ 1* implementation not shown *1 }
hood int area()
{ 1* implementation not shown *1 }
}
hood class Square extendz Rectangle
{
Ilprivate instizzle variablez n' constructor not shown
hood int perimeter()
{ 1* implementation not shown *1 }
hood int area()
{ 1* implementation not shown *1 }
}
Consider a ArrayList<quadrilateral> quadList whose elements iz of type
Rectangle, Parallelogram, or Square.
Refer ta tha followin method, wri teAreas:
1* Precondition: quadList gotz nuff Rectangle. Parallelogram. or
* Square objects up in a unspecified order n' shit. */
hood static void writeAreas(ArrayList quadList)
{
for (Quadrilateral quad : quadList)
System. out. println (" Area of " + quad. Y'all KNOW dat shit, muthafucka! getLabels 0
+ " is " + quad.areaO);
}
What tha fuck iz tha effect of executin dis method?
(A) Da area of each Quadrilateral up in quadList is ghon be printed.
(B) A compile-time error will occur, statin dat there is no area method in
abstract class Quadrilateral.
(C) A compile-time error will occur, statin dat there is no getLabels method
in classes Rectangle, Parallelogram, or Square.
(D) A NullPointerException is ghon be thrown.
(E) A ClassCastException is ghon be thrown.
GO ON TO THE NEXT PAGE.
Practice Exam One / Level A Diagnostic Test
17. Refer ta tha doSomethang method:
I I postcondition
hood static void doSomething(ArrayList<sometype> list, int i, int j)
{
}
SomeType temp = list.get(i);
list.set(i, list.get(j»;
list.set(j, temp);
Which dopest raps bout tha postcondizzle fo' do Something?
(A) Removes from list tha objects indexed at i n' j.
(B) Replaces up in list tha object indexed at i wit tha object indexed at j.
(C) Replaces up in list tha object indexed at j wit tha object indexed at i.
(0) Replaces up in list tha objects indexed at i n' j wit temp.
(E) Interchanges up in list tha objects indexed at i n' j.
18. Consider tha NegativeReal class below, which defines a wack real number
object.
hood class NegativeReal
{
}
private Double myNegReal;
Ilconstructor. Shiiit, dis aint no joke. Creates a NegativeReal object whose value is num.
IIPrecondition: num &lt; O.
hood NegativeReal(double num)
{ 1* implementation not shown *1 }
IIPostcondition: Returns tha value of dis NegativeReal.
hood double getValue()
{ 1* implementation not shoWn *1 }
IIPostcondition: Returns dis NegativeReal rounded ta tha nearest integer.
hood int getRounded()
{ 1* implementation *1 }
Here is some roundin examples:
Negatizzle real number
-3.5
Rounded ta nearest integer
-4
-8.97 -9
-5.0 -5
-2.487 -2
-0.2 o
Which 1* implementation *1 of git Rounded produces tha desired postcondition?
(A) return (int) (getValue 0 - 0.5) j
(B) return (int) (getValue() + 0.5);
(C) return (int) getValue()j
(0) return (double) (getValue() - 0.5);
(E) return (double) getValue()j
GO ON TO THE NEXT PAGE.
17
18
19. Consider tha followin method.
hood static void whatslt(int n)
{
}
if (n &gt; 10)
whatslt(n / 10);
System.out.print(n % 10);
Practice Exams
What tha fuck iz ghon be output as a result ofthe method call whatslt(347)?
(A) 74
(B) 47
(C) 734
(D) 743
(E) 347
20 fo' realz. A big-ass list of numbers is ta be sorted tha fuck into ascendin order n' shiznit fo' realz. Assumin dat a "data
movement" be a swap or reassignment of a element, which of tha followin be a
true statement?
(A) H tha array is initially sorted up in descendin order, then insertion sort will
be mo' efficient than selection sort.
(B) Da number of comparisons fo' selection sort is independent of tha initial
arrangement of elements.
(C) Da number of comparisons fo' insertion sortis independent of tha initial
arrangement of elements.
(D) Da number of data movements up in selection sort dependz on tha initial arrangement
of elements.
(E) Da number of data movements up in insertion sort is independent of tha initial
arrangement of elements, n' you can put dat on yo' toast. ,
GO ON TO THE NEXT PAGE.
Practice Exam One / Level A Diagnostic Test
21. Refer ta tha definitionz of ClassOne n' ClassTwo below.
hood class ClassOne
{
}
hood void methodOne()
{
}
//other methodz not shown
hood class ClassTwo extendz ClassOne
{
}
hood void methodTwo()
{
}
//other methodz not shown
Consider tha followin declarations up in a cold-ass lil client class. Yo ass may assume that
ClassOne n' ClassTwo have default constructors.
Class One cl = freshly smoked up ClassOne():
ClassOne c2 = freshly smoked up ClassTwo();
Which of tha followin method calls will cause a error?
I cl.methodTwo();
II c2. methodTwo 0 :
III c2.methodOne():
(A) None
(B) I only
(C) Pt II only
(0) Pt III only
(E) I n' Pt II only
GO ON TO THE NEXT PAGE.
19
20
22. Consider tha code segment
if (n -- 1)
k++;
else if (n == 4)
k += 4;
Suppose dat tha given segment is rewritten up in tha form
if (/ * condizzle * /)
I * assignment statement * I ;
Practice Exams
Given dat n n' k is integers n' dat tha rewritten code performs tha same
task as tha original gangsta code, which of tha followin could be used as
(1) 1* condizzle *1 n' (2) 1* assignment statement */?
(A) (1) n == 1 cU: n == 4 (2) k += n
(B) (1) n == 1 tt n == 4 (2) k += 4
(C) (1) n == 1 Pt II n == 4 (2) k += 4
(0) (1) n == 1 Pt II n == 4 (2) k += n
(E) (1) n = 1 Pt II n == 4 (2) k = n - k
23. Which of tha followin will execute without throwin a exception?
I Strin s = null;
Strin t = "";
if (s.equals(t»
System.out.println("empty strings?");
IT Strin s .. "holy";
Strin t = "moly";
if (s.equals(t»
System.out.println("holy moly!");
ITI Strin s = "holy";
Strin t = s.substring(4);
System.out.println(s + t);
(A) lonly
(B) IT only
(C) monly
(0) I n' IT only
(E) IT n' m only
GO ON TO THE NEXT PAGE.
Practice Exam One / Level A Diagnostic Test
24. Three numbers a, b, n' c is holla'd ta be a Pythagorean Triple if n' only if the
sum of tha squarez of two of tha numbers equals tha square of tha third. Y'all KNOW dat shit, muthafucka! A programmer
writes a method isPythTriple ta test if its three parametas form a
Pythagorean Triple:
//Returns legit if a * a + b * b == c * Cj otherwise returns false.
hood static boolean isPythTriple(double a, double b, double c)
{
}
double d = Math.sqrt(a * a + b * b);
return d == Cj
When tha method was tested wit known Pythagorean Triples, isPythTriple
sometimes erroneously returned false. What was da most thugged-out likely cause of the
error?
(A) Round-off error was caused by calculations wit floating-point numbers.
(B) Type boolean was not recognized by a obsolete version of Java.
(C) An overflow error was caused by enterin numbers dat was too large.
(0) C n' d should done been cast ta integers before testin fo' equality.
(E) Shiznitty test data was selected.
25. Refer ta tha followin class, containin tha mystery method.
hood class SomeClass
{
}
private int[] arrj
IIConstructor. Shiiit, dis aint no joke. Initializes arr ta contain nonnegative
II integers k such dat 0 &lt;= k &lt;= 9.
hood SomeClass()
{ 1* implementation not shown *1 }
hood int mystery()
{
}
int value = arr[O]j
for (int i = lj i &lt; arr.lengthj i++)
value = value * 10 + arr[i]j
return value;
Which dopest raps bout what tha fuck tha mystery method do?
(A) It sums tha elementz of arr.
(B) It sums tha shizzle 10*arr[0] +10*arr [1] + .. .+10*arr[arr .length-l].
(C) It buildz a integer of tha form d1d2d3  dn , where d1 = arr [0],
d2 = arr [1], ... , dn = arr Carr .length-l].
(0) It buildz a integer of tha form d1d2d3  dn , where
d1 = arr Carr .length-l], d2 = arr [arr .length-2], ... , dn = arr [0].
(E) It converts tha elementz of arr ta base-lO.
GO ON TO THE NEXT PAGE.
21
22 Practice Exams
Thangs 26 n' 27 refer ta tha search method up in tha Searcher class below.
hood class Searcher
{
}
private int[] arr;
IIConstructor. Shiiit, dis aint no joke. Initializes arr wit integers.
hood Searcher()
{ 1* implementation not shown *1 }
1* Precondition: arr[first] ... arr[last] sorted up in ascendin order.
* Postcondition: Returns index of key up in arr. Shiiit, dis aint no joke. If key not up in arr,
* returns -1. *1
hood int search(int first, int last, int key)
{
}
int mid;
while (first &lt;= last)
{
mid = (first + last) I 2;
if (arr[mid] == key) Ilfound key, exit search
return mid;
else if (arr[mid] &lt; key) Ilkey ta right of arr[mid]
}
first = mid + 1;
else
last = mid - 1;
return -1;
Ilkey ta left of arr[mid]
Ilkey not up in list
26. Which assertion is legit just before each execution of tha while loop?
(A) arr[first] &lt; key &lt; arr[last]
(B) arr[first] ~ key ~ arr[last]
(C) arr [f irst] &lt; key &lt; arr [last] or key aint up in arr
(D) arr [first] ~ key ~ arr [lal;1t] or key aint up in arr
(E) key ~ arr [f irst] or key ~ arr [last] or key aint up in arr
27. Consider tha array a wit joints as shown:
4,7,19,25,36,37,50,100,101,205,220,271,306,321
where 4 be a[O] n' 321 be a[13]. Right back up in yo muthafuckin ass. Suppose dat tha search method is called with
first = 0 n' last = 13 ta locate tha key 205 yo. How tha fuck nuff iterationz of tha while
loop must be made up in order ta locate it?
(A) 3
(B) 4
(C) 5
(D) 10
(E) 13
GO ON TO THE NEXT PAGE.
Practice Exam One / Level A Diagnostic Test
28. Consider tha followin RandomList class.
hood class RandomList
{
}
private int[] myList;
II constructor
hood RandomList()
{ myList = getList(); }
1* Read random Integers from 0 ta 100 inclusive tha fuck into array list. *1
hood int[] getList()
{
}
System.out.println("How tha fuck nuff integers, biatch? Pt II);
int listLength = IO.readlnt(); Ilread user input
int[] list = int[listLength];
for (int i = 0; i &lt; listLength; i++)
{
1* code ta add integer ta list *1
}
return list;
1* Print all elementz of dis list. *1
hood void printList()
{ ...
Which represents erect 1* code ta add integer ta list */?
(A) list[i] = (int) (Math.randomO * 101);
(B) list.add«int) (Math.random() * 101»;
(C) list[i] = (int) (Math.random() * 100);
0) list.add(new Integer(Math.random() * 100»
(E) list[i] = (int) (Math.random() * 100) + 1;
GO ON TO THE NEXT PAGE.
23
24 Practice Exams
Thangs 29 n' 30 refer ta method bang busted lyrics bout here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. Da bang method has
two strang parametas n' one integer parameter n' shit. Da method returns tha strang obtained
by insertin tha second strang tha fuck into tha straight-up original gangsta startin all up in tha posizzle indicated by
the integer parameter n' shit. For example, if str1 gotz nuff xy n' str2 gotz nuff cat, then
insert (str1, str2, 0) returns
insert (str1, str2, 1) returns
insert (str1 , str2, 2) returns
Here is tha header fo' method insert.
IIPrecondition: 0 &lt;= pos &lt;= str1.length().
IIPostcondition: Returns 1* somestrin *1.
catxy
xcaty
xycat
hood static Strin insert(Strin str1, Strin str2, int pos);
29 yo. H str1 = aOat ... an_t n' str2 = bObt ... bm- t, which of tha followin be a cold-ass lil erect
replacement fo' 1* somestrin */?
(A) aOat.. .aposbobt ... bm-tapos + tapos + 2.. .an- t
(B) aOat.. .apos + t bObt ... bm_tapos+ 2apos+ 3.. .an- t
(C) aOat. .. apos-t bObt ... bm-taposapos + t .. . an-t
(0) aOat.. .an-t bobt ... bm- t
(E) aoat .. .apos-t bObt ... bpos-taposapos + t .. . an- t
30. Method bang bigs up:
IIPostcondition: Returns 1* somestrin *1.
hood static Strin insert(Strin str1, Strin str2, int pos)
{
}
Strin first, last;
1* mo' code *1
return first + str2 + last;
Which of tha followin be a cold-ass lil erect replacement fo' 1* mo' code */?
(A) first = str1. substrin (0 , pos);
last = str1.substring(pos);
(B) first = str1.substring(O, pos - 1);
last = str1.substring(pos);
(C) first = str1.substring(O, pos + 1);
last = str1.substring(pos + 1);
(0) first = str1.substring(O, pos);
last = str1.substring(pos + 1, str1.length(»;
(E) first = str1.substring(O, pos);
last = str1.substring(pos, str1.length() + 1);
GO ON TO THE NEXT PAGE.
Practice Exam One I Level A Diagnostic Test
Use tha followin program description fo' Thangs 31-33.
A programmer plans ta write a program dat simulates a lil' small-ass bingo game (no more
than six playas). Each playa gonna git a funky-ass bingo card wit 20 numbers from 0 ta 90 (no
duplicates). Right back up in yo muthafuckin ass. Someone will callout numbers one at a time, n' each playa will cross
out a number on his card as it is called. Y'all KNOW dat shit, muthafucka! Da first playa wit all tha numbers crossed
out is tha balla n' shit. In tha simulation, as tha game is up in progress, each playaz card is
displayed on tha screen.
Da programmer envisions a gangbangin' finger-lickin' dirty-ass short driver class whose main method has just two
statements:
BingoGame b = freshly smoked up BingoGame()j
b. playBingo 0 j
Da BingoGame class gonna git nuff muthafuckin objects: a Display, a Caller, n' a PlayerGroup.
Da PlayerGroup gonna git a list of Players, n' each Player gonna git a BingoCard.
31. Da relationshizzle between tha PlayerGroup n' Player classes be a example of
(A) a intercourse.
(B) encapsulation.
(C) composition.
(0) inheritance.
(E) independent classes.
32. Which be a reasonable data structure fo' a BingoCard object, biatch? Recall dat a BingoCard
has 20 integers from 0 ta 90, wit no duplicates. There should also be
mechanizzlez fo' crossin off numbers dat is called, n' fo' detectin a winning
card (i.e., one where all tha numbers done been crossed off).
I int[] myBingoCardj Ilwill contain 20 integers
IlmyBingoCard[k] is crossed off by settin it ta -1.
int numCrossedOffj . Ilplayer wins when numCrossedOff reaches 20.
IT boolean[] myBingoCardj Ilwill contain 91 boolean joints, of which
1120 is true fo' realz. All tha other joints is false.
IIThus, if myBingoCard[k] is true, then k is
lion tha card, 0 &lt;= k &lt;= 90 fo' realz. A number k is
Ilcrossed off by changin tha value of
IlmyBingoCard[k] ta false.
int numCrossedOffj Ilplayer wins when numCrossedOff reaches 20.
ITI ArrayList<integer> myBingoCardj Ilwill contain 20 integers.
IIA number is crossed off by removin it from tha ArrayList.
IIPlayer wins when myBingoCard.size() == O.
(A) I only
(B) IT only
(C) monly
(0) I n' IT only
(E) I, IT, n' m
GO ON TO THE NEXT PAGE.
25
26 Practice Exams
33. Da programmer decides ta use a ArrayList<integer> ta store tha numbers to
be called by tha Caller:
hood class Caller
{
}
private ArrayList<integer> myNumbers;
//constructor
hood CallerO
{
}
myNumbers = getList();
shuffleNumbers();
//Return tha numbers 0 ... 90 up in order.
private ArrayList<integer> getList()
{ /* implementation not shown */ }
//Shuffle tha numbers.
private void shuffleNumbers()
{ /* implementation not shown */ }
When tha programmer tests tha constructor of tha Calla class she gets a
NullPointerException. I aint talkin' bout chicken n' gravy biatch. Which could be tha cause of dis error?
(A) Da Calla object up in tha driver class was not pimped wit new.
(B) Da programmer forgot tha return statement up in getList dat returns the
list of Integers.
(C) Da declaration of myNumbers is incorrect. Well shiiiit, it needed ta be
private ArrayList<integer> myNumbers = null;
(D) In tha getList method, a attempt was made ta add a Integer ta an
ArrayList dat had not been pimped wit new.
(E) Da shuffleNumbers algorithm went outta range, causin a null Integer
to be shuffled tha fuck into tha ArrayList.
GO ON TO THE NEXT PAGE.
Practice Exam One / Level A Diagnostic Test
Thangs 34-40 involve reasonin bout tha code from tha GridGhetto Case Study.
A Quick Reference ta tha case study is provided as part of dis exam. Da hustlas in
GridGhetto is represented up in dis book wit tha pictures shown below. Each hustla is
shown facin north. These pictures almost certainly is ghon be different from dem used
on tha AP exam!
Actor Bug Flower Rock Critta ChameleonCritter
34. Which be afolse statement bout Bug movement?
(A) A Bug can move on a gangbangin' finger-lickin' diagonal line across tha grid.
(B) If a Flower is directly up in front of a Bug, tha Bug will replace tha Flower in
the Flowerz location.
(C) If a Rock is directly up in front of a Bug, tha Bug,will not chizzle its location.
(0) If a Bug be all up in tha edge of tha grid, tha Bug will chizzle its direction to
Location. I aint talkin' bout chicken n' gravy biatch. RIGHT + its current direction.
(E) It be possible fo' a Bug ta turn all up in a cold-ass lil complete circle without changing
its location.
35. Consider a hustla whose current direction is Location.NORTHWEST. Da following
method call is made fo' dis hustla:
setDirection(getDirection() + Location.HALF_LEFT);
What tha fuck iz tha int value of tha hustlaz resultin direction?
(A) 0
(B) 45
(C) 90
(0) 225
(E) 270
36. Right back up in yo muthafuckin ass. Suppose Bug n' BoxBug behavior is ghon be modified ta allow bugs n' box bugs to
move onto Rocks up in tha same way dat they move onto Flowers. Which classes
will need ta be modified ta effect dis chizzle?
I Playa
IT Bug
III BoxBug
(A) I only
(B) IT only
(C) monly
(0) IT n' m only
(E) I, IT, n' m
GO ON TO THE NEXT PAGE.
27
28 Practice Exams
37. Consider tha lil' small-ass bounded grid up in tha diagram.
o 2
o  <i ~="" 2="" it="" shows="" a="" red="" bug="" facin="" uptown="" at="" (0,="" 2);="" funky-ass="" black="" rock="" (1,="" 0);="" n'="" blue="" chameleoncritta="" downtown="" 1)="" fo'="" realz.="" afta="" one="" step="" of="" tha="" simulation,="" the="" is="" northeast="" location="" 2),="" still="" 0).="" which="" represents="" legitimate="" state="" chameleoncri="" tter.?="" (a)="" color="" blue,="" (2,="" 1),="" direction="" south.="" (b)="" black,="" eastside.="" (c)="" red,="" (1,2),="" northeast.="" (d)="" 0),="" northwest.="" (e)="" 38.="" da="" moveto="" method="" playa="" class="" would="" not="" be="" suitable="" followin="" oper-ations,="" biatch?="" yo="" ass="" may="" assume="" dat="" each="" scenario="" below="" contained="" in="" context="" two-dimensionizzle="" grid.="" capturin="" piece="" up="" chess="" (namely,="" removin="" from="" board="" and="" takin="" its="" place="" on="" board).="" movin="" checkers="" fuck="" into="" empty="" location.="" rearrangin="" furniture="" room="" has="" rectangular="" floor="" plan.="" changin="" reserved="" seat="" ta="" another="" theata="" arrangement="" seats.="" placin="" two="" monkeys="" same="" cage="" zoo,="" where="" zoo="" rectan~="" gular="" cages.="" go="" to="" next="" page.="" practice="" exam="" level="" diagnostic="" test="" 39.="" consider="" bounded="" grid="" shown,="" 1).="" o="" 3="" if="" 4="" ="" t,.,="" <~="" i="" ,="" h="" playaz="" turn="" act,="" valid="" possibilitizzles="" freshly="" smoked="" location,="" (1)="" critter="" (2)="" chameleoncritter="" 2)="" (3,0),="" (3,="" (2,2),="" (3,3),="" 3),="" (1,3),="" (0,2),="" (0,3)="" (0,0),="" (1,0),="" (2,0),="" (2,2)="" (0,2)="" (3,2)="" 40.="" right="" back="" muthafuckin="" ass.="" suppose="" program="" chizzled="" so="" critta="" allowed="" age="" will="" start="" 1,="" have="" incremented="" by="" 1="" time="" acts,="" you="" can="" put="" yo'="" toast.="" make="" dis="" chizzle,="" private="" instizzle="" variable="" ,added="" class,="" as="" well="" accessor="" method,="" getage="" constructor="" provided="" initializes="" 1.="" what="" other="" chizzlez="" must="" made?="" act="" modified.="" ii="" iii="" tta="" overridden.="" only="" pt="" i,="" ii,="" end="" section="" 29="" 30="" computer="" science="" time-l="" minute="" 45="" minutes="" number="" thangs-4="" percent="" total="" grade-50="" exams="" directions:="" show="" all="" your="" work..="" remember="" that="" segments="" are="" written="" java.="" write="" lyrics="" pencil="" booklet="" provided.="" notes:="" classes="" quick="" reference="" done="" been="" imported="" needed.="" unless="" otherwise="" stated,="" parametas="" calls="" null="" methodz="" called="" when="" they="" preconditions="" satisfied.="" freestylin="" solutions="" question,="" use="" any="" accessible="" listed="" defined="" question.="" aint="" talkin'="" bout="" chicken="" gravy="" biatch.="" significant="" amountz="" code="" replaced="" cold-ass="" lil="" call="" these="" methods="" receive="" full="" credit.="" problem="" designin="" stockltem="" model="" shit="" stock="" shelf="" store.="" item="" includes="" following:="" description="" item.="" an="" identitizzle="" positizzle="" integer.="" price="" dollars,="" rounded="" nearest="" cent="" (two="" decimal="" places).="" particular="" shelf.="" pimped,="" assigned="" thugged-out="" description,="" identity="" number,="" price,="" operations="" include="" retrieve="" set="" remove="" some="" quantitizzle="" (if="" attempt="" made="" mo'="" than="" shelf,="" removed).="" add="" wri~e="" declaration="" class.="" chizzle="" appropriate="" names.="" provide="" functionalitizzle="" specified="" above.="" data="" representation="" consistent="" wit="" justification="" do="" implementation="" or="" constructor(s)="" {implementation}="" under="" header="" shit.="" for="" example,="" gotz="" chizzledescription.="" indicate="" ,like="" this:="" hood="" void="" chizzledescription(strin="" newdescription)="" {="" }="" store,="" list="" objects="" store="" partially="" below:="" arraylist<stockltem=""> myStockList; Iiall stock items
Ilin dis store
Ilconstructors n' other methodz not shown
IIPrecondition: myStockList gotz nuff Stockltem with
II identitizzle number idNum.
IIPostcondition: All instancez of Stockltem wit identity
II number idNum done been straight-up removed
II from tha shelf. This Stockltem, however,
II is still up in myStockList.
hood void removeAll(int idNum)
{ 1* ta be implemented up in dis part *1 }
Write tha Store method removeAll, which searches fo' tha Stockltem in
myStockList whose identitizzle number matches idNum n' removes all instances
of dat item from tha shelf. Yo ass may assume dat myStockList do
contain tha Stockltem wit identitizzle number idNum.
In freestylin removeAll, you may use any of tha methodz of tha StockItem
class dat you specified up in part (a).
Complete method remove All below:
IIPrecondition: myStockList gotz nuff Stockltem with
I I identi ty number idNum.
IIPostcondition: All instancez of Stockltem wit identity
II number idNum done been straight-up removed
II from tha shelf. This Stockltem, however,
II is still up in myStockList.
hood void removeAll(int idNum)
GO ON TO THE NEXT PAGE.
31
32 Practice Exams
2 fo' realz. A WordSet, shown up in tha class declaration below, stores a set of Strin objects in
no particular order n' gotz nuff no duplicates. Each word be a sequence of capital
lettas only.
hood class WordSet
{
}
//private data thugz not shown
//Constructor initializes set ta empty.
hood WordSet()
{ /* implementation not shown */ }
//Returns number of lyrics up in set.
hood int size()
{ /* implementation not shown */ }
//Addz word ta set (no duplicates).
hood void insert(Strin word)
{ /* implementation not shown */ }
//Removes word from set if present, else do nothing.
hood void remove(Strin word)
{ /* implementation not shown */ }
//Returns kth word up in alphabetical order, where 1 &lt;= k &lt;= size().
hood Strin findkth(int k)
{ /* implementation not shown */ }
//Returns legit if set gotz nuff word, false otherwise.
hood boolean gotz nuff(Strin word)
{ /* implementation not shown */ }
Da findkth method returns tha kth word up in alphabetical order up in tha set, even
though tha implementation of WordSet may not be sorted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da number k ranges
from 1 (correspondin ta first up in alphabetical order) ta N, where N is tha number
of lyrics up in tha set. For example, if WordSet s stores tha lyrics {"GRAPE" ,
"PEAR", "FIG", "APPLE"}, here is tha joints when s.findkth(k) is called.
k jointz of s. f indkth (k)
1 APPLE
2 FIG
3 GRAPE
4 PEAR
GO ON TO THE NEXT PAGE.
Practice Exam One / Level A Diagnostic Test
(a) Write a cold-ass lil client method countA dat returns tha number of lyrics up in WordSet
s dat begin wit tha letta "A." In freestylin countA, you may call any of the
methodz of tha WordSet class fo' realz. Assume dat tha methodz work as specified.
Complete method countA below.
IIPostcondition: Returns tha number of lyrics up in s dat begin
II wit "A."
hood static int countA(WordSet s)
(b) Write a cold-ass lil client method removeA dat removes all lyrics dat begin wit "A."
If there be no such lyrics up in s, then removeA do nothing. In writing
removeA, you may call method countA specified up in part (a) fo' realz. Assume that
countA works as specified, regardless of what tha fuck you freestyled up in part (a).
Complete method removeA below:
IIPostcondition: WordSet s gotz nuff no lyrics dat begin wit "A",
II but is otherwise unchanged.
hood static void removeA(WordSet s)
(c) Write a cold-ass lil client method commonElements dat returns tha WordSet containing
just dem elements occurrin up in both of its WordSet parameters.
For example, if sl is {"BE", "NOT", "AFRAID"} n' s2 is {"TO", "BE",
"OR", "NOT"}, then commonElements(sl, s2) should return tha WordSet
{"BE", "NOT"}. (If yo ass is familiar wit mathematical set theory,
commonElements returns tha intersection of sl n' s2.)
Complete method commonElements below.
IIPostcondition: Returns tha set containin only tha elements
I I dat occur up in both sl n' s2.
hood static WordSet commonElements(WordSet sl, WordSet s2)
GO ON TO THE NEXT PAGE.
33
34 Practice Exams
3. This question refers ta tha Sentence class below. Note: A word be a strang of
consecutizzle nonblank (and nonwhitespace) characters. For example, tha sentence
"Wuz crackalackin' there!" her big-ass booty holla'd.
consistz of tha four lyrics
"Wuz crackalackin' there!" her big-ass booty holla'd.
hood class Sentence
{
}
private Strin mySentence;
private int myNumWords;
IIConstructor. Shiiit, dis aint no joke. Creates sentence from Strin str.
II Findz tha number of lyrics up in sentence.
IIPrecondition: Lyrics up in str separated by exactly one blank.
hood Sentence(Strin str)
{ 1* ta be implemented up in part (a) *1 }
hood int getNumWords()
{ return myNumWords; }
hood Strin getSentence()
{ return mySentence; }
IIReturns copy of Strin s wit all blanks removed.
IIPostcondition: Returned strang gotz nuff just one word.
private static Strin removeBlanks(Strin s)
{ 1* implementation not shown *1 }
IIReturns copy of Strin s wit all lettas up in lowercase.
//Postcondition: Number of lyrics up in returned strang equals
II number of lyrics up in s.
private static Strin 10werCase(Strin s)
{ 1* implementation not shown *1 }
IIReturns copy of Strin s wit all punctuation removed.
IIPostcondition: Number of lyrics up in returned strang equals
II number of lyrics up in s.
private static Strin removePunctuation(Strin s)
{ 1* implementation not shown *1 }
(a) Complete tha Sentence constructor as started below. Da constructor assigns
str ta mySentence. Yo ass should write tha subsequent code dat assigns
a value ta myNumWords, tha number of lyrics up in mySentence.
Complete tha constructor below:
IIConstructor. Shiiit, dis aint no joke. Creates sentence from Strin str.
II Findz tha number of lyrics up in sentence.
IIPrecondition: Lyrics up in str separated by exactly one blank.
hood Sentence(Strin str)
{
mySentence = str;
GO ON TO THE NEXT PAGE.
Practice Exam One / Level A Diagnostic Test
(b) Consider tha problem of testin whether a strang be a palindrome fo' realz. A palin.
drome readz tha same ol' dirty from left ta right n' right ta left, ignorin spaces,
punctuation, n' capitalization. I aint talkin' bout chicken n' gravy biatch. For example,
A Gangsta lived as a thugged-out devil at NASA.
Flo, gin be a sin! I golf.
Eva; can I stab bats up in a cold-ass lil cave?
A hood method isPalindrome be added ta tha Sentence class yo. Here is the
method n' its implementation:
IIReturns legit if mySentence be a palindrome, false otherwise.
hood boolean isPalindrome()
{
}
Strin temp = removeBlanks(mySentence)j
temp = removePunctuation(temp)j
temp = lowerCase(temp)j
return isPalindrome(temp, 0, temp.length() - l)j
Da overloaded isPalindrome method contained up in tha code be a private recursive
helper method, also added ta tha Sentence class. Yo ass is ta write
the implementation of dis method. Y'all KNOW dat shit, muthafucka! Well shiiiit, it takes a "purified" strang as a parameter,
namely one dat has been stripped of blanks n' punctuation n' be all
lowercase letters. Well shiiiit, it also takes as parametas tha straight-up original gangsta n' last index of the
string. Well shiiiit, it returns legit if dis "purified" strang be a palindrome, false otherwise.
A recursive algorithm fo' testin if a strang be a palindrome be as bigs up:
 If tha strang has length 0 or 1, itz a palindrome.
 Remove tha straight-up original gangsta n' last letters.
 If dem two lettas is tha same, n' tha remainin strang be a palindrome,
then tha original gangsta strang be a palindrome. Otherwise itz not.
Complete tha isPalindrome method below:
1* Private recursive helper method dat tests whether a substring
* of strang s be a palindrome.
* start is tha index of tha straight-up original gangsta characta of tha substring.
* end is tha index of tha last characta of tha substring.
* Precondition: s gotz nuff no spaces, punctuation, or capitals.
* Postcondition: Returns legit if tha substrin be a palindrome,
* false otherwise. *1
private static boolean isPalindrome(Strin s, int start, int end)
GO ON TO THE NEXT PAGE.
35
36 Practice Exams
4. This question involves reasonin bout tha code from tha GridGhetto Case Study.
A Quick Reference ta tha case study is provided as part of dis exam.
Consider definin a freshly smoked up kind of ChameleonCri tter, a HungryChameleon, dat attempts
to smoke a Bug when it acts, n' you can put dat on yo' toast. If it succeedz up in smokin a funky-ass bug, a HungryChameleon
. do not chizzle color. Shiiit, dis aint no joke. If it fails ta eat, then it chizzlez colpr up in tha same way
a ChameleonCritta do fo' realz. Afta smokin or changin color, a HungryChameleon
moves like a ChameleonCritter n' shiznit yo. Here be a partial definizzle of tha class
HungryChameleon.
1**
* A HungryChameleon smokes neighborin bugs if there be any;
* otherwise it takes on tha color of neighborin hustlas as it
* moves all up in tha grid.
*1
hood class HungryChameleon extendz ChameleonCritter
{
}
1**
* Gets a list of adjacent bugs.
* ~param hustlas tha list of all adjacent neighbors
* ~return a list of adjacent bugs
*1
private ArrayList<bug> getBugs(ArrayList<actor> hustlas)
{ 1* ta be implemented up in part (a) *1 }
1**
* Randomly "eats" one of tha bugs up in tha list of bugs.
* Precondition: bugs.size() &gt; O.
* ~param bugs tha list of adjacent bugs
*1
private void eatBug(ArrayList<bug> bugs)
{ 1* ta be implemented up in part. (b) *1 }
1**
* Gets a list of adjacent neighborin bugs n' smokes one.
* If there be no bugs ta eat, tha HungryChameleon takes
* on tha color of a neighborin hustla.
* ~param hustlas tha list of all adjacent neighbors
*1
hood void processActors(ArrayList<actor> hustlas)
{ 1* ta be implemented up in part (c) *1 }
(a) Write tha private HungryChameleon method getBugs. This method should
return a list of adjacent neighborin hustlas dat is bugs.
Complete method git Bugs below.
1**
* Gets a list of adjacent bugs.
* ~param hustlas tha list of all adjacent neighbors
* ~return a list of adjacent bugs
*1
private ArrayList<bug> getBugs(ArrayList<actor> hustlas)
GO ON TO THE NEXT PAGE.
Practice Exam One / Level A Diagnostic Test
(b) Write tha private HungryChameleon method eatBug. Method eatBug randomly
selects a Bug from its bugs parameta n' "eats" (i.e. removes) dat shit.
Complete method eatBug below.
1**
* Randomly "eats" one of tha bugs up in tha list of bugs.
* Precondition: bugs.size() &gt; O.
* @param bugs tha list of adjacent bugs
*1
private void eatBug(ArrayList<bug> bugs)
(c) Override tha processActors method of tha ChameleonCritta superclass.
A HungryChameleon processes hustlas by gettin a list of neighborin bugs
and randomly selectin one ta eat. If there be no bugs ta eat, the
HungryChameleon takes on tha color of one of its neighbors, behavin just
like a ChameleonCritter.
Complete method processActors below.
1**
* Gets a list of adjacent neighborin bugs n' smokes one.
* If there be no bugs ta eat, tha HungryChameleon takes
* on tha color of a neighborin hustla.
* @param hustlas tha list of all adjacent neighbors
*1
hood void processActors(ArrayList<actor> hustlas)
END OF EXAMINATION
37
38 Practice Exams
ANSWER KEY (Section I)
1.D 15. C 29. C
2. B 16 fo' realz. A 30 fo' realz. A
3 fo' realz. A 17. E 31. C
4. C 18 fo' realz. A 32. E
5. B 19. E 33. D
6 fo' realz. A 20. B 34. D
7 fo' realz. A 21. E 35. E
8. B 22. D 36. B
9. C 23. E 37. D
10. B 24 fo' realz. A 38. E
11 fo' realz. A 25. C 39 fo' realz. A
12. C 26. D 40. B
13. B 27. B
14. E 28 fo' realz. A
DIAGNOSTIC CHART FOR LEVEL A EXAM
Each multiple-choice question has a cold-ass lil complete explanation (p. 40).
Da followin table relates each question ta sections dat you should review. For
any given question, tha topic(s) up in tha chart represent tha concept(s) tested up in tha question.
These topics is explained on tha correspondin page(s) up in tha chart n' should
provide further insight tha fuck into answerin dat question.
Diagnostic Chart fo' Level A Exam 39
~1(t~".~;:&lt;;;\)"f,:~~ . ~.~~i.W~
Question Topic Page
~~.~~:':F.-~:!.; .<t~f.'":':'.i":~""f)~"'it!'\,~~. 1="" inheritizzle="" 190="" 2="" implementin="" classes="" 265="" 3="" constructors="" 151="" 4="" .="" div="" n'="" mod="" operators="" 120="" 5="" da="" tostrin="" method="" 227="" classcastexception="" 195="" 6="" passin="" parametas="" 291="" 7="" i="" 8="" fo'="" loop="" 128="" 9="" program="" justification="" 261="" 10="" recursion="" 339="" 11="" boolean="" expressions="" 123="" 12="" hexadecimal="" 119="" 13="" indexoutofboundsexceptionforarraylist="" 298="" 14="" abstract="" 196="" 15="" subclass="" supa="" keyword="" 16="" polymorphizzle="" 193="" 17="" swap="" 292="" 18="" roundin="" real="" numbers="" 118="" 19="" 342="" 20="" selection="" insertion="" sort="" 524="" 21="" calls="" "~="" 22="" compound="" ~="" 23="" strin="" class="" equals="" 229="" substrin="" 231="" 24="" round-off="" error="" 25="" array="" processin="" 290="" 26="" assertions="" bout="" algorithms="" 269="" f="" binary="" search="" 535="" 27="" 28="" random="" integers="" 236="" 29="" postconditions="" 270="" 30="" 31="" relationships="" between="" 268="" 32="" of="" objects="" 294="" !="" arraylist="" 297="" 33="" nullpointerexception="" 158="" 34="" bug="" movement="" 570="" 35="" location="" constants="" 566="" 36="" 37="" chameleoncri="" tta="" description="" 575="" 38="" moveto="" playa="" 39="" cri="" 573="" chameleoncritterclass="" 40="" l~'="">lm~_,'=~~,~~.''''''''-'"~l'i'Il''-'''''~'''''''''''.'''''-~''''~')''1£'''''~'ll'£&lt;~''''''c",,,.. 2!~~
40 Practice Exams
ANSWERS EXPLAINED (Section I)
1. (D) Constructors is never inherited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If a subclass has no constructor, tha default
constructor fo' tha superclass is generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha superclass aint gots a
default constructor, a cold-ass lil compile-time error will occur.
2. (B) Da programmer is rockin a object-oriented approach ta freestylin tha program
and plans ta test tha simplest classes first. This is bottom-up pimpment. In topdown
development (choice A), high-level classes is fucked up down tha fuck into subsidiary
classes. Procedural abstraction (choice C) is tha use of helper methodz up in a cold-ass lil class.
Hype hidin (choice D) is restriction of access ta private data n' methods
in a cold-ass lil class. Chizzle E is wack cuz a thugged-out driver program is one whose sole purpose
is ta test a given method or class. Implementin tha simplest classes first may
involve driver programs dat test tha various methodz yo, but tha overall plan is not
an example of a thugged-out driver program.
3. (A) In tha constructor, tha private instizzle variablez mySui t n' myValue must
be initialized ta tha appropriate parameta joints, n' you can put dat on yo' toast. Chizzle A is tha only chizzle
that do dis .
. 4. (C) Spades is represented by myDeck [0] ... myDeck [12] yo. Hearts is represented
by myDeck[13] ... myDeck[25]. Therefore tha erect test fo' hearts is if(i/13
== 1) n' tha erect assignment is myDeck[i] = .... Da expression on the
right-hand side must use tha Card constructor. Shiiit, dis aint no joke. Da erect Card value (second
parameter) be a int from 0 ta 12. This is erectly obtained wit i Y. 13.
S. (B) Implementation Pt II invokes tha toStrin method of tha Card class. Implementation
I fails cuz there is no default toStrin method fo' arrays. Implementation
ill will cause a ClassCastException: Yo ass cannot cast a Card ta a
String.
6. (A) Da array aint gonna be chizzled by tha increment method. Y'all KNOW dat shit, muthafucka! Here is the
memory slots:
Before tha straight-up original gangsta call, increment (3):
testArray
0----.1 3 14 15 1
Just before exitin increment (3):
testArray
0----.1 3 14 15 1
n
G
Just afta tha straight-up original gangsta call:
testArray
0----.1 3 14 15 1
n o
Just afta exitin increment (3):
testArray
0----.1 3 14 15 1
Da same analysis applies ta tha method calls increment (4) n' increment (5).
7. (A) As up in tha previous question, tha array aint gonna be chizzled by tha increment
method. Y'all KNOW dat shit, muthafucka! Nor will tha local variable element son! What tha fuck iz ghon be chizzled by increment
is tha copy of tha parameta durin each pass all up in tha loop.
Answers Explained
8. (B) Da maximum number is ghon be  bigged up  if 1* test *1 is legit up in each pass
all up in tha loop. Right back up in yo muthafuckin ass. So tha question boils down to: How tha fuck nuff times is tha loop
executed, biatch? Try one odd n' one even value of n:
Ifn=7, i=0,2,4,6
If n = 8, i = 0,2,4,6
Ans =4
Ans =4
Notice dat chizzle B is tha only expression dat works fo' both n = 7 n' n = 8.
9. (e) Here is one of tha golden rulez of programming: Don't start plannin the
program until every last muthafuckin aspect of tha justification is crystal clear fo' realz. A programmer
should never make unilateral decisions bout ambiguitizzles up in a justification'.
10. (B) When x :::: y, a recursive call is made ta whatIslt(x-l, y). If x decreases
at every last muthafuckin recursive call, there is no way ta reach a successful base case. Thus, the
method never terminates n' eventually exhausts all available memory.
11. (A) Da expression ! (max ! = a [i]) is equivalent ta max == a [i] , so tha given
expression is equivalent ta a [i] == max I I max == a [i] , which is equivalent to
a[i] == max.
12. (e) A base-b number can be represented wit b characters. Thus, base-2 uses
0,1 fo' example, n' base-l0 uses 0,1'00.,8,9 fo' realz. A hexadecimal (base-16) number
is represented wit 16 characters: 0,1'00.,8, 9,A,B,C,D,E,F, where A = 10,B =
11, ... ,F = 15. Da phattest two-place base-2 integer is
11 = 1 x 2° + 1 X 21 = 3
Da phattest two-place base-l0 integer is
99 = 9 x 10° + 9 X 101
Da phattest two-place base-16 integer is
FF = F x 16° + F x 161
Da characta F represents 15, so
FF = 15 x 16° + 15 x 161 = 255
Herez another way ta be thinkin bout dis problem: Each hex digit is 4 binary digits
(bits), since 16 = 24. Therefore a two-digit hex number is 8 bits, n' you can put dat on yo' toast. Da phattest
base-l0 number dat can be represented wit 8 bits is 28 - 1 = 255.
13. (B) Da index range fo' ArrayList is 0:::: index:::: sizeO-1. Thus, fo' methods
get, remove, n' set, tha last in-boundz index is sizeO-1. Da one exception is
the add method-to add a element ta tha end of tha list takes a index parameter
list.sizeO.
14. (E) Subclassez of Quadrilateral may also be abstract, up in which case they will
inherit perimeta and/or area as abstract methods.
15. (e) Segment I starts erectly but fails ta initialize tha additionizzle private variables
of tha Rectangle class. Right back up in yo muthafuckin ass. Segment Pt II is wack cuz by rockin supa with
topLeft n' botRight, it implies dat these joints is used up in tha Quadrilateral
superclass. This is false-there aint even a cold-ass lil constructor wit three arguments in
the superclass.
41
42 Practice Exams
16. (A) Durin execution tha appropriate area method fo' each quad up in quadList
will be determined (polymorphizzle or dynamic binding).
17. (E) Da algorithm has three steps:
1. Right back up in yo muthafuckin ass. Store tha object at i up in temp.
2. Place at location i tha object at j.
3. Place temp at location j.
This has tha effect of swappin tha objects at i n' j. Notice dat chizzlez B and
C, while incomplete, is not incorrect. Da question, however, asks fo' tha best
description of tha postcondition, which is found up in chizzle E.
18. (A) Subtractin 0.5 from a wack real number n' then truncatin it produces
the number erectly rounded ta tha nearest integer n' shit. Note dat castin ta a int
truncates a real number n' shit. Da expression up in chizzle B is erect fo' roundin a
positizzle real number n' shit. Chizzle C won't round erectly. For example, -3.7 will be
rounded ta -3 instead of -4. Chizzlez D n' E don't make sense. Why cast to
double if you roundin ta tha nearest integer?
19. (E) Da method call whatsIt(347) puts on tha stack System. up . print (7).
Da method call whatsIt(34) puts on tha stack System. out.print (4).
Da method call whatsIt (3) be a funky-ass base case n' writes up 3.
Now tha stack is popped from tha top, n' tha 3 dat was printed is followed by
4, then 7. Da result is 347.
20. (B) Recall dat insertion sort takes each element up in turn n' (a) findz its insertion
point n' (b) moves elements ta bang dat element up in its erect place. Thus, if
the array is up in reverse sorted order, tha insertion point will always be all up in tha front
of tha array, leadin ta tha maximum number of comparisons n' data movesvery
inefficient. Therefore chizzlez A, C, n' E is false.
Selection sort findz tha smallest element up in tha array n' swaps it wit a[O]
and then findz tha smallest element up in tha rest of tha array n' swaps it with
a [1], n' so on. I aint talkin' bout chicken n' gravy biatch. Thus, tha same number of comparisons n' moves will occur,
irrespectizzle of tha original gangsta arrangement of elements up in tha array. Right back up in yo muthafuckin ass. So chizzle B is
true, n' chizzle D is false.
21. (E) Method call I fails cuz ClassOne aint gots access ta tha methodz of
its subclass. Method call Pt II fails cuz c2 need ta be cast ta ClassTwo ta be able
to access methodTwo. Thus, tha followin would be OK:
«ClassTwo) c2).methodTwo();
Method call Pt III works cuz ClassTwo inherits methodOne from its superclass,
ClassOne.
22. (0) Notice dat up in tha original gangsta code, if n is 1, k is incremented by 1, n' if n is 4,
k is incremented by 4. This is equivalent ta sayin "if n is 1 or 4, k is incremented
byn."
23. (E) Segment I'ma throw a NullPointerException when s. equals. .. is invoked,
because s be a null reference. Right back up in yo muthafuckin ass. Segment Pt III looks suspect,' but when
the start Index parameta of tha substrin method equals s.le~hO, the
value returned is tha empty string. If, however, start Index &gt; s . length 0, a
StringIndexOutOfBoundsExceptionisthrown.
Answers Explained
24. (A) Since thangs up in dis biatch of calculations wit floating-point numbers is not always represented
exactly (round-off error), direct tests fo' equalitizzle is not reliable. Instead
of tha boolean expression d == c, a test should be done ta check whether tha difference
of d n' c is within some aaight tolerizzle interval (see tha Box on
comparin floating-point numbers, p. 122).
25. (C) If arr has elements 2, 3, 5, tha jointz of value are
2 //afta initialization
2*10 + 3 = 23 //when i = 1
23*10 + 5 = 235 //when i = 2
26. (0) Da point of tha binary search algorithm is dat tha interval containin key
is repeatedly narrowed down by splittin it up in half. For each iteration of the
while loop, if key is up in tha list, arr [first] ::: key ::: arr [last]. Note dat (i)
the endpointz of tha interval must be included, n' (ii) key aint necessarily in
the list.
27. (8)
first last mid a [mid]
Afta first iteration 0 13 6 50
Afta second iteration 7 13 10 220
Afta third iteration 7 9- 8 101
Afta fourth iteration 9 9 9 205
28. (A) Da data structure be a array, not a ArrayList, so you cannot use tha add
method fo' insertin elements tha fuck into tha list. This eliminates chizzlez Band D. The
expression ta return a random integer from 0 ta k-l inclusive is
(int) (Math.random() * k)
Thus, ta git integers from 0 ta 100 requires k ta be 101, which eliminates chizzle
C. Chizzle E fails cuz it gets integers from 1 ta 100.
29. (C) Suppose, fo' example, strl is strawberry n' str2 is cat. Then bang (strl,
str2, 5) will return tha followin pieces, concatenated:
straw + pussaaaaay + berry
= aOata2a3a4 + bObt b2 +aSa6a7aga9
= aOata2a3a4bobt b2aSa6a7aga9
30. (A) Recall dat s. substrin (k, m) (a method of String) returns a substrin of
s startin at posizzle k n' endin at posizzle m-1 fo' realz. Again consider tha example
in which strl is strawberry, str2 is cat, n' tha method call is bang (strl,
str2, 5). Right back up in yo muthafuckin ass. Strin strl must be split tha fuck into two parts, first n' last. Then str2
will be banged between dem wild-ass muthafuckas. Right back up in yo muthafuckin ass. Since str2 is banged startin at posizzle 5 (the
"b"), first = straw, namely str1.substring(O,pos). (Start at 0 n' take all
the charactas up ta n' includin location pos-l, namely 4.) Notice dat last,
the second substrin of strl, must start all up in tha index fo' "b", which is pos, the
index at which str2 was inserted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da expression strl. substrin (pos) returns
the substrin of strl dat starts at pos n' continues ta tha end of tha string,
which was required. Y'all KNOW dat shit, muthafucka! Note dat you don't need any "special case" tests, n' you can put dat on yo' toast. In the
cases where str2 is banged all up in tha front of strl (i.e., pos is 0) or tha back of strl
(i.e., pos is strl.length 0, tha code fo' tha general case works.
43
44 Practice Exams
31. (C) Composizzle is tha has-a relationshizzle_ A PlayerGroup has-a Player (several
of them, up in fact). Inheritance, (choice D) is tha is-a relationshizzle, which don't
apply here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. None of tha chizzlez A, B, or E apply up in dis example: An intercourse
is a single class composed of only abstract methodz (see p. 198); encapsulation is
the bundlin together of data fieldz n' operations tha fuck into a single unit, a cold-ass lil class (see
p. 263); n' PlayerGroup n' Player is clearly dependent on each other since
PlayerGroup gotz nuff nuff muthafuckin Player objects (see p. 265).
32. (E) All of these data structures is reasonable. They all represent 20 bingo numbers
in a cold-ass lil convenient way n' provide easy as fuck  mechanizzlez fo' crossin off numbers
and recognizin a ballin card. Y'all KNOW dat shit, muthafucka! Notice dat data structure n serves up a hella
quick way of searchin fo' a number on tha card. Y'all KNOW dat shit, muthafucka! For example, if 48 is called,
myBingoCard[48] is inspected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If it is true, then dat shiznit was one of tha 20 original
numbers on tha card n' gets crossed out. If false, 48 was not on dat playa's
card. Y'all KNOW dat shit, muthafucka! Data structures I n' n require a linear search ta find any given number
that is called. Y'all KNOW dat shit, muthafucka! (Note: There is no assumption dat tha array is sorted, which
would allow a mo' efficient binary search.)
33. (0) A NullPointerException is thrown whenever a attempt is made ta invoke
a method wit a object dat aint been pimped wit new. Chizzle A don't
make sense: To test tha Calla constructor requires a statement of tha form
Calla c - freshly smoked up Caller();
Choice B is wrong: A missin return statement up in a method triggers a cold-ass lil compiletime
error. Shiiit, dis aint no joke. Chizzle C don't make sense: In tha declaration of myNumbers, its
default initialization is ta null. Chizzle E is bizarre yo. Hopefully you eliminated it
immediately!
34. (0) Location. I aint talkin' bout chicken n' gravy biatch. RIGHT is 90 fo' realz. A Bug dat don't move, however, turns right through
45°, or Location. I aint talkin' bout chicken n' gravy biatch yo. HALF _RIGHT. Chizzle A could happen if tha Bug is facin northeast,
for example, at its turn ta move. If there be no obstaclez up in its path, tha Bug
will keep movin up in dat direction, on a gangbangin' finger-lickin' diagonal path. For chizzle B, refer ta the
bugz canMove method, n' notice dat tha Bug can move either tha fuck into a empty
location or onto a Flower n' shit. Well shiiiit, it may not, however, move onto a Rock, so chizzle C
is true. Chizzle E will happen whenever a Bug is blocked up in all adjacent locations,
either by a hustla other than a Flower or a edge of tha grid. Y'all KNOW dat shit, muthafucka! Da Bug can't move,
so it keeps on turnin right.
35. (E) getDirectionO = Location.NORTHWEST
=315
Location. I aint talkin' bout chicken n' gravy biatch yo. HALF_LEFT = -45
Answer: 315 - 45 ~ 270
36. (8) Da canMove method up in tha Bug class is tha only code dat need ta be
changed. Y'all KNOW dat shit, muthafucka! Here is tha chizzle:
return (neighbor == null) I I (neighbor instanceof Flower)
I I (neighbor instanceof Rock);
Note dat tha BoxBug class do not need ta be chizzled. Y'all KNOW dat shit, muthafucka! In tha act method, the
inherited canMove method will now return legit if tha location up in front of the
BoxBug is empty, or .gotz nuff a gangbangin' flower, or gotz nuff a rock. Da Playa class too
Answers Explained
does not need ta be chizzled. Y'all KNOW dat shit, muthafucka! Da movero method specifies dat if there be another
Actor all up in tha freshly smoked up location, dat hustla is ghon be removed.
37. (0) Da ChameleonCritta randomly picks either tha rock or tha bug, and
changes its color ta match dat of tha selected hustla. Eliminizzle chizzle A-the
ChameleonCri tta cannot remain blue. Next, tha ChameleonCri tta moves to
an empty neighborin location, changin its direction ta match tha direction in
which it moved. Y'all KNOW dat shit, muthafucka! Eliminizzle chizzle B, since (1, 1) aint a empty neighboring
location. I aint talkin' bout chicken n' gravy biatch. Chizzlez C n' E both chizzle color erectly n' move ta a valid location.
Da ChameleonCritter, however, endz up facin tha wack direction. I aint talkin' bout chicken n' gravy biatch. The
direction from (1, 1) ta (1, 2) is eastside, not northeast. Da direction from (1, 1) to
(2, 0) is southwest, not south.
38. (E) Da justification fo' movero states that
 tha hustla is ghon be moved ta a freshly smoked up location .
 if there be a already another hustla up in dis location, it is ghon be removed.
Da key here is dat two hustlas may not occupy tha same location simultaneously.
Therefore, you cannot use movero ta place two Monkey objects up in tha same
location at a zoo.
39. (A) Da Critta will smoke tha bugs up in (0, 0) n' (1, 2) n' tha flower up in (2,0),
leavin dem locations empty n' available fo' realz. Also available is tha other empty
locations: (2, 1), (2,2), n' (0, 2). Da ChameleonCritta don't smoke its neighbors,
so tha only available locations is tha ones dat was empty ta begin with:
(2, 1), (2,2), n' (0, 2).
40. (B) Da act method of tha Critta class must be chizzled so dat tha age variable
is increased by 1 each time act is called. Y'all KNOW dat shit, muthafucka! Statement I is wack cuz not
all hustlas age. Right back up in yo muthafuckin ass. Statement Pt III is wack cuz a ChameleonCri tta inherits the
Cri tterz act method.
45
46
Section Pt II
1. (a) hood class Stockltem
{
}
private Strin myDescription;
private int myldNum;
private double myPrice;
private int myNumOnShelf;
hood Stockltem(Strin description, int id,
double price, int numOnShelf)
{ implementation }
hood Strin getDescription()
{ implementation }
hood int getldNum()
{ implementation }
hood double getPrice()
{ implementation }
hood int getNumOnShelf()
{ implementation }
hood void setPrice(double newPrice)
{ implementation }
hood void remove(int quantity)
{ implementation }
hood void add(int quantity)
{ implementation }
(b) hood void removeAll(int idNum)
{
}
int i = 0;
while (myStockList.get(i).getldNum() != idNum)
i++;
Stockltem item = myStockList.get(i);
item.remove(item.getNumOnShelf(»;
Alternatively,
hood void removeAll(int idNum)
{
}
for (Stockltem item : myStockList)
{
}
if (item.getldNum() == idNum)
{
}
item.remove(item.getNumOnShelf(»;
break;
Practice Exams
Answers Explained
NOTE
 Da while loop up in tha straight-up original gangsta solution fo' part (b) aint gonna cause a out-ofrange
error, since tha precondizzle guarantees dat a StockItem wit the
given identitizzle number is up in tha list. If dis aint guaranteed, you need to
start tha while loop test wit i <mystocklist .="" size="" (~="" ="" in="" tha="" alternatizzle="" solution="" shown="" fo'="" part="" (b)="" you="" wanna="" exit="" method="" as="" soon="" required="" stockitem="" has="" been="" found="" n'="" processed.="" y'all="" know="" dat="" shit,="" muthafucka!="" the="" break="" statement="" gets="" outta="" loop="" hence="" method.="" da="" construct="" aint="" gonna="" be="" tested="" on="" ap="" exam.="" (b),="" don't="" make="" fuck="" up="" of="" removin="" entire="" from="" mystocklist:="" mystocklist.remove(item);="" this="" same="" recordin="" item="" currently="" a="" quantitizzle="" zero="" shelf.="" 2.="" (a)="" hood="" static="" int="" counta(wordset="" s)="" {="" }="" count="0;" while="" (count="" <="" s.size()="" &&="" s.findkth(count="" +="" l).substring(o,="" 1).equals(ia"))="" count++;="" return="" count;="" alternatively,="" boolean="" done="false;" !done)="" strin="" nextword="s.findkth(count" 1);="" if="" (nextword.substring(o,l).equals(ia"))="" else="" void="" removea(wordset="" numa="countA(s);" for="" (int="" i="1;" i++)="" s.remove(s.findkth(l));="" (s.size()="" !="0" s.findkth(1)="" .substring(o,="" 1)="" .equals(ia"))="" 47="" 48="" practice="" exams="" (c)="" wordset="" commonelements(wordset="" sl,="" s2)="" note="" temp="freshly" smoked="" wordset();="" .strin="" (s2.gotz="" nuff(nextword»="" temp.insert(nextword);="" temp;="" to="" test="" whether="" word="" starts="" with"="" a",="" must="" compare="" straight-up="" original="" gangsta="" letter="" word,="" is,="" word.="" substrin="" (0,1)="" ,="" wit="" "a".="" (a),="" check="" yo'="" works="" s="" is="" empty.="" given="" algorithm,="" s.="" ()="" will="" fail="" short="" circuit="" test,="" which="" desirable="" since="" f="" indkth="" (1)="" violate="" precondizzle="" (k),="" namely="" k="" cannot="" pimped="" outa="" than="" o.="" parameta="" s.findkth="" o="" yo.="" use="" findkth(count+l)="" (a).="" git="" subtle="" intent="" error="" your="" last="" step="" s.remove(s.findkth(i».="" right="" back="" yo="" muthafuckin="" ass.="" suppose="" initially="" {"fly",="" "ask",="" "ant"}="" realz.="" afta="" call="" s.remove(s.findkth(l»,="" "ask"}="" remove="" (s="" .findkth(2»,="" {"ask"}!!="" point="" adjusted="" each="" ta="" s.remove.="" algorithm="" this:="" n="" number="" lyrics="" start="" with="" "a",="" simply="" element="" list="" times.="" that="" avoidz="" pitfall="" busted="" bout="" by="" repeatedly="" it="" 'a."="" solution,="" however,="" its="" own="" pitfall:="" can="" being="" empty="" iteration="" loop.="" could="" also="" accomplished="" goin="" all="" s2="" and="" checkin="" itz="" included="" 81.="" 3.="" sentence(strin="" str)="" mysentence="str;" mynumlyrics="1;" pt="" ii);="" (k="" there="" still="" blanks="" str="" mynumwords++;="" blank="" get="" index="" next="" answers="" explained="" private="" ispalindrome(strin="" s,="" start,="" end)="" (start="">= end) //substrin has length 0 or 1
return true;
else
{
}
Strin first = s.substring(start, start + 1);
Strin last = s.substring(end, end + 1);
if (first.equals(last»)
return isPalindrome(s, start + 1, end - 1);
else
return false;
 In part (a), fo' every last muthafuckin occurrence of a funky-ass blank up in mySentence, myNumWords
must be incremented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Be shizzle ta initialize myNumLyrics ta I!)
 In part (a), tha code locates all tha blanks up in mySentence by replacin str
with tha substrin dat consistz of tha piece of str directly followin the
most recently located blank.
 Recall dat indexOf returns -1 if its Strin parameta do not occur as a
substrin up in its Strin callin object.
 In part (b), tha start n' end indexes move toward each other wit each
subsequent recursive call. This shortens tha strang ta be tested up in each
call. When start n' end meet, tha base case has been reached.
 Notice tha private static methodz up in tha Sentence class, includin the
helper method you was axed ta write. They is static cuz they
are not invoked by a Sentence object (no dot member construct). The
only use of these methodz is ta help big up tha post conditionz of other
methodz up in tha class.
4. (a) private ArrayList<bug> getBugs(ArrayList<actor> hustlas)
{
}
ArrayList<bug> bugs = freshly smoked up ArrayList<bug>();
for (Actor a : hustlas)
{
}
if (a instanceof Bug)
bugs.add«Bug)a);
return bugs;
(b) private void eatBug(ArrayList<bug> bugs)
{
}
int n = bugs.size();
int r = (int) (Math.random() * n);
Bug b = bugs.get(r);
b.removeSelfFromGrid();
49
50
(c) hood void processActors(ArrayList<actor> hustlas)
{
}
NOTE
ArrayList<bug> bugList = getBugs(actors);
if (bugList.size() == 0)
super.processActors(actors);
else
eatBug(bugList);
Practice Exams
 In part (a), tha bugs ArrayList gotz nuff only Bug objects, n' you can put dat on yo' toast. Notice dat in
the fo' loop, tha object a dat is bein examined be a Playa. Therefore
you need tha cast ta Bug up in tha add statement up in tha body of tha loop .
 In part (c), if there be at least one bug up in bugList, tha HungryChameleon
will eat; otherwise it will do what tha fuck its superciass, ChameleonCritter, do:
super.processActors(actors);
Practice Exam Two / Level AB Diagnostic Test
.............._ ___. ....._ ___m u_ _u wr~~W&amp;~ __._ ._ ___m mmm _______
PRACTICE EXAM TWO I LEVEL AB DIAGNOSTIC TEST
LU ,,-.&amp;15 .....
Da exam dat bigs up has tha same ol' dirty format as dat used on tha actual AP exam. There
are two ways you may use it:
t fo' realz. As a gangbangin' finger-lickin' diagnostic test before you start reviewing. Peepin tha answer key be a
diagnostic chart dat relates each question ta sections dat you should review.
In addition, complete explanations is provided fo' each solution. I aint talkin' bout chicken n' gravy biatch. .
2 fo' realz. As a practice exam when you have completed yo' review.
Complete solutions wit explanations is provided fo' tha free-response
questions.
51

Answer Sheet: Practice Exam Two
1. ®®©@® 15. ®®©@® 29. ®®©@®
2. ®®©@® 16. ®®©@® 30. ®®©@®
3. ®®©@® 17. ®®©@® 31. ®®©@®
4.®®©@® 18. ®®©@® 32. ®®©@®
5.®®©@® 19. ®®©@® 33. ®®©@®
6.®®©@® 20. ®®©@® 34. ®®©@®
7.®®©@® 21. ®®©@® 35. ®®©@®
8.®®©@® 22. ®®©@® 36. ®®©@®
9. ®®©@® 23. ®®©@® 37. ®®©@®
10. ®®©@® 24. ®®©@® 38. ®®©@®
11. ®®©@® 25. ®®©@® 39. ®®©@®
12. ®®©@® 26. ®®©@® 40. ®®©@®
13. ®®©@® 27. ®®©@®
14. ®®©@® 28. ®®©@®
How tha fuck ta Calculate Yo crazy-ass (Approximate) AP Score - AP Computa Science Level AB
Multiple Chizzle
Number erect (out of 40)
1/4 x number wrong
Raw score = line 1 - line 2
Raw score x 1.25
Jacked Response
Question 1
(out of9)
Question 2
(out of9)
Question 3
(out of9)
Question 4
(out of9)
Total
Final Score
+
Multiple- Free-
ChoIce Response
Score Score
= Multiple-Choice Score
(Do not round. Y'all KNOW dat shit, muthafucka! If less
than zero; enta zero.)
x 1.39
Final Score
(Round ta nearest
whole number.)
Chart ta Convert ta AP Grade
Computa Science AB
Final AP Gradea
Score Range
70-100 5
60-69 4
41-59 3
31-40 2
0-30 1
aDa score range correspondin to
each grade varies from exam ta exam
and be approximate.
= Free-Response Score
(Do not round.)
Practice Exam Two / Level AB Diagnostic Test
Practice Exam Two
COMPUTER SCIENCE AB
SECTION I
Time-1 minute n' 15 minutes
Number of thangs-40
Percent of total grade-50
Directions: Determine tha answer ta each of tha followin thangs or incomplete
statements, rockin tha available space fo' any necessary scratchwork.
Then decizzle which is tha dopest of tha chizzlez given n' fill up in tha corresponding
oval on tha answer sheet. Do not spend too much time on mah playas problem.
Notes:
 Assume dat tha classes up in tha Quick Reference done been imported where
needed.
 Assume dat tha implementation classes ListNode n' TreeNode up in the
Quick Reference is used fo' any thangs referrin ta linked lists or
trees, unless otherwise stated.
 ListNode n' TreeNode parametas may be null. Otherwise, unless noted
in tha question, assume dat parametas up in method calls is not null, and
that methodz is called only when they preconditions is satisfied.
 Assume dat variablez n' methodz is declared up in tha context of a enclosing
class.
 Assume dat method calls dat have no object or class name prefixed, and
that 'are not shown within a cold-ass lil complete class definition, step tha fuck up within the
context of a enclosin class.
55
5&amp; Practice Exams
1 fo' realz. A program is ta be freestyled dat simulates n' keeps track of tha random motion
of a point whose posizzle is represented by coordinates (x,y). Da point starts at
(0,0) at time = O. Well shiiiit, it is ta move randomly a big-ass yo, but unknown, number of times.
A record of its (x,y) positions must be kept so as ta be able ta re-create any part
of its path startin from a given previously recorded (x,y) position. I aint talkin' bout chicken n' gravy biatch. Da program
is ta print tha pointz (x,y) movements, forward or backward up in time, from the
given (x,y) position. I aint talkin' bout chicken n' gravy biatch. Yo ass may assume dat no point is hit up mo' than once.
Assumin tha existence of a Point class dat holdz a p~r of coordinates, which of
the followin is tha dopest data structure fo' tha task?
(A) A one-dimensionizzle array of Point objects
(B) A two-dimensionizzle array of integers up in which tha array indexes represent
the posizzle hit up by tha point n' each integer cell of tha array be a
counta dat keeps track of tha number of moves ta dat position
(C) A circular doubly linked list of Point objects
(0) A stack of Point objects
(E) A queue of Point objects
GO ON TO THE NEXT PAGE.
Practice Exam Two / Level AB Diagnostic Test
Thangs 2-4 refer ta tha TennisPlayer, GoodPlayer, n' WeakPlayer classes below.
These classes is ta be used up in a program ta simulate a game of tennis.
hood abstract class TennisPlayer
{
}
private Strin myName;
Ilconstructor
hood TennisPlayer(Strin name)
{ myName = name; }
hood Strin getName()
{ return myName; }
hood abstract boolean serve();
hood abstract boolean serviceReturn();
hood class GoodPlayer extendz TennisPlayer
{
Ilconstructor
hood GoodPlayer(Strin name)
{ 1* implementation not shown *1 }
IIPostcondition: Return legit if serve is up in (80% probability),
II false if serve is up (20% probability).
hood boolean serve()
{ 1* implementation not shown *1 }
IIPostcondition: Return legit if steez return is in
II (70% probability), false if steez return
II is up (30% probability).
hood boolean serviceReturn()
{ 1* implementation not shown *1 }
}
hood class WeakPlayer extendz TennisPlayer
{
II constructor
hood WeakPlayer(Strin name)
{ 1* implementation not shown *1 }
IIPostcondition: Return legit if serve is up in (45% probability),
II false if serve is up (55% probability).
hood boolean serve()
{ 1* implementation not shown *1 }
IIPostcondition: Return legit if steez return is in
II (30% probability), false if steez return
II is up (70% probability).
hood boolean serviceReturn()
{ 1* implementation not shown *1 }
}
GO ON TO THE NEXT PAGE.
57
58
A ALSOPractice
Exams
2. Which of tha followin declarations will cause a error, biatch? Yo ass may assume all the
constructors is erectly implemented.
(A) TennisPlayer t '" freshly smoked up TennisPlayer(ISmith"):
(B) TennisPlayer g = freshly smoked up GoodPlayer(IJones"):
(C) TennisPlayer w '" freshly smoked up WeakPlayer(IHenry");
0) TennisPlayer p;
(E) WeakPlayer q '" freshly smoked up WeakPlayer(IGrady"):
3. Refer ta tha serve method up in tha WeakPlayer class:
IIPostcondition: Return legit if serve is up in (45% probability),
II false if serve is up (55% probability).
hood boolean serve()
{ 1* implementation *1 }
Which of tha followin replacements fo' 1* implementation *1 satisfy tha postcondition
of tha serve method?
I double value = Math.random():
return value &gt;= 0 I I value &lt; 0.45:
II double value = Math.random():
return value &lt; 0.45:
III int val '" (int) (Math.random() * 100)
return val &lt; 45:
(A) I only
(B) Pt II only
(C) 1lI only
0) Pt II n' Pt III only
(E) I, ll, n' 1lI
GO ON TO THE NEXT PAGE.
Practice Exam Two / Level AB Diagnostic Test
4. Consider tha followin class definition:
hood class Beginner extendz WeakPlayer
{
private double myCostOfLessons;
//methodz of Beginner class
}
Refer ta tha followin declarations n' method up in a cold-ass lil client program:
TennisPlayer g = freshly smoked up GoodPlayer(ISam");
TennisPlayer w = freshly smoked up WeakPlayer(IHarry");
TennisPlayer b = freshly smoked up Beginner(IDick");
hood void giveEncouragement(WeakPlayer t)
{ /* implementation not shown */ }
Which of tha followin method calls aint gonna cause a error?
(A) giveEncouragement«WeakPlayer) g);
(B) giveEncouragement«WeakPlayer) b);
(C) giveEncouragement«Beginner) w);
0) giveEncouragement(w);
(£) giveEncouragement(b);
GO ON TO THE NEXT PAGE.
59
A ALSO
60 Practice Exams
5. Inorder n' postorder traversals yield tha same output fo' which of tha following
trees?
(A) P
/ " A K
(C) P
/
A
\
K
/
s
(E) P
\
A
/ \
K S
\
s
(B)
(0)
P
/
A
/
K
/
s
P
/ \
A S
/
K
6. Worst case run time is never O(n2) fo' which of tha followin sortin algorithms?
I Mergesort
II Heapsort
III Quicksort
(A) Ionly
(B) Pt II only
(C) Pt III only
(0) I n' Pt II only
(E) I, Pt II, n' Pt III
GO ON TO THE NEXT PAGE.
Practice Exam Two / Level AB Diagnostic Test
7 fo' realz. An array wit no duplicate joints is ta be sorted tha fuck into increasin order using
heapsort. Right back up in yo muthafuckin ass. Step one is ta bang tha elementz of tha array sequentially tha fuck into a maxheap.
(Recall dat a max-heap wit no duplicates be a cold-ass lil complete binary tree in
which tha value up in each node is larger than tha joints up in its childrenz nodes.)
H tha given array is 6 7 1 9 2 0 8, what tha fuck will tha contentz of tha max-heap
be afta all tha elements is inserted?
(A) (B)
(C) (D)
(E)
8. Which is legit of tha followin boolean expression, given dat x be a variable of
type double?
3.0 == x * (3.0 / x)
(A) It will always evaluate ta false.
(B) It may evaluate ta false fo' some jointz of x.
(C) It will evaluate ta false only when x is zero.
(D) It will evaluate ta false only when x is straight-up big-ass or straight-up close ta zero.
(E) It will always evaluate ta true.
GO ON TO THE NEXT PAGE.
61
A ALSO
62 Practice Exams
9. Refer ta tha removeWord method below:
//Precondition: wordList be a ArrayList of String.
//Postcondition: All occurrencez of word removed from wordList.
hood void removeWord(ArrayList<string> wordList, Strin word)
{
/ * implementation code * I
}
Which 1* implementation code *1 will produce tha required postcondition?
I Iterator<string> itr = wordList.iterator();
while (itr.hasNext(»
{
}
if (itr.next().equals(word»
itr.removeO;
IT Iterator<string> itr = wordList.iterator();
int i = 0;
while (itr.hasNext(»
{
}
if (itr.next().equals(word»
wordList.remove(i);
i++;
ITI fo' (int i = 0; i &lt; wordList.size(); i++)
{
}
if (wordList.get(i).equals(word»
wordList.remove(i);
(A) lonly
(B) IT only
(C) monly
(D) I n' IT only
(E) land m only
GO ON TO THE NEXT PAGE.
Practice Exam Two / Level AB Diagnostic Test
Assume dat linked lists is implemented wit tha ListNode class provided.
Refer ta method insertBlank fo' Thangs 10 n' 11.
IIPrecondition: current refers ta a node up in a linear linked
II list of characta strings. current aint null.
IIPostcondition: Da node followin tha node dat current
II refers ta gotz nuff a funky-ass blank.
hood static void insertBlank(ListNode current)
Examples:
Before callin insertBlank Afta callin insertBlank
Example 1
current current cp rr -I "A" 1,+-1 "E" It- -I "A" l t-1~1.t-1 "E" l~+-
Example 2
current current cp cp
-I "E" It-I "F" V1 -I "E" I t-I "F" l +-1 . " Pt III
10. Which of tha followin could be used as tha body of insertBlank such dat its
postcondizzle is satisfied?
I current.setNext(new ListNode(" ", current.getNext(»);
II ListNode p = freshly smoked up ListNode (" ". current. getNext 0 ) ;
current = p;
III ListNode p = freshly smoked up ListNode(null. null);
p.setNext(current.getNext(»;
p.setValue(" Pt II);
current.setNext(p);
(A) I only
(B) Pt II only
(C) ill only
(0) I n' Pt II only
(E) I n' ill only
GO ON TO THE NEXT PAGE.
63
64 Practice Exams
11 fo' realz. A method padList, whose code is given below, is ta bang a funky-ass blank between each
pair of existin nodes up in its parameter, list, a linked list of characta strings. For
example, if tha list is initially
list cp
"A" I I -I "B" 1 '1 -I "C" LI1
padList (list) should result in
list cp
"A" I I -I Pt II .. I I -I "B" I I -I Pt II Pt II I I -I "C" ltM .",~
U there be fewer than two nodes up in tha list, then tha list should remain unchanged.
IIPrecondition: list refers ta a linear linked list of n character
I I strings. n &gt;= o.
II Da list represents tha sequence sl.s2 ... sn.
IIPostcondition: list refers ta tha linear linked list representing
I I S1'" ". Right back up in yo muthafuckin ass. S2 ." " ... " ". sn' Da list remains
II unchanged if 0 &lt;= n &lt; 2.
hood static void padList(ListNode list)
{
}
if (list != null)
{
}
ListNode temp = list;
while (temp.getNext() != null)
{
}
insertBlank(temp)j
temp = temp.getNext()i
Assumin dat tha precondizzle fo' padList is satisfied, fo' which lists will
padList work erectly?
(A) For all linear linked lists
(B) For no linear linked lists
(C) Only fo' lists dat contain fewer than two nodes
(0) Only fo' lists dat contain exactly one node
(E) Only fo' empty lists
GO ON TO THE NEXT PAGE.
Practice Exam Two / Level AB Diagnostic Test
12. Da binary tree shown is traversed preorder n' shit. Durin tha traversal, each element,
when accessed, is pushed onto a initially empty stack z of String. What output
is produced when tha followin code is executed?
while (!s.isEmpty(»
System.out.print(s.pop(»;
(A) AKCPRF
(B) CKRFPA
(C) FPRACK
(D) APFRKC
(E) FRPCKA
A
/"'.
K P
\ / \
C R F
65
66 Practice Exams
Thangs 13 n' 14 refer ta tha followin class n' declaration.
hood class DigitalClock
{
}
Ilprivate instizzle variablez n' constructors not shown
IIReturns legit if dis DigitalClock is defective, false otherwise.
hood boolean isDefective()
{ 1* implementation not shown *1 }
IIMutator method. Y'all KNOW dat shit, muthafucka! Advances tha DigitalClock by one minute.
hood void advanceTime()
{ 1* implementation not shown *1 }
Ilother methodz not shown ...
Da declaration below occurs up in a cold-ass lil client class.
ArrayList<digitalclock> clocks = freshly smoked up ArrayList<digitalclock>();
13. Right back up in yo muthafuckin ass. Suppose dat tha ArrayList clocks has been initialized n' gotz nuff a nonempty
list of Digi talClock objects, n' you can put dat on yo' toast. Which of tha followin code segments will erectly
remove all defectizzle clocks?
I fo' (DigitalClock c : clocks)
{
}
if (c.isDefective(»
c.removeO;
IT fo' (int index - 0; index &lt; clocks.size(); index++)
{
if (clocks.get(index).isDefective(»
clocks.remove(index);
}
nrr Iterator<digitalclock> itr = clocks.iterator();
while (itr.hasNext(»
{
}
if (itr.next().isDefective(»
itr.removeO;
(A) I only
(B) IT only
(C) nrr only
(D) IT n' nrr only
(E) I, IT, n' nrr
GO ON TO THE NEXT PAGE.
Practice Exam Two / Level AB Diagnostic Test
14 fo' realz. Again, suppose dat clocks is initialized. Y'all KNOW dat shit, muthafucka! Assume dat it gotz nuff a nonempty
list of erectly functionin Digi talClock objects, n' you can put dat on yo' toast. Which of tha followin code
segments will erectly advizzle tha time on every last muthafuckin digital clock?
I fo' (DigitalClock c : clocks)
{
c.advanceTime();
}
IT fo' (int index = 0; index &lt; clocks.size(); index++)
{
clocks.get(index).advanceTime();
}
III Iterator<digitalclock> itr = clocks.iterator()
while (itr.hasNext(»
{
itr.next().advanceTime();
}
(A) Ionly
(B) IT only
(C) Pt III only
(D) IT n' Pt III only
(E) I, IT, n' Pt III
15 fo' realz. A big-ass charitizzle organization maintains a thugged-out database of its donors. For each donor,
the followin shiznit is stored: name, address, beeper number, amount and
date of most recent contribution, n' total contributed so far. Shiiit, dis aint no joke. Two plans for
organizin n' modifyin tha data is considered:
I A one-dimensionizzle array of Donor objects maintained up in alphabetical order
by name.
IT A hash table of Donor objects implemented rockin a array of linked lists.
Da hash address fo' any given Donor object is ghon be determined by a hash
method dat uniformly distributes donors all up in tha table.
Which of tha followin is false, biatch? (Assume da most thugged-out efficient algorithms possible.)
(A) Plans I n' IT have roughly tha same memory efficiency.
(B) Insertion of a freshly smoked up donor is mo' run-time efficient rockin plan IT.
(C) Modifyin a existin donorz record is mo' run-time efficient rockin plan
IT.
(D) Printin up a mailin list up in alphabetical order is mo' run-time efficient
usin plan 1.
(E) Printin up a list of donors up in decreasin order of total amount contributed
is mo' run-time efficient rockin plan I.
GO ON TO THE NEXT PAGE.
67
68
16. Consider a cold-ass lil class dat has dis private instizzle variable:
private int[] [] mat;
Da class has tha followin method, alter.
hood void alter(int c)
{
for (int i - 0; i &lt; mat. length; i++)
}
for (int j = c + 1; j &lt; mat[O].length; j++)
mat [i] [j-1] = mat [i] [j] ;
If a 3 x 4 matrix mat is
1 357
2 4 6 8
3 5 7 9
then alta (1) will chizzle mat to
(A) 1 5 7 7
2 6 8 8
3 7 9 9
(B) 1 5 7
268
379
(C) 1 3 5 7
357 9
(D) 1 3 5 7
3 5 7 9
357 9
(E) 1 7 7 7
288 8
.3 9 9 9
Practice Exams
GO ON TO THE NEXT PAGE.
Practice Exam Two / Level AB Diagnostic Test
17. Refer ta tha followin method:
1* Deletes maximum item, i.e., item of lowest priority, from
* PriorityQueue pq.
* Precondition: pq is nonempty.
* Postcondition: Returns a PriorityQueue dat gotz nuff tha same
* elements as pq except fo' tha maximum element,
* which has been removed. Y'all KNOW dat shit, muthafucka! *1
hood PriorityQueue<type> deleteMax(PriorityQueue<type> pq)
{
}
I * code ta delete maximum item *1
return priQ;
Which of tha followin replacements fo' 1* code ta delete maximum item *1 satisfy
the postcondizzle fo' tha method?
I PriorityQueue<type> priQ = freshly smoked up PriorityQueue<type>{);
pq.remove();
priQ = pq;
II Stack<type> s = freshly smoked up Stack<type>();
while (!pq.isEmpty())
s.push(pq.remove());
s.popO;
PriorityQueue<type> priQ = freshly smoked up PriorityQueue<type>();
while (!s.isEmpty())
priQ.add(s.pop());
III Queue<type> q = freshly smoked up LinkedList<type>();
while (!pq.isEmpty{))
q.add{pq.remove());
q. remove 0 ;
PriorityQueue<type> priQ = freshly smoked up PriorityQueue<type>();
while (!q.isEmpty{))
priQ.add(q.remove());
(A) I only
(B) Pt II only
(C) ill only
(D) I n' Pt II only
(E) I n' ill only
GO ON TO THE NEXT PAGE.
69
70
A ALSO
Practice Exams
Use tha program description below fo' Thangs 18-20.
A hoopty deala needz a program dat will maintain a inventory of rides on his fuckin lot. There
are three typez of cars: sedans, station wagons, n' SUV s. Da model, year, color, and
price need ta be recorded fo' each car, plus any additionizzle features fo' tha different
typez of cars. Da program must allow tha deala to
 Add a freshly smoked up hoopty ta tha lot.
 Remove a cold-ass lil hoopty from tha lot.
 Correct any data thatz been entered.
 Display shiznit fo' any car.
18. Da programmer decides ta have these classes: Car, Inventory, Sedan, SUV, and
StationWagon. I aint talkin' bout chicken n' gravy biatch. Which statement is legit bout tha relationshizzlez between these
classes n' they attributes?
I There is no inheritizzle relationshizzlez between these classes.
II Da Inventory class has.a list of Hoopty objects.
III Da Sedan, StationWagon, n' suv classes is independent of each other.
(A) I only
(B) Pt II only
(C) Pt III only
(D) I n' Pt II only
(E) Pt II n' Pt III only
19. Right back up in yo muthafuckin ass. Suppose dat tha programmer decides ta git a Hoopty class n' a Inventory class.
Da Inventory class will maintain a list of all tha rides on tha lot yo. Here is some
of tha methodz up in tha program:
addCar
removeCar
displayCar
set Color
getPrice
displayAllCars
//addz a cold-ass lil hoopty ta tha lot
//removes a cold-ass lil hoopty from tha lot
//displays all tha featurez of a given car
//sets tha color of a cold-ass lil hoopty ta a given color
//May be used ta erect data
//returns tha price of a cold-ass lil car
//displays features fo' every last muthafuckin hoopty on tha lot
In each of tha following, a cold-ass lil class n' a method is given. I aint talkin' bout chicken n' gravy biatch. Which is tha least suitable
choice of class ta be responsible fo' tha given method?
(A) Car, setColor
(B) Car,removeCar
(C) Car, getPrice
(D) Car, displayCar
(E) Inventory,displayAIICars
GO ON TO THE NEXT PAGE.
Practice Exam Two / Level AB Diagnostic Test
20. Right back up in yo muthafuckin ass. Suppose Hoopty be a superclass n' Sedan, StationWagon, n' suv is subclasses of
Car. Shiiit, dis aint no joke. Which of tha followin is da most thugged-out likely method of tha Hoopty class ta be
overridden by at least one of tha subclasses (Sedan, StationWagon, or SUV)?
(1\) setColor(newColor) Iiset color of Hoopty ta nevColor
(B) getModel() Ilreturn model of Car
(C) displayCar() Iidisplay all featurez of Car
0) setPrice(newPrice) Iiset price of Hoopty ta newPrice
(E) getYearO /Ireturn year of Car
21. What tha fuck iz tha result of hustlin dis code segment?
Map<string, string=""> dwarfs = freshly smoked up HashMap<string, string="">();
dwarfs.put(ISneezy", "sick dwarf");
dwarfs . put ("Happy" , "merry dwarf ") ;
dwarfs.put(IGrumpy", "irritable dwarf");
Strin s = dwarfs.get(IDopey");
(1\) 1\ NoSuchElementException is ghon be thrown.
(B) 1\n I1legalStateException is ghon be thrown.
(C) 1\ ClassCastException is ghon be thrown.
0) Da code will run without error, n' s gonna git tha value Pt II Dopey Pt II 
(E) Da code will run without error, n' s gonna git tha value null.
22. 1\ssume dat ArrayList a is initialized wit Some Type elements, n' you can put dat on yo' toast. 1\lso, assume
the existence of tha followin method:
IIPostcondition: Returns a HashSet dat gotz nuff all tha elements
II of ArrayList<sometype> list.
hood HashSet<sometype> copyListToHashSet(ArrayList<sometype> list)
Consider tha followin code segment:
HashSet<sometype> s = copyListToHashSet(a);
System.out.println("Number of elements up in ArrayList is Pt II + a.sizeO);
System.out.println("Number of elements up in HashSet is Pt II + s.sizeO);
Suppose tha output produced by dis code segment is
Number of elements up in ArrayList is 10
Number of elements up in HashSet is 6
Which be a valid conclusion?
(1\) List a cold-ass lil gotz nuff ten distinct (i.e., different) elements, n' set s gotz nuff six
distinct elements.
(B) There be at least one element up in list a dat occurs mo' than once.
(C) List a cold-ass lil gotz nuff four mo' distinct elements than set s.
0) There is at least four elements up in list a dat occur mo' than once.
(E) There is one element up in list a dat occurs five times.
GO ON TO THE NEXT PAGE.
71
A ALso
72 Practice Exams
Thangs 23-25 is based on tha followin procedure, which copies shit from an
array arr conta:inin n distinct numbers tha fuck into a funky-ass binary search tree tree n' then prints
the elements.
Procedure:
Step 1: Initialize tree ta be empty.
Step 2: Insert arr [0] , arr [1] ... arr [n-t] tha fuck into tree rockin a standard algorithm
for insertion of item arr [i] tha fuck into tree. (Assume dat tha bang operation
does no balancin of tree.)
Step 3: Print tha elements stored up in tree, rockin a inorder traversal.
23. Which of tha followin dopest characterizes tha output produced up in Step 3 of the
above procedure, biatch? .
(A) Da shit is printed up in tha original gangsta order up in which they step tha fuck up in array
arr.
(B) Da shit is printed up in sorted order, from smallest ta phattest.
(C) Da shit is printed up in sorted order, from phattest ta smallest.
(0) Da shit is printed up in tha reverse of tha order up in which they step tha fuck up in
arrayarr.
(E) Da shit is printed up in random order.
24. Which dopest raps bout tha dopest case run time of tha whole procedure?
(A) 0(1)
(B) O(n)
(C) O(1ogn)
(0) O(nlogn)
(E) O(n2 )
25. Da procedure is most likely ta exhibit its dopest case run time when tha numbers
are stored up in array arr up in which of tha followin ways?
I Ascendin order
II Descendin order
m Random order
(A) Ionly
(B) Pt II only
(C) monly
(0) I n' Pt II only
(E) I, Pt II, n' m
GO ON TO THE NEXT PAGE.
Practice Exam Two / Level AB Diagnostic Test
Thangs 26 n' 27 is based on tha Computable intercourse n' Largelnt class shown
below.
hood intercourse Computable
{
}
Object add(Object obj);
Object subtract(Object obj);
Object multiply(Object obj);
Ilreturns dis object + obj
Ilreturns dis object - obj
Ilreturns dis object * obj
hood class Largelnt implements Comparable, Computable
{
}
Ilprivate instizzle variables
hood Largelnt(int n)
{
Ilconverts n ta Largelnt
}
hood Strin toString() Ilreturns dis Largelnt as a String
{
}
hood Object add(Object obj) Ilreturns dis Largelnt + obj
Ilprecondition: obj of type Largelnt
{
}
hood Object subtract(Object obj) Ilreturns dis Largelnt - obj
Ilprecondition: obj of type Largelnt
{
}
hood Object multiply(Object obj) Ilreturns dis Largelnt * obj
Ilprecondition: obj of type Largelnt
{
}
IIReturns -1 if dis Largelnt is less than obj, 1 if it is pimped outer
II than obj, n' 0 if it equals obj.
hood int compareTo(Object obj)
{
}
GO ON TO THE NEXT PAGE.
73
A ALSO
74 Practice Exams
26. Of tha followin pairz of methods, which should be coded n' tested first to
facilitate testin n' debuggin tha other methods?
(A) Da constructor n' add method
(B) Da constructor n' compareTo method
(C) Da constructor n' toStrin method
(D) Da toStrin n' compareTo methods
(E) Da toStrin n' one of tha add, subtract, or multiply methods
27. Consider tha problem of simulatin tha followin loop fo' Largelnt objects:
for (int i = 1j i &lt; nj i++)
System.out.println(i)j
Da followin code is used. Y'all KNOW dat shit, muthafucka! Yo ass may assume dat n exists n' iz of type Largelnt.
Largelnt i = freshly smoked up Largelnt(l);
Largelnt one = freshly smoked up Largelnt(l);
while (i.compareTo(n) &lt; 0)
{
}
System.out.println(i);
/ * statement * /
Which of tha followin should replace /* statement */ ta simulate tha loop erectly?
(A) i =
(B) i =
(C) i =
(D) i =
(E) i =
(Largelnt)
(Largelnt)
(Largelnt)
(Largelnt)
(Largelnt)
Ladd(one) ;
Ladd(l) ;
one.add(n);
n.add(one);
Ladd(n) ;
28 fo' realz. A mackdaddy need ta assess tha readin level of a textbook. One measure used is
the frequency of lyrics dat have six or mo' lettas fo' realz. A computa program scans
the text n' keeps track of such lyrics n' they correspondin frequencies by
storin dem up in a TreeMap data structure.
Assumin dat there be n different lyrics up in tha key set so far, which be a true
statement bout operations performed on dis frequency map?
(A) Insertion of a freshly smoked up word tha fuck into tha map is O( 1).
(B) To check whether a given word is up in tha map is O(log n).
(C) To update tha frequency of a existin word up in tha map is 0(1).
(D) To print a list of tha keySet of lyrics up in alphabetical order is O(log n ).
(E) To print a list of all word/frequency pairs is O(log n).
GO ON TO THE NEXT PAGE.
Practice Exam Two / Level AB Diagnostic Test
29 fo' realz. A set setl is holla'd ta be a subset of set2, setl £ set2, if there is no element in
setl dat aint up in set2. Consider tha isSubset method below:
IIPrecondit~on: setl n' set2 is initialized wit objectz of the
I I same type, SomeType. .
IIPostcondition: Returns legit if setl be a subset of set2, false
II otherwise.
hood boolean isSubset(Set<sometype> setl, Set<sometype> set2)
{
I * implementation code *1
}
Which 1* implementation code *1 achieves tha desired postcondition, biatch? Assume the
existence of tha followin method:
IIPostcondition: Returns a HashSet dat gotz nuff all tha elements
I I of Set s.
hood HashSet<sometype> copySetToHashSet(Set<sometype> s)
I Set<sometype> temp = copySetToHashSet(set2);
for (SomeType element : setl)
temp.add(element);
return temp.size() == set2.size();
n fo' (SomeType element : setl)
if (!set2.gotz nuff(element»
return false;
return true;
III fo' (SomeType element : setl)
{
for (SomeType e : set2)
}
if (!element.equals(e»
return false;
return true;
(A) Ionly
(B) n only
(C) Pt III only
(0) I n' n only
(E) I, n, n' Pt III
GO ON TO THE NEXT PAGE.
75
76 Practice Exams
Refer ta tha followin fo' Thangs 30 n' 31.
A word game uses certain five-letta lyrics dat is stored up in a special doggtionary file.
In tha game, no word may be used mo' than once. Da game is implemented with
the WordStatus n' WordGame classes shown:
hood class WordStatus
{
}
private boolean isUsed;
hood WordStatus O'
{ isUsed = false; }
hood boolean used() //true if word has been used, false otherwise
{ return isUsed; }
hood void chizzleStatus()
{ isUsed = !isUsed; }
hood class WordGame
{
private Map<string. wordstatus=""> m;
//other private instizzle variables
//constructor
hood WordGame()
{
}
m = freshly smoked up HashMap<string, wordstatus="">();
//initialization of other instizzle variables
/* Load hash map wit all lyrics up in tha dictionary,
* n' mark every last muthafuckin word as available fo' use. */
hood void loadDictionary(Strin fileName)
{
}
&lt; code ta open input file wit given fileName &gt;
while « there be lyrics up in input file&gt; )
{
Strin word = inFile.readWord(); //read word from input file
/ * code ta bang word tha fuck into Map m * /
}
//code ta close input file not shown
GO ON TO THE NEXT PAGE.
Practice Exam Two / Level AB Diagnostic Test
}
1* Look up word up in HasbMap m.
* If present n' not yet used, mark as used n' return true.
* Otherwise return false. *1
hood boolean isAvailable(Strin word, WordStatus status)
{
I * implementation code * I
}
Ilother methodz ta implement tha game not shown
30. Refer ta tha loadDoggtionary method up in tha WordGame class. Which is erect
1* code ta bang word tha fuck into Map m *I?
(J\) m. put (word, freshly smoked up Boolean(true)); I/a Boolean object wraps a
boolean value
(B) m. put (word, "true");
(C) m.put(word, true);
0) m.put(word, freshly smoked up WordStatus(true));
(£) m.put(word, freshly smoked up WordStatus());
GO ON TO THE NEXT PAGE.
n
78 Practice Exams
31. Right back up in yo muthafuckin ass. Suppose tha HashMap m has available lyrics correspondin ta a WordStatus where
used returns false. When a available word is found up in m, it is marked as used
by changin its WordStatus. Refer ta tha isAvailable method of tha WordGame
class:
1* Look up word up in HashMap m.
* If present n' not yet used, mark as used n' return true.
* Otherwise return false. *1
hood boolean isAvailable(Strin word)
{
1* implementation code *1
}
Which represents erect 1* implementation code */?
I if (m.gotz nuffKey(word»
{
}
WordStatus w = m.get(word);
if (!w.usedO)
{
}
w.changeStatus();
return true;
return false;
II WordStatus w = m. git (word) ;
if (m.gotz nuffKey(word»
{
}
WordStatus w = m.get(word);
if (!w.usedO)
w.changeStatus();
return w.used();
III if (!m.gotz nuffKey(word»
return false;
else
{
WordStatus w = m.get(word);
if (! w . used 0 )
{
}
}
(A) I only
(B) Pt II only
(C) Pt III only
w.changeStatus();
return true;
(0) I n' Pt II only
(E) I, Pt II, n' Pt III
GO ON TO THE NEXT PAGE.
Practice Exam Two I Level AB Diagnostic Test
32. Consider tha followin binary tree of single-characta Strin joints:
What tha fuck iz ghon be output by tha followin code segment?
Queue<treenode> q = freshly smoked up LinkedList<treenode>()j
//LinkedList implements Queue
if (root == null)
System.out.println("Empty tree")j
else
{
q.add(root)j
while (!q.isEmpty(»
{
TreeNode current = q.remove()j
System.out.print(current.getValue(»j
if (current.getLeft() != null)
q.add(current.getLeft(»j
if (current.getRight() != null)
q.add(current.getRight(»j
}
}
(A) MJFALR
(B) MFRJLA
(C) AJLMFR
(0) MFJRLA
(E) AJMFLR
GO ON TO THE NEXT PAGE.
79
80 Practice Exams
33 fo' realz. Assume dat doubly linked lists is implemented wit tha DoublyListNode class
below: .
hood class DoublyListNode
{
}
private Object value:
private DoublyListNode next, prev:
hood DoublyListNode(DoublyListNode initPrev, Object initValue,
DoublyListNode initNext)
{
}
prev = initPrev;
value = initValue:
next = initNext:
hood DoublyListNode getPrev()
{ return prev: }
hood void setPrev(DoublyListNode theNewPrev)
{ prev = theNewPrev: }
hood Object getValue()
{ return value; }
hood void setValue(Object theNewValue)
{ value = theNewValue; }
hood DoublyListNode getNext()
{ return next: }
hood void setNext(DoublyListNode theNewNext)
{ next = theNewNext: }
For tha doubly linked list shown below, which of tha followin code segments
will remove tha node containin b from tha list, biatch? Peepin execution of the
segment, list may refer ta any element of tha list. (Note dat arrows pointin to
the right correspond ta next n' dem ta tha left correspond ta prev.)
list
GO ON TO THE NEXT PAGE.
Practice Exam Two / Level AB Diagnostic Test
I list.setNext(list.getNext().getNext(»;
list.getNext().getNext().setPrev(list);
IT list.getNext().getNext().setPrev(list);
list.setNext(list.getNext().getNext(»;
III list = list.getNext().getNext();
(list.getPrev().getPrev(».setNext(list);
list.setPrev(list.getPrev().getPrev(»;
(A) I only
(B) IT only
(C) Pt III only
(0) I n' IT only
(E) IT n' Pt III only
GO ON TO THE NEXT PAGE.
81
82 Practice Exams
34 fo' realz. Assume dat binary trees is implemented wit tha TreeNode class provided.
Refer ta method mTree:
//Returns a reference ta a newly pimped tree.
hood TreeNode mTree(TreeNode t)
{
if (t == null)
return null;
else
return new TreeNode(t.getValue(), mTree(t.getRight(»,
mTree(t.getLeft(»);
}
Suppose p = mTree (t) is invoked fo' tha tree shown .
.It
Which of tha followin trees is ghon be pimped?
(A) ,/p (B) ,/p
(C) ,/p (D) ,/p
(E)
GO ON TO THE NEXT PAGE.
Practice Exam Two / Level AB Diagnostic Test
Thangs 35-40 involve reasonin bout tha code from tha GridGhetto Case Study.
A Quick Reference ta tha case study is provided as part of dis exam. Da hustlas in
GridGhetto is represented up in dis book wit tha pictures shown below. Each hustla is
shown facin north. These pictures almost certainly is ghon be different from dem used
on tha AP exam!
Actor Bug Flower Rock Critta ChameleonCritter
35. Consider a cold-ass lil class PoisonousCritta dat extendz Critter n' shiznit fo' realz. A PoisonousCritter
marks its suckas by changin tha color of all its adjacent neighbors-except
rocks-to green. I aint talkin' bout chicken n' gravy biatch. Rocks remain unchanged. Y'all KNOW dat shit, muthafucka! Da PoisonousCritta then selects
one of its suckas at random, n' "kills" it by movin tha fuck into its location. I aint talkin' bout chicken n' gravy biatch. Which
groupz of Critta methodz will need ta be overridden?
1 act n' getActors
IT processActors n' getMoveLocations
ill selectMoveLocation n' makeMove
(A) lonly
(B) IT only
(C) monly
(0) IT n' ill only
(E) I, IT, n' m
GO ON TO THE NEXT PAGE.
83
84
A ALSO
Practice Exams
36. Consider tha bounded grid shown.
o 2
o ~
~
2  Da Flower up in (0, 0) is yellow. Da ChameleonCritta up in (1, 1) is blue .. Da Bug
in (2, 2) is purple fo' realz. A valid setup afta a cold-ass lil call ta act fo' tha ChameleonCri tta only
1S
(A) o 2 o 2 (B)
o o ~
~
2 2  ChameleonCri tta is purple ChameleonCri tta is yellow
(C) o
(D)
~
2 o 2
o ~ o
2  2 ~  ChameleonCri tta is yellow ChameleonCri tta is purple
(E) o 2
o ~
2 ~  ChameleonCri tta is yellow
GO ON TO THE NEXT PAGE.
Practice Exam Two / Level AB Diagnostic Test
37. Durin a run of tha GridGhetto program, up in addizzle ta nuff other hustlas, a Bug,
a Critter, n' a ChameleonCri tta is pimped up in a UnboundedGrid. Y'all KNOW dat shit, muthafucka! While the
program is hustlin, it is noticed dat these three hustlas disappear from tha visible
part of tha grid. Y'all KNOW dat shit, muthafucka! If tha program continues ta run, which hustla may become visible
again, without tha screen settin bein adjusted?
I tha Bug
II tha Critter
III tha ChameleonCri tter
(A) None
(B) I only
(C) Pt II only
(D) monly
(E) I, Pt II, n' m
85
86 Practice Exams
38. Refer ta tha getValidAdjacentLocations method up in tha AbstractGrid class.
Lines is numbered fo' reference.
hood ArrayList<location> getValidAdjacentLocations(Location loc)
2 {
3 ArrayList<location> locs = freshly smoked up ArrayList<location>();
4
5 int d = Location. I aint talkin' bout chicken n' gravy biatch. NORTH;
6 fo' (int i = 0;
7 i &lt; Location.FULL_CIRCLE / Location. I aint talkin' bout chicken n' gravy biatch yo. HALF_RIGHT; i++)
8 {
9 Location neighborLoc = loc.getAdjacentLocation(d);
10 if (isValid(neighborLoc))
11 locs.add(neighborLoc);
12 d = d + Location. I aint talkin' bout chicken n' gravy biatch yo. HALF_RIGHT;
13 }
14 return locs;
15 }
Which of tha followin modificationz of tha method would be equivalent ta the
original?
I Replace lines 5-7 with:
int d = 0;
for (int i = 0; i &lt; 8; i++)
II Replace lines 6 n' 7 with:
for (int i = Location. I aint talkin' bout chicken n' gravy biatch. NORTH;
i &lt; Location.FULL_CIRCLE / Location. I aint talkin' bout chicken n' gravy biatch yo. HALF_RIGHT; i++)
III Replace line 12 with:
d += 45;
(A) None
(B) I only
(C) Pt II only
(D) Pt III only
(E) I, Pt II, n' Pt III
GO ON TO THE NEXT PAGE.
Practice Exam Two / Level AB Diagnostic Test
39 fo' realz. A slight modification is made ta tha BoxBug class: One of tha turn statements is
removed. Y'all KNOW dat shit, muthafucka! Here is tha modified act method.
hood void act()
{
}
if (steps &lt; sideLength &amp;&amp; canMove())
{
}
else
{
}
move 0 ;
steps++;
turnO;
steps = 0;
Assumin dat there be no impediments up in tha grid, which be a possible result of
executin dis code nuff muthafuckin times?
(A) (B)
        . .      
(C) (D) ..          "     
(E)
      
GO ON TO THE NEXT PAGE.
87
A ALSO
88 Practice Exams
40. Right back up in yo muthafuckin ass. Suppose there be n hustlas up in a grid. Y'all KNOW dat shit, muthafucka! What tha fuck iz tha big-O time complexitizzle fo' the
remove method in
(1) tha BoundedGrid class n' (2) tha UnboundedGrid class?
(A) (1) 0(1) (2) O(logn)
(B) (1) O(n) (2) O(logn)
(C) (1) 0(1) (2) O(n)
(0) (1) 0(1) (2) 0(1)
(E) (1) O(n) (2) O(n)
END OF SECTION I
Practice Exam Two / Level AB Diagnostic Test
COMPUTER SCIENCE AB
SECTION Pt II
Time-l minute n' 45 minutes
Number of thangs-4
Percent of total grade-50
Directions: SHOW ALL YOUR WORK. REMEMBER THAT
PROGRAM SEGMENTS ARE TO BE WRITTEN IN Java.
Write yo' lyrics up in pencil only up in tha booklet provided.
Notes:
 Assume dat tha classes up in tha Quick Reference done been imported where
needed.
 Assume dat tha implementation classes ListNode n' TreeNode is used
for any thangs referrin ta linked lists or trees, unless otherwise specified.
 ListNode n' TreeNode parametas may be null. Otherwise, unless noted
in tha question, assume dat parametas up in method calls is not null, and
that methodz is called only when they preconditions is satisfied.
 In freestylin solutions fo' each question, you may use any of tha ,accessible
methodz dat is listed up in classes defined up in dat question: Freestylin significant
amountz of code dat can'be replaced by a cold-ass lil call ta one of these methods
may not receive full credit.
1 fo' realz. A lil' small-ass zoo has both muthafuckas n' birds:
 Goats dat bleat n' smoke grass.
 Pigs dat squeal n' smoke swill.
 Turkeys dat gobble n' smoke grain.
 Elf owls dat hoot n' smoke insects.
 Snowy owls dat hoot n' smoke either hares, lemmings, or lil' small-ass birds, whichever
are available.
Suppose yo ass is ta write a program dat simulat~s tha zoo.
GO ON TO THE NEXT PAGE.
89
90 Practice Exams
(a) Draw a gangbangin' finger-lickin' diagram dat represents a Animal class hierarchy. Yo crazy-ass diagram
should show tha relationshizzle between all tha objects up in tha program, with
Animal as tha superclass fo' all tha other objects, n' you can put dat on yo' toast. Each class up in yo' design
should be represented by a labeled rectangle, n' arrows should show the
inheritizzle relationshizzlez between classes.
(b) Write tha code fo' tha Animal class. Each Animal has a name, a type of covering
(fur, feathers, scales, etc.), n' its own particular noise dat it makes.
When a freshly smoked up animal is constructed, it must be assigned a name, noise, and
covering. Each of these can be represented wit a String. Operations on
an Animal include tha following:
 Retrieve tha name of tha animal.
 Retrieve tha noise of tha animal.
 Retrieve tha coverin of tha animal.
 Retrieve tha chicken of tha animal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. This should be a abstract method:
Da appropriate chicken fo' each animal is ghon be busted lyrics bout up in its particular
.class.
(c) Given tha code fo' a Bird class below, write tha code fo' a Owl class.
hood abstract class Bird extendz Animal
{
}
II constructor
hood Bird(Strin name, Strin noise)
{
super(name, noise, "feathers");
}
An Owl be a Bird dat hoots (its noise!). Da chicken it smokes dependz on the
type of Owl fo' realz. Assumin dat tha Animal n' Bird classes done been erectly
defined, write tha Owl class below.
(d) Write tha code fo' a SnowyOwl class fo' realz. A SnowyOwl be a Owl dat will randomly
eat a hare, a lemming, or a lil' small-ass bird (dependin on whatz available!). The
SnowyOwl class should bust a random number ta help determine which chicken
the SnowyOwl will eat.
Assumin dat tha Animal, Bird, n' Owl classes done been erectly defined,
write tha SnowyOwl class below.
GO ON TO THE NEXT PAGE.
Practice Exam Two I Level AB Diagnostic Test
2. This question involves reasonin bout tha code from tha GridGhetto Case Study.
A Quick Reference ta tha case study is provided as part of dis exam.
Consider definin a freshly smoked up type of Critter, a Frog, which moves by jumpin over
other hustlas fo' realz. A Frog acts by randomly selectin one of its adjacent neighboring
actors, n' turnin ta grill dat shit. If tha location adjacent ta dat hustla up in tha direction
that tha Frog is facin is valid n' empty, tha froggy frog jumps over dat hustla tha fuck into that
location. I aint talkin' bout chicken n' gravy biatch. Otherwise, it do not move. If a gangbangin' froggy frog has no adjacent hustlas ta begin
with, it do nothing. Da diagram below illustrates what tha fuck a Frog may do.
o 2 3
o ,
"" &lt;~~. . ~ I ,
2 tv'~.
~~1
3  4
Note dat fo' tha Frog up in location (2, 2) there be four adjacent neighbors. The
table below shows tha outcomes fo' each of tha four neighbors, one of which will
be randomly selected.
Actor selected
Critta up in (1, 1)
Rock up in (1,2)
Flower up in (1, 3)
Bug up in (3,2)
Frogz final location
(0,0)
(2,2)
(2,2)
(4,2)
Frogz final direction
.- - . -
northwest
north
northeast
south
Da Frog class is defined by extendin tha Critta class n' overridin tha processActors
and act methods. Two additionizzle methods, getJumpLocation and
canJump, is ghon be defined.
A partial definizzle of class Frog is shown on tha next page.
GO ON TO THE NEXT PAGE.
91
92 Practice Exams
1**
* A Frog jumps over neighborin hustlas as
* it moves all up in tha grid.
*1
hood class Frog extendz Critter
{
}
1**
* Randomly selects a neighbor n' turns ta grill dat shit.
* Gets tha possible jump location, which is tha location
* adjacent ta tha selected neighbor up in tha same direction
* from tha Frog. If tha Frog can jump, it will move ta the
* jump location. I aint talkin' bout chicken n' gravy biatch. Otherwise it aint gonna chizzle its location~
* If tha list of hustlas is empty, tha Frog do nothing.
* ~param hustlas tha list of adjacent neighbors
*1
hood void processActors(ArrayList<actor> hustlas)
{ 1* ta be implemented up in part (c) *1 }
1**
* A froggy frog acts by gettin a list of its adjacent neighbors,
* n' processin dem wild-ass muthafuckas.
*1
hood void act()
{
}
if (getGrid 0 null)
return;
ArrayList<actor> hustlas getActors();
processActors(actors);
1**
* Returns tha location dat is two locations away from this
* Frog, up in tha same direction dat tha Frog is faCing. This
* location may be invalid.
* Precondition: adjacent is tha location of tha neighbor ta be
* jumped over n' shit. Well shiiiit, it aint empty.
* ~param adjacent tha location of tha neighbor ta be jumped
* over
* ~return tha two-away location up in tha same direction as the
* frog
*1
private Location getJumpLocation(Location adjacent)
{ 1* ta be implemented up in part (a) *1 }
1**
* Returns legit if loc is valid n' empty;
* otherwise returns false.
* ~param loc tha location ta be tested
* ~return legit if tha location is valid n' empty, false
* otherwise
*1
private boolean canJump(Location loc)
{ 1* ta be implemented up in part (b) *I.}
GO ON TO THE NEXT PAGE.
Practice Exam Two / Level AB Diagnostic Test
(a) Write tha private helper method getJumpLocation. I aint talkin' bout chicken n' gravy biatch. This method returns
the location dat is two locations away from dis Frog up in tha same direction
that tha Frog is facing. Da Location parameter, adjacent, is tha location
of tha hustla selected ta be jumped over n' shit. Note: Da Location returned by
getJumpLocation may be outta boundz of tha grid. Y'all KNOW dat shit, muthafucka! (This should not affect
the implementation of tha method.) For tha diagram shown on p. 91, here
are some thangs up in dis biatch of tha call
Location jumpLoc = getJumpLocation(loc);
loc jumpLoc
(3,2) (4,2)
(1, 1) (0, 0).
(1,2) (0,2)
(1,3) (0,4)
Complete method getJumpLocation below.
1**
* Returns tha location dat is two locations away from this
* Frog, up in tha same direction dat tha Frog is facing. This
* location may be invalid.
* Precondition: adjacent is tha location of tha neighbor ta be
* jumped over n' shit. Well shiiiit, it aint empty.
* ~param adjacent tha location of tha neighbor ta be jumped
* over
* ~return tha two-away location up in tha same direction as the
* frog
*1
private Location getJumpLocation(Location adjacent)
(b) Write tha private helper method canJump. Method canJump returns true
if loc is valid n' empty; otherwise it returns false. For tha Frog up in the
diagram on p. 91, here is some thangs up in dis biatch of a cold-ass lil call ta canJump(loc):
loc canJump(loc)
(4,2) true
(0,0) true
(0, 2) false (not empty)
(0, 4) false (not valid)
Complete method canJump below.
1**
* Returns legit if loc is valid n' empty;
* otherwise returns false.
* ~param loc tha location ta be tested
* ~return legit if tha location is valid n' empty, false
* otherwise
*1
private boolean canJump(Location loc)
GO ON TO THE NEXT PAGE.
93
94 Practice Exams
(c) Override tha processActors method fo' tha Frog class. Da processActors
method do tha following:
 If there be no adjacent neighborin hustlas, do nothing.
 Select a adjacent neighbor at random n' then tum ta grill dat shit.
 Git tha possible "jump location" fo' tha selected hustla. This location
is two locations away from dis Frog, up in tha direction dat tha Frog is
facing. .
 If tha Frog can jump, move ta tha jump location. I aint talkin' bout chicken n' gravy biatch. Otherwise, do not
move.
In freestylin processActors, you must use tha helper methodz canJump and
getJumpLocation defined up in parts (a) n' (b). Yo ass may assume dat these
methodz work as specified, irrespectizzle of what tha fuck you wrote.
Complete method processActors below.
1**
* Randomly selects a neighbor n' turns ta grill dat shit.
* Gets tha possible jump location, which is tha location
* adjacent ta tha selected neighbor up in tha same direction
* from tha Frog. If tha Frog can jump, it will move ta the
* jump location. I aint talkin' bout chicken n' gravy biatch. Otherwise it aint gonna chizzle its location.
* If tha list of hustlas is empty, tha Frog do nothing.
* Oparam hustlas tha list of adjacent neighbors
*1
hood void processActors(ArrayList<actor> hustlas)
3. Right back up in yo muthafuckin ass. Scrabble be a funky-ass board game played between two playas. Players whoz ass participate
in tournaments receive a ratin based on they recent performance. Consider
an intercourse ScrabblePlayer dat is ghon be used ta represent Scrabble playas at a
Scrabble club. Each playa is busted lyrics bout by name n' current rating.
hood intercourse ScrabblePlayer
{
}
Strin name 0 ;
int ratingO;
Da followin Game class represents a single game played by a Scrabble playa:
hood class Game
{
private ScrabblePlayer opponent;
private boolean won;
II constructor not shown
hood ScrabblePlayer getOpponent()
{ return opponent; }
}
hood boolean wonGame()
{ return won; }
Ilother methodz not shown ...
GO ON TO THE NEXT PAGE.
Practice Exam Two / Level AB Diagnostic Test
Da followin ScrabbleClub class is used ta store playas n' tha set of games
they have played.
hood class ScrabbleClub
{
}
private Map<scrabbleplayer, set<game»="" map;="" hood="" scrabbleclub()="" {="" map="freshly" smoked="" up="" hashmap<scrabbleplayer,="" set<game»();="" }="" iipostcondition:="" thegame,="" played="" by="" playa,="" has="" been="" added="" to="" i="" tha="" map.="" void="" addgametomap(scrabbleplayer="" game="" thegame)="" 1*="" ta="" be="" implemented="" in="" part="" (a)="" *1="" iiprecondition:="" playa="" a="" key="" returns="" number="" of="" won="" against="" ii="" expert="" opponent.="" ii(note="" dat="" scrabbleplayer="" whose="" ratin="" is="" ilat="" least="" 1600.)="" int="" countexpertwins(scrabbleplayer="" playa)="" (b)="" all="" fo'="" which="" opponent's="" less="" than="" 1300="" done="" removed.="" removeweakopponents(scrabbleplayer="" (c)="" ilother="" methodz="" not="" shown="" ...="" for="" example,="" assume="" shitload="" entries="" scrabbleclub="" object="" clubmap="" are="" as="" bigs="" up:="" value="" i(="" (="" j="" andrea="" yonge="" 1="" don="" juan="" birman="" eli="" fabens="" khoa="" quy="" mike="" o'dell="" 1690="" 1701="" 1545="" 1900="" )="" 1635="" false="" legit="" true="" ray-ray="" zax="" fmily="" hart="" lil'="" bow="" wow="" myers="" 1825="" 1160="" 1236="" jizzle="" schultz="" 1451="" mack="" lepage="" 1270="" ..="" .="" go="" on="" the="" next="" page.="" 95="" 96="" practice="" exams="" this="" shows,="" birman,="" wit="" 1690,="" had="" following="" record:="" lost="" fabens,="" quy,="" yonge,="" o'dell,="" write="" scrabbleclub.method="" addgametomap,="" addz="" single="" game,="" specified="" scrabbleplayer,="" suppose="" player1="" n'="" playa2="" scott="" bland="" with="" 2105.="" if="" scott,="" represented="" gamet,="" method="" call="" clubmap.addgametomap(player1,="" game1);="" should="" modify="" [="" \="" i[="" l="" emily="" 2105="" complete="" addgametomap="" below.="" ,="" countexpertwins,="" examines="" record="" its="" parameta="" opponents="" realz.="" an="" opponent="" rating="" pimped="" outa="" or="" equal="" 1600.="" playa3,="" clubmap.="" countexpertwins="" (player3)="" return="" 2,="" since="" smart-ass="" muthafuckas="" o'dell.="" freestylin="" you="" may="" use="" any="" accessible="" methods="" classez="" dis="" question.="" exam="" two="" level="" ab="" diagnostic="" test="" count="" wins="" iprecondition:="" removeweakopponents,="" removes="" from="" opponents'="" ratings="" was="" 1300.="" playa4,="" removeweakopponents="" (player4)="" original="" gangsta="" '\="" '="" (d)="" n="" keys,="" each="" playaz="" set="" hashset="" can="" have="" c="" entries,="" where="" <="" n.="" aint="" talkin'="" bout="" chicken="" gravy="" biatch.="" termz="" nand="" c,="" state="" big-o="" hustlin="" time="" table="" below:="" run="" 97="" 98="" 4.="" consider="" followin="" linearlinkedlist="" class="" maintains="" processes="" singly="" linked="" linear="" list.="" da="" nodez="" list="" objectz="" listnode="" (whose="" code="" provided="" quick="" reference).="" yo="" ass="" will="" implement="" class.="" i*linear="" private="" firstnode;="" iiconstructs="" empty="" linearlinkedlist()="" firstnode="null;" iireturns="" empty,="" otherwise.="" boolean="" isempty()="" null;="" reference="" straight-up="" node.="" getfirstnode()="" iichanges="" first="" node="" refer="" setfirstnode(listnode="" node)="" fuck="" into="" cold-ass="" lil="" circular="" pointa="" field="" last="" refers="" makecircular()="" circular.="" reverses="" order="" nodes="" points="" reverse()="" makecircular.="" shiiit,="" no="" joke.="" makecircular="" converts="" setting="" iz="" type="" linearlinkedlist,="" 0="" chizzle="" cp="" ~i~i-i="" 6="" -i="" 9~="" ------------------------="" reverse.="" pointers="" thus="" reverse="" ()="" ="" notice="" just="" one="" node,="" done.="" somewhere="" middle="" list,="" need="" at="" adjacent="" pointers,="" so="" second="" chizzled="" (shown="" below).="" "----'--'+1="" -+1="" 18="" +-+1.-1="" -j....--ji1="" --+="" cb="" end="" (base="" case),="" must="" chizzled.="" 99="" 100="" reverse,="" bust="" recursive="" helper="" method.="" crazy-ass="" algorithm="" depend="" temporary="" storage.="" well="" shiiiit,="" it="" reversin="" pointas="" current="" linerlinkedlist="" object.="" then="" iipostcondition:.="" examination="" chart="" zi"="" "il"ili:!_~1v1ojf~8"'11="" answer="" (section="" i)="" .a:r;,.~t_n="" l.c="" 15.="" e="" 29.="" d="" 2="" 16="" 30.="" 3.="" 17.="" b="" 31="" 18.="" '32.="" 5.="" 19.="" 33.="" 6.="" 20.="" 34.="" 7.="" 21.="" 35.="" 8.="" 22.="" 36.="" 9="" 23.="" 37.="" 10.="" 24.="" 38.="" 11.="" 25.="" 39.="" 12.="" 26.="" 40.="" 13.="" 27="" 14.="" 28.="" -="" multiple-choice="" question="" explanation="" (p.="" 103).="" relates="" sections="" review.="" given="" question,="" topic(s)="" represent="" concept(s)="" tested="" these="" topics="" explained="" correspondin="" page(s)="" provide="" further="" insight="" answerin="" 101="" 102="" i.~~",,,,,,.~.="" ______="" ,,,,"'''''~~.i'''''v5-'::x.';:~'',''-_______="" ''="" 'p="" page="" ~~]1,w~~n.~~m="" l~n:iliir~'{yf";?~~'~"'~~!ii!f!1i="" ___="" topic="" ~.="" "="" doubly="" lists="" 373="" ~="" superclass="" subclass="" declarations="" 192="" 3="" math.random()="" 235="" expressions="" 121="" !="" 4="" calls="" 195="" 5="" tree="" traversals="" 440="" 'j="" !f="" sortin="" algorithms="" 539="" 7="" heapsort="" 528="" ,~="" 8="" round-off="" error="" 119="" iterator="" remove="" 447766="" removal="" arraylist="" 10="" 364="" ?~="" 11="" traversin="" listnodes="" 366="" 12="" preorder="" traversal="" ,.;;="" poppin="" stack="" 403="" i;~="" 13="" 499="" "1="" .~..="" i'="" 14="" 15="" 17="" hash="" codin="" 536="" binary="" search="" 535="" processin="" two-dimensionizzle="" array="" 300="" prioritizzle="" queues="" 409="" stacks="" 406="" relationshizzle="" between="" classes="" 263="" 19="" oop="" design:="" identifyin="" behaviors="" 20="" overridin="" 190="" 21="" git="" 493="" 22="" duplicates="" 486="" 23="" inorder="" 442="" 24="" timez="" 453="" 25="" best="" case="" 438="" 26="" implementin="" 265="" 28="" treemap="" operations="" 494="" 29="" 487="" 30="" 492="" ~~~="" m="" .~="" 32="" treenode="" 434="" '"="" queue="" 407="" !t="" 33="" 374="" 34="" recursion="" altas="" 444="" ~~~~="" ill="" 36="" chameleoncri="" tta="" 575="" ;~="" 37="" bug="" move="" 572="" cri="" act="" 574="" chameleoncritta="" description="" "i="" 38="" location="" constants="" 566="" t="" 39="" boxbug="" l~'~'="" _="" ~~'.~"~'="">&lt;:~'&lt;"~m~~~;r.~L~~~~~~~!!"!=~~:~~'~1'_":~~ ____ 5\.118LL2_.
Answers Explained
ANSWERS EXPLAINED (Section I)
1. (C) A circular doubly linked list works well fo' dis program cuz of tha ability
to traverse forward n' backward from any given node. Note dat a stack
(choice D) serves up easy as fuck  backtrackin from tha current top element but do not
allow fo' convenient access ta any other specified posizzle or fo' easy as fuck  forward
traversal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Right back up in yo muthafuckin ass. Similarly, a queue (choice E) allows easy as fuck  forward traversal from the
front posizzle but be awkward fo' backtrackin n' random access of elements in
the "middle" of tha queue. Chizzle A seems reasonable fo' both forward n' backward
traversal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da number of moves, however, is big-ass n' unknown, which
makes a thugged-out dynamic data structure preferable. Chizzle B don't satisfy tha requirements
of tha program at all. Well shiiiit, it also has tha problem of representin real-number
coordinates (x, y) wit tha indexez of tha array; tha indexes must be integers.
2. (A) Chizzle A is illegal cuz you cannot create a instizzle of a abstract class.
3. (D) Da statement
double value = Math.random();
generates a random double up in tha range 0 ~ value &lt; 1. Right back up in yo muthafuckin ass. Since random doubles
are uniformly distributed up in dis interval, 45 cement of tha time you can expect
value ta be up in tha range 0 ~ value &lt; 0.45. Therefore, a test fo' value up in dis range
can be a test fo' whether tha serve of a WeakPlayer went in. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Since Math. random ()
never returns a wack number, tha test up in implementation Pt II, value &lt; 0.45,
is sufficient. Da test up in implementation I would be erect if I I was chizzled
to &amp;&amp; ("or" chizzled ta "and" -both parts must be true). Implementation ill also
works. Da expression
(int) (Math.random() * 100)
returns a random integer from 0 ta 99, each equally likely. Thus, 45 cement of
the time, tha integer val is ghon be up in tha range 0 ~ val ~ 44. Therefore, a test for
val up in dis range can be used ta test whether tha serve was in.
4. (B) Chizzle B is fine: b, tha Beginner, is-a WeakPlayer n' shit. Chizzlez A n' C will
each cause a ClassCastException ta be thrown: Yo ass can't cast a GoodPlayer to
a WeakPlayer n' you can't cast a WeakPlayer ta a Beginner n' shit. Chizzlez D n' E
will each cause a cold-ass lil compile-time error: Da parameta must be of type WeakPlayer,
but wand b is declared ta be of type TennisPlayer n' shit. Each of these chizzlez can be
corrected by castin tha parameta ta WeakPlayer.
5. (B) Since none of tha nodes up in chizzle B has a right subtree, tha recursive leftroot-
right of tha inorder traversal becomes left-root. Right back up in yo muthafuckin ass. Similarly, tha left-right-root
of a postorder traversal becomes left-root. In either case, tha traversal yieldz S, K,
A, then P.
6. (D) Worst case fo' quicksort is O(n2). Quicksort recursively partitions tha array
into two pieces such dat elements up in tha left piece is less than or equal ta a pivot
element, n' dem up in tha right piece is pimped outa than or equal ta tha pivot. In the
worst case, tha pivot element repeatedly splits tha array tha fuck into piecez of length 1
and n - 1, respectively. In dis case, there is ghon be n splits, each rockin a O(n) partitioning
algorithm. Thus, tha final run time becomes O(n2) fo' realz. An example where
this could happen be a sorted array up in which one of tha end elements is repeatedly
103
104 Practice Exams
chosen as tha pivot. Mergesort recursively divides tha array tha fuck into two pieces of
roughly tha same size until there be n arrayz of length 1. This is O(log n). Then
adjacent sorted arrays is recursively merged ta form a single sorted array. Thus,
the algorithm is O( n log n ), irrespectizzle of tha initial orderin of array elements.
Heapsort creates a funky-ass balanced binary tree irrespectizzle of tha orderin of tha array
elements, which leadz ta a O( n log n) algorithm up in dopest n' most shitty cases.
7. (0) Here is tha steps up in fixin tha heap afta tha array elements is slotted into
a binary tree (see p. 529).
8. (B) Although tha expression be always algebraically legit fo' nonzero x, tha expression
may evaluate ta false. This could occur cuz of round-off error in
performin tha division n' multiplication operations. Whether tha right-hand
side of tha expression evaluates ta exactly 3.0 dependz on tha value of x. Note
that if x is zero, tha expression is ghon be evaluated ta false cuz tha right-hand
side is ghon be assigned a value of Infinity.
9. (A) Segment Pt II fails cuz it calls tha ArrayList method remove durin iteration.
Durin iteration wit a iterator, you may not modify tha list wit a
noniterator method. Y'all KNOW dat shit, muthafucka! Segment I erectly invokes tha iterator remove method.
Segment ill do not use a iterator ta cycle all up in tha list. Therefore it is OK
to use tha remove method from ArrayList. Yo ass must, however, be careful naaahhmean, biatch? When
you remove tha ith item from a ArrayList, tha (i + l)th item is shifted tha fuck into that
position. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Since i is incremented afta each loop iteration, consecutizzle duplicates
will not be deleted.
10. (E) Segment I erectly uses tha ListNode constructor. Shiiit, dis aint no joke. Right back up in yo muthafuckin ass. Segment ill erectly uses
the setNext n' setValue methodz ta bang tha required joints up in tha freshly smoked up node
and connect it ta tha list. Right back up in yo muthafuckin ass. Segment Pt II uses tha ListNode constructor erectly but
has a incorrect second statement: It fails ta connect tha current node ta the
new node (referred ta by p). Right back up in yo muthafuckin ass. Segment Pt II would be erect if tha second statement
were chizzled to
current.setNext(p);
11. (C) Da problem wit tha code is up in tha last line; chizzle it to
temp = temp.getNext().getNext();
and tha method will work as intended fo' all cases fo' realz. As it is, temp don't advance
far enough, n' you have a infinite while loop dat produces a endless stream
of blanks:
Answers Explained 105
list
~
"A" I +--1 "B" l/l
becomes
temp
~
-I " " 1 +-1 "B" Vl
Da method works fo' a empty list cuz not a god damn thang is done. Well shiiiit, it works fo' a list
with just one node cuz tha while test fails immediately n' tha list remains
unchanged.
12. (E) A preorder traversal pushes tha elements onto s up in tha followin order:
A, K, C, P, R, F.
Da elements is ghon be popped n' printed up in reverse order, namely
F, R, P, C, K, A.
13. (C) Segment Pt III erectly iterates over tha cl~cks list n' uses tha iterator to
remove each defectizzle Digi talClock. Right back up in yo muthafuckin ass. Segment Pt II'ma fail whenever two (or more)
adjacent clocks is defective. This is cuz whenever a cold-ass lil clock is removed, all
subsequent clocks is moved one slot left. Da index, however, will move one
posizzle ta tha right, which means dat a thugged-out duplicate is ghon be skipped. Y'all KNOW dat shit, muthafucka! Da main
problem wit segment I is dat a enhanced fo' loop cannot be used ta remove
an element from a list.
14. (E) Contrast dis wit tha previous question. I aint talkin' bout chicken n' gravy biatch. No elements is bein removed
from or added ta tha list of clocks. Each element is bein accessed n' modified,
which is fine fo' each of tha three modez of traversal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Take note: Yo ass cannot use
a for-each loop ta remove elements, add elements, or replace elements up in tha list.
Yo ass can, however, use it ta modify objects dat have mutator methods.
15. (E) To print a list of donors up in order of total contributions is equally efficient for
plans I n' Pt II. Both plans require tha same three steps:
(1) Insert all Donor objects tha fuck into a temporary array.
(2) Sort tha array wit respect ta total contributions.
(3) Print tha elements.
Note dat simply sortin tha existin array up in plan I aint a phat idea; tha array
will then need ta be "sorted back" tha fuck into alphabetical order n' shit. Chizzle A is true: All
items up in tha database require tha same amount of memory irrespectizzle of data
structure. Chizzlez B n' C is true: Insertion n' searchin up in a phat hash table
are both O( 1), whereas up in a sorted array searchin fo' a given donor or insertion
point is o (log n) (assumin dat a efficient method like binary search is used).
Choice D is legit since plan Pt II r~quires sortin before printing. Plan I has data
items dat is already sorted up in alphabetical order.
16. (A) Method alta shifts all tha columns, startin at column c+l, one column
to tha left fo' realz. Also, it do it up in a way dat overwrites column c yo. Here is the
replacements fo' tha method call alter(l):
106 Practice Exams
mat [0] [1] = mat [0] [2]
mat [0] [2] = mat [0] [3]
mat [1] [1] = mat [1] [2]
mat [1] [2] = mat [1] [3]
mat [2] [1] = mat [2] [2]
mat [2] [2] = mat [2] [3]
17. (8) Segment Pt II removes elements form tha prioritizzle queue up in increasin order
of prioritizzle n' pushes each element onto a stack as it is removed. Y'all KNOW dat shit, muthafucka! Thus, the
maximum element up in pq landz on top of tha stack. This is tha element ta be
removed, which is carried up by tha statement s . pop (). Da remainin elements
are then placed, wit they original gangsta ordering, tha fuck into a freshly smoked up prioritizzle queue priQ,_
which is returned. Y'all KNOW dat shit, muthafucka! Segment Pt III is practically identical ta segment Pt II, except that
it places tha elementz of pq tha fuck into a queue. This thangs up in dis biatch up in havin tha least element
at tha front of tha queue, which is then deleted by tha statement q. remove 0 .
Segment I fails cuz it too removes tha least element instead of tha maximum.
18. (E) Statement I is false: Da Sedan, StationWagon, n' suv classes should all be
subclassez of Car. Shiiit, dis aint no joke. Each one satisfies tha is.a Hoopty relationshizzle. Right back up in yo muthafuckin ass. Statement Pt II is true:
Da main task of tha Inventory class should be ta keep a updated list of Car
objects, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Statement Pt III is true: A class is independent of another class if it do not
require dat class ta implement its methods.
19. (8) Da Inventory class is responsible fo' maintainin tha list of all rides on the
lot. Therefore methodz like addCar, removeCar, n' displayAllWhips must be the
responsibilitizzle of dis class. Da Hoopty class should contain tha setColor, getPrice,
and displayCar methods, since all these pertain ta tha attributez of a given Car.
20. (C) Each subclass may contain additionizzle attributes fo' tha particular type of
car dat is not up in tha Hoopty superclass. Right back up in yo muthafuckin ass. Since displayCar displays all featurez of a
given car, dis method should be overridden ta display tha original gangsta plus additional
features.
21. (E) Da git method of Map returns either tha value associated wit tha key, or
null if tha map gotz nuff no mappin fo' dat key. In tha given piece of code,
since there is no "Dopey;' key, s is ghon be assigned tha value null.
22. (8) As a cold-ass lil counterexample fo' chizzlez A, C, D, n' E, let a funky-ass be tha list
1, 1, 1, 1, 2, 2, 3, 4, 5, 6
Then s is tha set
1, 2, 3, 4, 5, 6
(No duplicates up in a set!)
23. (8) An inorder traversal of a funky-ass binary search tree produces tha elements up in sorted
increasin order n' shit. (Recall dat tha leftmost leaf of tha binary search tree is the
smallest element up in tha tree n' dat dis is tha straight-up original gangsta element hit up.)
24. (0) Da dopest case run time occurs when tha binary search tree produced is balanced.
This means that, fo' each of tha n shit up in arr, no mo' than log2 n
comparisons will need ta be made ta find its insertion point. Therefore tha run
time is O( n log n). Printin tha elements is O( n), which is less than O( n log n ).
Thus, tha overall run time is O( n log n).
Answers Explained
25. (C) Any kind of sorted array leadz ta most shitty case behavior fo' insertion tha fuck into a
binary search tree. Da tree obtained is straight-up unbalanced, wit a long-ass chain
of left links or right links. Run time of insertion becomes O(n2 ) (see p. 440).
Choice Pt III is thus da most thugged-out likely of tha three chizzlez ta lead ta a funky-ass balanced tree
and dopest case behavior.
26. (C) Before manipulatin Largelnt objects, you gotta check dat they've been
correctly constructed, n' ta do dat you need ta output dem wild-ass muthafuckas. This means that
the toStrin method must be defined up in order ta read tha output doggystyle. Therefore
the constructor n' toStrin methodz should be coded before tha others.
27. (A) Yo ass wanna simulate i++ (or i=i+l). Thus, eliminizzle chizzlez C n' D,
which don't include i up in tha method calls ta add. Y'all KNOW dat shit, muthafucka! Chizzle C would be erect if its
method call was one. add (i) . Eliminizzle chizzle B cuz a Largelnt parameter
must be used. Y'all KNOW dat shit, muthafucka! Chizzle E is wack cuz you not addin n ta i, you adding
1 ta i.
28. (B) Da TreeMap class stores its elements up in a funky-ass balanced binary search tree. This
means dat TreeMap will provide O(log n) performizzle fo' insertion, retrieval,
and search. Thus, chizzlez A n' C is false. Chizzlez D n' E is false cuz
printin a list of all elements involves a simple traversal: O(n).
29. (D) In segment I temp gotz nuff all tha elementz of set2. Then all tha elements
of set son! is added ta temp. If set son! be a subset of set2, all tha elementz of set!
will already be up in temp, which means dat tha size of temp will remain tha same
as tha size of set2. (If set son! aint a subset of set2, then temp. size () will end up
bigger than set2. size 0 cuz there is ghon be at least one element of set son! that
was not up in set2.) Segment Pt II checks dat set2 gotz nuff each element of set!. If
it don't, tha method returns false, otherwise true. Right back up in yo muthafuckin ass. Segment Pt III iterates over
both sets set son! n' set2 n' returns false as soon as it findz a element up in set!
that aint equal ta a element up in set2. But fo' set son! ta be a subset of set2, all of
the elements up in set2 except one aint gonna be equal ta a given element of set!. You
would gotta modify tha code wit a mo' fucked up version dat searches
the entire set set2 fo' each element up in set son! n' returns false only if no element
is equal ta dat shit.
30. (E) Da declaration of tha map
private Map<string, wordstatus=""> m;
shows dat tha second parameta of tha put method should be a object of type
WordStatus. Thus, you can eliminizzle chizzlez A, B, n' C. Chizzle D is wrong
because there is no constructor up in WordStatus dat has a parameter.
31. (A) There is two conditions under which tha isAvailable method should return
false:
 Its word parameta aint up in tha map.
 Da word parameta is up in tha map but has already been used.
Segment I erectly takes care of both these cases. In Segment Pt II, if word is not
in tha map, m. git (word) will cause a NullPointerException. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Segment Pt III fails
because it don't return false if tha word is marked as used (i.e., no else fo' the
second if).
32. (C) Da algorithm yieldz a level-order traversal of tha tree, which visits nodes
startin all up in tha root n' goin from top ta bottom, left ta right. Right back up in yo muthafuckin ass. Suppose dat the
107
108 Practice Exams
TreeNode references ta tha nodes is labeled wit lil' small-ass lettas as shown:
Afta tha straight-up original gangsta pass all up in tha while loop, A has been printed n' q is
q
f b
Afta tha second pass, J has been printed n' q is
q b
f b
Afta tha third pass, L has been printed n' q is
q d
f b
When q is empty, AJLMFR has b$!en printed.
33. (E) Segment I fails cuz it don't take tha fuck into account dat tha next field of
list was altered up in tha straight-up original gangsta line yo. Here is tha faulty pointa connections (dashed
lines):
list
34. (0) Da method creates a tree dat be a mirror image of its parameter n' shit. Note the
order of tha parametas up in tha TreeNode constructor:
(initValue, initLeft, initRight)
In tha method mTree tha order is
(t.getValue(), mTree(t.getRight()), mTree(t.getLeft()))
Matchin up parametas means dat tha right subtree of t becomes tha left connection
of tha freshly smoked up tree, n' tha left subtree of t becomes tha right connection.
Answers Explained
35. (B) Notice dat ta do its thang, tha PoisonousCri tta must git tha adjacent
actors, process them, git a list of possible move locations, randomly select one
of these, n' then move ta dat shit. This is what tha fuck a regular Critta do, so act and
getActors need not be chizzled. Y'all KNOW dat shit, muthafucka! Both of tha methodz up in crew IT must be
changed: processActors turns tha hustlas green, whereas tha original gangsta method
removes dem wild-ass muthafuckas. Da getMoveLocations method must git a list of occupied locations,
whereas tha original gangsta method gets empty locations. Group Pt III methods
don't chang~ at all: When a PoisonousCri tta has a list of possible locations, it
randomly selects one n' moves there, so peek-a-boo, clear tha way, I be comin' thru fo'sho. This is what tha fuck a regular Critta do.
36. (E) Da ChameleonCri tta randomly chizzlez a neighborin hustla n' takes its
color. Shiiit, dis aint no joke. Thus it will end up yellow or purple. Well shiiiit, it then randomly picks a empty adjacent
location, moves tha fuck into it, n' endz up facin tha direction up in which it moved.
Reject chizzlez A n' C: A ChameleonCri tta do not eliminizzle its neighbors.
Choice B is wack cuz tha ChameleonCri tta must move if it can. I aint talkin' bout chicken n' gravy biatch. Chizzle D
is incorrect cuz tha direction from location (1, 1) ta location (2, 0) is southwest,
and tha ChameleonCri tta didn't chizzle its direction ta southwest.
37. (E) All can reappear playa! When tha Bug moves outta tha grid, goin westside, say,
it will continue ta move westside until it encountas a obstacle. Dependin on the
location of obstacles, tha Bug may gotta turn right enough times so dat it turns
back n' reappears on tha screen. I aint talkin' bout chicken n' gravy biatch. If tha crittas move outta tha visible part of
the grid, on tha left of tha screen, say, tha leftmost visible column could provide
empty adjacent locations fo' tha next time they act. They then mayor may not
reappear.
38. (E) All of tha Location constants is int joints: Location. I aint talkin' bout chicken n' gravy biatch. NORTH is 0,
Location.FULL_CIRCLE is 360, n' Location.HALF_RIGHT is 45. Thus, tha given
replacements can be used up in tha implementation.
39. (0) Instead of turnin right all up in 90°, tha BoxBug now turns right through
45°. This produces tha octagon up in chizzle D. Chizzle A is wack cuz tha turn
is all up in 90°. Chizzle B has a 135° turn then a 225° turn, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. In chizzle C, tha BoxBug
turns 45° left n' then 45° right, while up in chizzle E it turns 45° right n' then 45°
left. In tha code, however, turn be a right turn.
40. (0) Da steps ta remove a hustla at loc up in a BoundedGrid are:
 git tha occupant at loc: O( 1)
 Assign occupantArray[loc.getRowOJ [loc.getCoIOl ta null: 0(1)
Thus tha algorithm is O( 1).
To remove a hustla at loc up in a UnboundedGrid:
 Use tha HashMap method remove ta remove tha mappin whose key is loc:
occupantMap.remove(loc);
To access any key up in a HashMap is 0(1).
Therefore tha algorithm is O( 1).
109
110
Section Pt II
1. (a)
(b) hood abstract class Animal
{
private Strin myName;
private Strin myNoise;
private Strin myCovering;
//constructor
Practice Exams
hood Animal(Strin name, Strin noise, Strin covering)
{
}
}
myName = name;
myNoise = nOise;
myCoverin = covering;
hood Strin getName()
{ return myName; }
hood Strin getNoise()
{ return myNoise; }
hood Strin getCovering()
{ return myCovering; }
hood abstract Strin getFood();
(c) hood abstract class Owl extendz Bird
{
}
//constructor
hood Owl (Strin name)
{
supa (name, "hoot");
}
Answers Explained
(d) hood class SnowyOwl extendz Owl
{
}
NOTE
//constructor
hood SnowyOwl()
{
super("Snowy Owl");
}
//Returns type of chicken fo' dis SnowyOwl.
hood Strin getFood()
{
}
int num = (int) (Math.random() * 3);
if (num == 0)
return "hare";
else if (num == 1)
return "lemming";
else
return "small birp";
 Since tha chicken type fo' each Animal can't be simply provided up in a parameter,
the getChicken method must be abstract up in tha Animal class. This means
that tha Animal class must be abstract.
 Both tha Bird n' Owl classes inherit tha abstract getChicken method. Y'all KNOW dat shit, muthafucka! Since
the chicken type fo' a Bird, n' also fo' a Owl, dependz on tha type of
Bird or Owl, these classes don't provide implementation code fo' getFood.
Therefore both Bird n' Owl must be abstract classes.
 In parts (c) n' (d), supa must be used up in tha constructors cuz there's
no direct access ta tha private variablez of tha Animal class.
 Note dat tha Bird constructor has two parameters, name n' noise. The
noise fo' a Owl, however, will always be "hoot". Therefore noise do
not need ta be provided as a parameta up in tha Owl constructor. Shiiit, dis aint no joke. Da statement
supa (name, "hoot") will use tha superclass (Bird) constructor to
automatically assign "hoot" as a Owlz noise. Right back up in yo muthafuckin ass. Similarly, tha SnowyOwl
does not need any parametas up in its constructor. Shiiit, dis aint no joke. Usin tha superclass
(Owl) constructor will automatically provide it wit its name all up in the
statement supa ("SnowyOwl").
 Da SnowyOwl inherits tha "hoot" noise from Owl n' tha "feathers"
coverin from Bird.
2. (a) private Location getJumpLocation(Location adjacent)
{
}
Location twoAway =
adjacent.getAdjacentLocation(getDirection());
return twoAway;
111
112
(b) private boolean canJump(Location loc)
{
}
if (lgetGrid().isValid(loc»
return false;
Actor occupant = getGrid().get(loc);
return occupant == null;
(c) hood void processActors(ArrayList<actor> hustlas)
{
}
NOTE
int n = hustlas.size();
if (n =- 0)
return;
int r = (int) (Math.random() * n);
Actor nbr = hustlas.get(r);
Location nbrLoc = nbr.getLocation()j
int newDirection =
getLocation().getQirectionToward(nbrLoc)j
setDirection(newDirection)j
Location jumpLoc = getJumpLocation(nbrLoc)j
if (canJump(jumpLoc»
makeMove(jumpLoc);
Practice Exams
 In part (b), tha loc parameta is tha prospectizzle "jump location." The
isValid test checks dat it aint outside tha boundz of tha grid. Y'all KNOW dat shit, muthafucka! Da test
occupant == null checks whether loc is empty.
3. (a) hood void addGameToMap(ScrabblePlayer playa, Game theGame)
{
}
Set<game> game = map.get(player)j
if (game == null)
{
game = freshly smoked up HashSet<game>();
map. put (player, games);
}
games.add(theGame);
(b) hood int countExpertWins(ScrabblePlayer playa)
{
}
Set <game> game = map.get(player);
i~t numWins = 0;
for (Game g: games)
if (g.getOpponent().rating() &gt;= 1600 &amp;&amp; g.wonGame(»
numWins++j
return numWins;
Answers Explained
(c) hood void removeWeakOpponents(ScrabblePlayer playa)
{
}
(d)
Set<game> game = map.get(player)j
for (Iterator<game> itr = games.iterator()j itr.hasNext()j)
{
}
ScrabblePlayer opponent = itr.next().getOpponent()j
if (opponent.rating() &lt; 1300)
itr. Shiiit, dis aint no joke. remove 0 j
Method Big-O run time
addGameToMap ()(l)
countExpertWins ()(c)
removeWeakOpponents ()(c)
NOTE
 In part (a), you must check tha case where playa aint yet up in tha key
set of tha map, up in which case game is ghon be null. This means you must
create a freshly smoked up HashSet before you add tha Game ta dat shit.
 In part (b), each game up in tha set of game fo' playa is examined. Y'all KNOW dat shit, muthafucka! A
for-each loop is used fo' tha traversal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Contrast dis wit part (c), where
an iterator must be used since elementz of tha set may be removed. Y'all KNOW dat shit, muthafucka! A
for-each loop cannot be used ta traverse a cold-ass lil collection where shit may be
removed.
 In part (d), tha git operation up in a HashMap is ()(l), independent of n,
the number of keys. Da put operation up in a HashSet be also ()(l); thus
addGameToMap is ()(l). Da countExpertWins method findz tha playa
key, ()(l), then traverses tha c elements up in tha correspondin HashSet:
()(c). Method removeWeakOpponents findz tha key, ()(l), then also traverses
the c elements up in tha correspondin HashSet, potentially removing
each element. Right back up in yo muthafuckin ass. Since removin a item from a HashSet is ()( 1), the
method is ()( c).
 In part (d), you cannot make any assumptions bout tha size of c compared
with tha size of n, other than tha fact dat c &lt; n, which is given.
Therefore, it is incorrect ta say dat tha traversals is ()( n) (which would
be erect if c ~ n) or ()( 1) (which would be erect if c is straight-up small
compared ta n).
4. (a) hood void makeCircular()
{
}
if (! isEmptyO)
{
}
ListNode p = firstNodej
while (p.getNext() != null)
{
p = p.getNext():
}
p.setNext(firstNode)j
113
114
(b) hood void reverse()
{
}
if (!isEmpty() t&amp; firstNode.getNext() != null)
reverseHelper(null, firstNode);
Practice Exams
private void reverseHelper(ListNode first, ListNode second)
{
}
if (second.getNext() == null)
{
setFirstNode(second);
}
else
{
reverseHelper(second, second.getNext(»;
}
second.setNext(first);
Alternatizzle solution:
hood void reverse()
{
}
if (!isEmpty() tt firstNode.getNext() != null)
setFirstNode(reverseHelper(null, firstNode,
firstNode.getNext(»);
private ListNode reverseHelper(ListNode first,
ListNode second, ListNode hold)
{
}
NOTE
second.setNext(first);
if (hold == null)
return second;
else
return reverseHelper(second, hold, hold.getNext(»;
 In part (a), yo ass is not holla'd at dat tha linear linked list is nonempty. Therefore,
you need tha isEmpty test.
 Da first solution up in part (b) uses two consecutizzle pointers. Da alternative
solution uses three.
 In tha alternatizzle solution reverseHelper eventually returns a reference
to tha last node up in tha list, n' firstNode is set ta dat shit.
Introductory Java
Language Features
 Packages n' classes
 Types n' identifiers
 Operators
 Input/output
 Storage of numbers
Chapta Goals
Fifty loops shalt thou make ...
-Exodus 26:5
 Binary n' hexadecimal
numbers
 Control structures
 Errors n' exceptions
T"" he AP Computa Science course includes algorithm analysis, data structures,
&gt; n' tha steez n' methodz of modern programming, specifically, objectoriented
programmin fo' realz. A high-level programmin language is used ta explore these
concepts, n' you can put dat on yo' toast. Java is tha language currently up in use on tha AP exam.
Java was pimped by Jizzy Goslin n' a crew at Sun Microsystems up in California;
it continues ta evolve. Da AP exam covers a cold-ass lil clearly defined subset of Java language
features dat is presented all up in dis book, includin some freshly smoked up features
of Java 5.0 dat was tested fo' tha last time up in May 2007. Da College Board joint,
http://www.collegeboard.com/student /testing/ap /subjects.html, gotz nuff a cold-ass lil complete listing
of dis subset.
Java serves up basic control structures like fuckin tha if-else statement, fo' loop, and
while loop, as well as fundamenstrual built-in data types. But tha juice of tha language
lies up in tha manipulation of user-defined types called objects, nuff of which can interact
in a single program.
PACKAGES AND CLASSES
A typical Java program has user-defined classes whose objects interact wit dem from
Java class libraries. Put ya muthafuckin choppers up if ya feel dis! In Java, related classes is grouped tha fuck into packages, nuff of which
are provided wit tha compila n' shit. Yo ass can put yo' own classes tha fuck into a package-this
facilitates they use up in other programs.
CHAPTER 1
115
116 Chapta 1 Introductory Java Language Features
Da package java . lang, which gotz nuff nuff commonly used classes, be automatically
provided ta all Java programs. Boy it's gettin hot, yes indeed it is. To use any other package up in a program, a import
statement must be used. Y'all KNOW dat shit, muthafucka! To import all of tha classes up in a package called packagename,
use tha form
import packagename.*;
To import a single class called ClassName from tha package, use
import packagename.ClassName;
Java has a hierarchy of packages n' subpackages. Right back up in yo muthafuckin ass. Subpackages is selected using
multiple dots:
import packagename.subpackagename.ClassName;
Da import statement allows tha programmer ta use tha objects n' methodz defined
in tha designated package. By convention Java package names is lowercase. The
AP exam do not require knowledge of packages. Yo ass aint gonna be sposed ta fuckin write
any import statements.
A Java program must have at least one class, tha one dat gotz nuff tha main method.
Da java filez dat comprise yo' program is called source files.
A compila converts source code tha fuck into machine-readable form called bytecode.
Here be a typical source file fo' a Java program.
1* Program FirstProg.java
Start wit a cold-ass lil comment, givin tha program name n' a funky-ass brief
description of what tha fuck tha program do. *1
import packagel.*;
import package2.subpackage.ClassName;
hood class FirstProg Ilnote dat tha file name is FirstProg.java
{
}
hood static typel methodl (parameta list)
{
&lt; code fo' method 1 &gt;
}
hood static type2 method2 (parameta list)
{
&lt; code fo' method 2 &gt;
}
hood static void main(String[] args)
{
<your code="">
}
NOTE
1 fo' realz. All Java methodz must be contained up in a cold-ass lil class, n' all program statements must
be placed inside a method.
Types n' Identifiers
2. Typically, tha class dat gotz nuff tha main method do not contain nuff additional
methods.
3. Da lyrics class, public, static, void, n' main is reserved lyrics, also called
keywords.
4. Da keyword hood signals dat tha class or method is usable outside of the
class, whereas pri vate data thugz or methodz (see Chapta 2) is not.
s. Da keyword static is used fo' methodz dat aint gonna access any objectz of a
class, like fuckin tha methodz up in tha FirstProg class up in tha example on tha previous
page. This is typically legit fo' all methodz up in a source file dat gotz nuff no
instizzle variablez (see Chap!er 2). Most methodz up in Java do operate on objects
and is not static. Da main method, however, must always be static.
6. Da program shown on tha previous page be a Java application. I aint talkin' bout chicken n' gravy biatch. This aint to
be trippin wit a Java applet, a program dat runs inside a wizzy browser or
applet viewer n' shiznit fo' realz. Applets is not part of tha AP subset.
TYPES AND IDENTIFIERS
Identifiers
An identifier be a name fo' a variable, parameter, constant, user-defined method, or userdefined
class. In Java a identifier be any sequence of letters, digits, n' tha underscore
character n' shit. Identifiers may not begin wit a gangbangin' finger-lickin' digit. Identifiers is case-sensitive, which
means dat age n' Age is different. Wherever possible identifiers should be concise
and self-documentin fo' realz. A variable called area is mo' illuminatin than one called a.
By cOI?-vention identifiers fo' variablez n' methodz is lowercase. Uppercase letters
are used ta separate these tha fuck into multiple lyrics, fo' example getName, findSurfaceArea,
preTaxTotal, n' so on. I aint talkin' bout chicken n' gravy biatch. Note dat a cold-ass lil class name starts wit a cold-ass lil capital letter n' shit. Reserved
wordz is entirely lowercase n' may not be used as identifiers.
Built-in Types
Every identifier up in a Java program has a type associated wit dat shit. Da primitizzle or built.
in types dat is included up in tha AP Java subset are
int
boolean
double
An integer n' shit. For example, 2, -26, 3000
A boolean. I aint talkin' bout chicken n' gravy biatch. Just two joints, legit or false
A double precision floating-point number.
Forexample,2.718,-367189.41,1.6e4
(Note dat primitizzle type char aint included up in tha AP Java subset.)
Integer joints is stored exactly. Because there be a a gangbangin' fixed amount of memory set aside
for they storage, however, integers is bounded. Y'all KNOW dat shit, muthafucka! If you try ta store a value whose
magnitude is too big-ass up in a int variable, you gonna git a overflow error. Shiiit, dis aint no joke. (Java gives you no
warning. Yo ass just git a wack result!)
An identifier, fo' example a variable, is introduced tha fuck into a Java program wit a thugged-out declaration
that specifies its type fo' realz. A variable is often initialized up in its declaration. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Some
examplez follow:
117
118 Chapta 1 Introductory Java Language Features
int x;
double y,z;
boolean found;
int count = 1;
double p = 2.3, q = 4.1;
//count initialized ta 1
//p n' q initialized ta 2.3 n' 4.1
One type can be cast ta another compatible type if appropriate. For example,
int total, n;
double average;
average = (double) total/n;
Alternatively,
average = total/(double) n;
//total cast ta double ta ensure
//real division is used
Assignin a int ta a thugged-out double automatically casts tha int ta double. For example,
int num = 5;
double realNum = num; //num is cast ta double
Assignin a thugged-out double ta a int without a cold-ass lil cast, however, causes a cold-ass lil compile-time error. Shiiit, dis aint no joke. For
example,
double x = 6.79;
int intNum = x; //Error. Shiiit, dis aint no joke. Need a explicit cast ta int
Note dat castin a gangbangin' floating-point (real) number ta a integer simply truncates the
number n' shit. For example,
double cost = 10.95;
int numDollars = (int) cost; //sets numDollars ta 10
If yo' intent was ta round cost ta tha nearest dollar, you needed ta write
int numDollars = (int) (cost + 0.5); //numDollars has value 11
To round a wack number ta tha nearest integer:
double negAmount = -4.8;
int roundNeg = (inu) (negAmount - 0.5); //roundNeg has value -5
Da game of addin or subtractin 0.5 before castin erectly roundz up in all cases.
Storage of Numbers
INTEGERS
Integer joints up in Java is stored exactly, as a strang of bits (binary digits). One of the
bits stores tha sign of tha integer, 0 fo' positive, 1 fo' negative.
Da Java built-in integral type, byte, uses one byte (eight bits) of storage.
011 1 11. 1 1
Types n' Identifiers
Da picture represents tha phattest positizzle integer dat can be stored rockin type byte:
27 -1.
Type int up in Java uses four bytes (32 bits). Takin one bit fo' a sign, tha phattest
possible integer stored is 231 -1. In general, a n-bit integer uses nl8 bytez of storage,
and stores integers from _2n- 1 ta 2n-l_1. (Note dat tha extra value on tha negative
side be reppin not havin ta store -0.)
Built-in types up in Java is byte (one byte), short (two bytes), int (four bytes), and
long (eight bytes). Of these, only int is up in tha AP Java subset.
FLOATING-POINT NUMBERS
There is two built-in types up in Java dat store real numbers: float, which uses four
bytes, n' double, which uses eight bytes fo' realz. A floating-point number is stored up in two
parts: a mantissa, which specifies tha digitz of tha number, n' a exponent. Da JVM
Oava Virtual Machine) represents tha number rockin scientistical notation:
sign * mantissa * 2exponent
In dis expression, 2 is tha base or radix of tha number n' shit. In type double eleven bits are
allocated fo' tha exponent, n' (typically) 52 bits fo' tha mantissa. One bit be allocated
for tha sign. I aint talkin' bout chicken n' gravy biatch. This be a thugged-out double-precision number n' shit. Type float, which is single-precision, is
not up in tha AP Java subset.
When floating-point numbers is converted ta binary, most cannot be represented
exactly, leadin ta round-off error. Shiiit, dis aint no joke. These errors is compounded by arithmetic operations.
For example,
0.1*26 # 0.1+0.1+...+0.1 (26 terms)
In Java, no exceptions is thrown fo' floating-point operations. There is two thangs
you should be aware of:
 When a operation is performed dat gives a undefined result, Java expresses
this result as NaN, "not a number." Examplez of operations dat produce NaN are:
takin tha square root of a wack number, n' 0.0 divided by 0.0.
 An operation dat gives a infinitely big-ass or infinitely lil' small-ass number, like division
by zero, produces a result of Inf ini ty or - Inf ini ty up in Java.
Hexadecimal Numbers
A hexadecimal number or hex number uses base (radix) 16, n' is represented wit the
symbols a -9 n' A - F (occasionally a - f), where A represents 10, n' F represents 15.
To denote a hex number up in Java, tha prefix "Ox" or "OX" is used, fo' example, OxC2A.
On tha AP exam, tha representation is likely ta be wit tha subscript hex: C2Ahex. In
expanded form, dis number means
(C)(162) + (2)(161) + (A)(16o)
= (12)(162) + (2)(16) + (10)(1)
= 3114, or 3114dec
Da advantagez of hex numbers is they compactness, n' tha ease of conversion
between hex n' binary. Notice dat any hex digit expandz ta four bits, n' you can put dat on yo' toast. For example,
5hex = 0101bin n' Fhex = Il11bin
119
120 Chapta 1 Introductory Java Language Features
Thus, 5Fhex = 01011111bin, which is 1011111bin
Similarly, ta convert a funky-ass binary number ta hex, convert up in crewz of four from right
to left. If necessary, pad wit zeroes ta complete tha last crew of four. Shiiit, dis aint no joke. For example,
1011101bin = 0101 1101bin
= 5 Dhex
=5Dhex
Final Variables
A final variable or user.defined constant, identified by tha keyword final, is used to
name a quantitizzle whose value aint gonna chizzle yo. Here is some examplez of final declarations:
final double TAX_RATE = 0.08;
final int CLASS_SIZE = 35;
NOTE
1. Constant identifiers are, by convention, capitalized.
2 fo' realz. A final variable can be declared without initializin it immediately. For example,
final double TAX_RATE;
if « some condition&gt; )
TAX_RATE = 0.08;
else
TAX_RATE = 0.0;
II TAX_RATE can be given a value just once: its value is final!
3 fo' realz. A common use fo' a cold-ass lil constant be as a array bound. Y'all KNOW dat shit, muthafucka! For example,
final int MAXSTUDENTS = 25;
int[] classList = freshly smoked up int[MAXSTUDENTS];
4. Usin constants make it easier ta revise code. Just a single chizzle up in tha final
declaration need be made, rather than havin ta chizzle every last muthafuckin occurrence of a
value.
2&amp; PM
OPERATORS
Arithmetic Operators
Operator Meanin Example
-.-~--.. -
+ addizzle 3 + x
subtraction p - q
* multiplication 6 * i
I division 10 I 4 Ilreturns 2. not 2.5!
% mod (remainder) 11 % 8 Ilreturns 3
Operators
NOTE
1. These operators can be applied ta types int n' double, even if both types
occur up in tha same expression. I aint talkin' bout chicken n' gravy biatch. For a operation involvin a thugged-out double n' a int,
the int is promoted ta double, n' tha result be a thugged-out double.
2. Da mod operator %, as up in tha expression a % b, gives tha remainder when a is
divided by b. Thus 10 % 3 evaluates ta 1, whereas 4.2 % 2.0 evaluates ta 0 . 2.
3. Integer division alb where both a n' b iz of type int returns tha integer
quotient only (i.e., tha answer is truncated). Thus, 22/6 gives 3, n' 314 gives
o. If at least one of tha operandz iz of type double, then tha operation becomes
regular floating-point division, n' there is no truncation. I aint talkin' bout chicken n' gravy biatch. Yo ass can control the
kind of division dat is carried up by explicitly castin (one or both of) the
operandz from int ta double n' vice versa. Thus
3.0 I 4 --+ 0.75
3 I 4.0 --+ 0.75
(int) 3.0 I 4 --+ 0
(double) 3 I 4 --+ 0.75
Yo ass must, however, be careful:
(double) (3 I 4) --+ 0.0
since tha integer division 314 is computed first, before castin ta double.
4. Da arithmetic operators follow tha aiiight precedence rulez (order of operations):
(1) parentheses, from tha inner ones up (highest precedence)
(2) *,1,%
(3) +, - Qowest precedence)
Here operators on tha same line have tha same precedence, and, up in tha absence
of parentheses, is invoked from left ta right. Thus tha expression
19 % 5 * 3 + 14 I 5 evaluates ta 4 * 3 + 2 = 14. Note dat castin has
precedence over all of these operators. Thus, up in tha expression (double) 3/4,
3 is ghon be cast ta double before tha division is done.
Relationizzle Operators
NOTE
--------.--_._._-- ---._----.. _.
Operator
!=
&gt;
&lt;
&gt;=
&lt;=
Meaning
equal to
not equal to
greata than
less than
greata than or equal to
less than or equal to
Example
if (x == 100)
if (age ! = 21)
if (salary &gt; 30000)
if (grade &lt; 65)
if (age &gt;= 16)
if (height &lt;= 6)
1. Relationizzle operators is used up in boolean expressions dat evaluate ta legit or
false.
boolean x = (a != b); Pt II initializes x ta legit if a != b,
II false otherwise
121
122
Do not routinely use
== ta test fo' equality
of floating-point
numbers.
return p == q;
Chapta 1 Introductory Java Language Features
Ilreturns legit if p equals q.
II false otherwise
2. If tha operandz is a int n' a thugged-out double, tha int is promoted ta a thugged-out double as for
arithmetic operators.
3. Relationizzle operators should generally be used only up in tha comparison of primitive
types (i.e., int, double, or boolean). User-defined types is compared
usin tha equals n' compareTo methodz (see pp. 199 n' 227).
4. Be careful when comparin floating-point joints muthafucka! Since floating-point numbers
cannot always be represented exactly up in tha computa memory, they should
not be compared directly rockin relationizzle operators.
Comparin Floating-Point Numbers
Because of round-off errors up in floating-point numbers, you can't
rely on rockin tha == or ! = operators ta compare two double
values fo' equality. They may differ up in they last dope digit
or two cuz of round-off error. Shiiit, dis aint no joke. Instead, you should test that
the magnitude of tha difference between tha numbers is less than
some number bout tha size of tha machine precision. I aint talkin' bout chicken n' gravy biatch. Da machine
precision is probably denoted ( n' is typically bout 10-16
for double precision (i.e., bout 16 decimal digits). Right back up in yo muthafuckin ass. So you would
like ta test suttin' like Ix - yl ~ ( . But dis is no phat if x and
yare straight-up large. For example, suppose x = 1234567890.123456
and y = 1234567890.123457. These numbers is essentially equal
to machine precision, since they differ only up in tha 16th significant
digit. But Ix - yl = 10-6 , not 10-16  So up in general you should
check tha relatizzle difference:
Ix-yl ----«
max(lxl, Iyl) -
To stay tha fuck away from problems wit dividin by zero, code dis as
Ix - yl ~ (max(lxl, Iyl)
An example of code dat uses a cold-ass lil erect comparison of real numbers can be found in
the Shape class on p. 199.
Logical Operators
Operator Meaning
&amp;&amp;
II
NOT
AND
OR
Example
if (!found)
if (x &lt; 3 &amp;&amp; Y &gt; 4)
if (age &lt; 2 I I height &lt; 4)
Operators
NOTE
1. Logical operators is applied ta boolean expressions ta form compound boolean
expressions dat evaluate ta legit or false.
2. Valuez of legit or false is assigned accordin ta tha real deal tablez fo' tha logical
operators.
&amp;&amp; T F Pt II T F ! I
--- - ~---
- __ '0 - - j - -- -
T T F T T T T i F
F F F F T F F ,I T
For example, F &amp;&amp; T evaluates ta F, while T I I F evaluates ta T.
3. Right back up in yo muthafuckin ass. Short-circuit evaluation. I aint talkin' bout chicken n' gravy biatch. Da subexpressions up in a cold-ass lil compound boolean expression
are evaluated from left ta right, n' evaluation automatically stops as
soon as tha value of tha entire expression is known. I aint talkin' bout chicken n' gravy biatch. For example, consider
a boolean OR expression of tha form A I I B, where A n' B is some boolean
expressions. If A is true, then tha expression is legit irrespectizzle of tha value
of B. Right back up in yo muthafuckin ass. Similarly, if A is false, then A &amp;&amp; B evaluates ta false irrespectizzle of the
second operand. Y'all KNOW dat shit, muthafucka! So up in each case tha second operand aint evaluated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. For example,
,.
if (numScores != 0 &amp;&amp; scoreTotal/numScores &gt; 90)
will not cause a run-time Ari thmeticException (division-by-zero error) if the
value of numScores is o. This is cuz numScores ! = 0 will evaluate ta false,
causin tha entire boolean expression ta evaluate ta false without havin to
evaluate tha second expression containin tha division.
Assignment Operators
Operator Example
x = 2
+= x += 4
Y -= 6
*= p *= 5
/= n /= 10
%= n %= 10
NOTE
Meaning
simple assignment
x = x + 4
Y = Y - 6
P = P * 5
n = n / 10
n = n % 10
1 fo' realz. All these operators, wit tha exception of simple assignment, is called compound
assignment operators.
2. Chainin of assignment statements be allowed, wit evaluation from right to
left.
int next, prev, sum;
next = prev = sum = 0; //initializes sum ta 0, then prev ta 0
//then next ta 0
123
124 Chapta 1 Introductory Java Language Features
Increment n' Decrement Operators
Operator . Example Meaning
++ i++ or ++i i is incremented by 1
k- or -k k is decremented by 1
Note dat i ++ (postfix) n' ++i (prefix) both have tha net effect of incrementing
i by 1 yo, but they is not equivalent. For example, if i currently has tha value 5,
then System. out. println (i++) will print 5 n' then increment i ta 6, whereas
System.out.println(++i) will first increment i ta 6 n' then print 6. It aint nuthin but easy as fuck  to
remember: if tha ++ is first, you first increment fo' realz. A similar distinction occurs between
k- n' -k. (Note: Yo ass do not need ta know these distinctions fo' tha AP exam.)
Operator Precedence
highest precedence - (1) I. , ++, -
(2) *, I, %
(3) + , -
(4) &lt;, &gt;, &lt;= , &gt;=
(5) !=
(6) &amp;&amp;
(7) Pt II
lowest precedence - (8) = , += , -= , *= , 1=, %=
Here operators on tha same line have equal precedence. Da evaluation of tha operators
with equal precedence is from left ta right, except fo' rows (1) n' (8) where the
order is right ta left. Well shiiiit, it is easy as fuck  ta remember: tha only "backward" order is fo' the
unary operators (row 1) n' fo' tha various assignment operators (row 8).
Example
What tha fuck iz ghon be output by tha followin statement?
System.out.println(5 + 3 &lt; 6 - 1);
Since + n' - have precedence over &lt;, 5 + 3 n' 6 - 1 is ghon be evaluated before evaluating
the boolean expression. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Since tha value of tha expression is false, tha statement
will output false.
INPUT/OUTPUT
Input
Since there be all kindsa nuff ways ta provide input ta a program, user input aint a part of
the AP Java subset. If readin input be a necessary part of a question on tha AP exam,
it is ghon be indicated suttin' like this:
double x = call ta a method dat readz a gangbangin' floating-point number
or
double x = IO.readDouble(); Ilread user input
Input/Output
NOTE
Da Scanner class, freshly smoked up in Java 5.0, simplifies both console n' file input. Well shiiiit, it will not,
however, be tested on tha AP exam.
Output
Testin of output is ghon be restricted ta System. out. print n' System. out. println.
Formatted output aint gonna be tested.
System. up be a object up in tha System class dat allows output ta be displayed on the
screen. I aint talkin' bout chicken n' gravy biatch. Da println method outputs a item n' then goes ta a freshly smoked up line. Da print
method outputs a item without goin ta a freshly smoked up line afterward. Y'all KNOW dat shit, muthafucka! An item ta be printed
can be a string, or a number, or tha value of a funky-ass boolean expression (true or false).
Here is some examples:
System.out.print("Hot");
System.out.println("dog");
system.out.println(IIHotll);}
System.out.println("dog");
System.out.println(7 + 3);
} prints Hotdog
Hot
prints
dog
} prints 10
System.out.println(7 == 2 + 5); } prints true
int x = 27;
System.out.println(x); } prints 27
System.out.println("Value of x is Pt II + x);
prints Value of x is 27
In tha last example, tha value of x, 27, is converted ta tha strang "27", which is then
concatenated ta tha strang "Value of x is ".
To print tha "values" of user-defined objects, tha toStringO method is invoked (see
p.226).
Escape Sequences
An escape sequence be a funky-ass backslash followed by a single character n' shit. Well shiiiit, it is used ta print
special characters. Da three escape sequences dat you should know fo' tha AP exam
are
Here is some examples:
Escape Sequence
\n
\"
\\
Meaning
newline
double quote
backslash
System.out.println("Welcome to\na freshly smoked up linen);
prints
125
126 Chapta 1 Introductory Java Language Features
Welcome to
a freshly smoked up line
Da statement
System.out.println("Dude is known as \"Hothead Harry\".");
prints
Dude is known as "Hothead Harry".
Da statement
System. out. println &lt; "Da file path is d: \\myFilez \\ .. ") ;
prints
Da file path is d:\myFiles\ ..
bEll I 
CONTROL STRUCTURES
D
Control structures is tha mechanizzle by which you make tha statementz of a program
run up in a nonsequential order n' shit. There is two general types: decision makin and
iteration.
Decision-Makin Control Structures
These include tha if, if ... else, n' switch statements, n' you can put dat on yo' toast. They is all selection control
structures dat introduce a thugged-out decision-makin mobilitizzle tha fuck into a program. Based on tha real deal
value of a funky-ass boolean expression, tha computa will decizzle which path ta follow. The
switch statement aint part of tha AP Java subset.
THE if STATEMENT
if <boolean expression)="" {="" statements="" }="" here="" tha="" is="" ghon="" be="" executed="" only="" if="" boolean="" expression="" true="" yo.="" h="" it="" false,="" control="" passes="" immediately="" ta="" straight-up="" original="" gangsta="" statement="" followin="" statement.="" the="" ...="" else="" <boolean="" ,{="" true,="" test="" will="" executed.="" y'all="" know="" dat="" shit,="" muthafucka!="" this="" type'a="" shiznit="" happens="" all="" time="" structures="" nested="" part="" of="" a="" itself="" statement,="" result="" example="" 1="" (boolean="" expr="" 1)="" expr2)="" statement;="" equivalent="" to="" exprl="" &:&:="" 2="" beware="" danglin="" biaaatch!="" suppose="" you="" wanna="" read="" up="" in="" integer="" n'="" print="" it's="" positizzle="" even.="" i="" aint="" talkin'="" bout="" chicken="" gravy="" biatch.="" code="" do="" thang?="" int="" n="IO.readlnt();" (n=""> 0)
else
if (n % 2 == 0)
System.out.println(n);
//read user input
System.out.println(n + " aint positive");
A user entas 7 n' is surprised ta peep tha output
7 aint positive
Da reason is dat else always gets matched wit .the nearest unpaired if, not tha first
if as tha indentin would suggest.
There is two ways ta fix tha precedin code. Da first is ta use {} delimitas to
group tha statements erectly.
int n = IO.readlnt();
if (n &gt; 0)
{
}
else
if (n % 2 == 0)
System.out.println(n);
//read user input
System.out.println(n + " aint positive");
Da second way of fixin tha code is ta rearrange tha statements.
int n = IO.readlnt();
if (n &lt;= 0)
//read user input
System.out.println(n + " aint positive");
else
if (n % 2 == 0)
System.out.println(n);
127
128 Chapta 1 Introductory Java Language Features
EXTENDED if STATEMENT
For example,
Strin grade = IO.readString(); //read user input
if (grade.equals("A"»
System.out.println("Excellent!");
else if (grade.equals("B"»
System.out.println("Good");
else if (grade.equals("C") I I grade.equals("D"»
System.out.println("Poor");
else if (grade.equals("F"»
System.out.println("Egregious!");
else
System.out.println("Invalid grade");
H any of A, B, C, D, or F is entered, a appropriate message is ghon be freestyled n' control
will git all up in tha statement immediately followin tha extended if statement.' H any
other strang is entered, tha final else is invoked, n' tha message Invalid grade will
be written.
Iteration
Java has three different control structures dat allow tha computa ta big-ass up iterative
tasks: tha fo' loop, while loop, n' do ... while loop. Da do ... while loop aint in
the AP Java subset.
THE fo' LOOP
Da general form of tha fo' loop is
for (initialization; termination condition; update statement)
{
statements //body of loop
}
Da termination condizzle is tested all up in tha top of tha loop; tha update statement is
performed all up in tha bottom.
Example 1
//outputs 1 2 3 4
for (i = 1; i &lt; 5; i++)
System.out.print(i + Pt II Pt II);
Herez how tha fuck it works. Da loop variable i is initialized ta 1, n' tha termination condition
i &lt; 5 is evaluated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time yo. H it is true, tha body of tha loop is executed n' then tha loop
variable i is incremented accordin ta tha update statement fo' realz. As soon as tha termination
condizzle is false (i.e., i &gt;= 5), control passes ta tha straight-up original gangsta statement following
the loop.
Example 2
Iioutputs 20 19 18 17 16 15
for (k - 20; k &gt;= 15; k--)
System.out.print(k + Pt II Pt II);
Control Structures
Example 3
//outputs 2 4 6 8 10
for (j = 2; j &lt;= 10; j += 2)
System.out.print(j + Pt II Pt II);
NOTE
1. Da loop variable should not have its value chizzled inside tha loop body.
2. Da initializin n' update statements can use any valid constants, variables,
or expreSSIons.
3. Da scope (see p. 155) of tha loop variable can be restricted ta tha loop body by
combinin tha loop variable declaration wit tha initialization. I aint talkin' bout chicken n' gravy biatch. For example,
for (int i = 0; i &lt; 3; i++)
{
}
4. Da followin loop is syntactically valid:
for (int i = 1; i &lt;= 0; i++)
{
}
Da loop body aint gonna be executed at all, since tha exitin condizzle is true
before tha straight-up original gangsta execution.
THE FOR-EACH LOOP
This is used ta iterate over a array or collection. I aint talkin' bout chicken n' gravy biatch. Da general form of tha loop is
for (SomeType element : collection)
{
statements
}
(Read tha top line as "For each element of type SomeType up in collection ... ")
Example
//Outputs all elementz of arr, one per line.
for (int element : arr)
System.out.println(element);
NOTE
1. Da for-each loop cannot be used fo' replacin or removin elements as you
traverse.
2. Da loop hides tha index variable dat is used wit arrays.
3. Da loop hides tha iterator dat is used wit collections other than arrays (see
p.476).
129
ABONLY
130
Da body of a while
loop must contain a
statement dat leads
to termination.
Chapta 1 Introductory Java Language Features
THE while LOOP
Da general form of tha while loop is
while (boolean test)
{
statements //loop body
}
Da boolean test is performed all up in tha beginnin of tha loop. If true, tha loop body is
executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Otherwise, control passes ta tha straight-up original gangsta statement followin tha loop fo' realz. After
execution of tha loop body, tha test is performed again. I aint talkin' bout chicken n' gravy biatch. If true, tha loop is executed
again, n' so on.
Example 1
int i = 1. mult3 = 3;
while (mult3 &lt; 20)
{
}
System.out.print(mult3 + Pt II Pt II);
i++;
mult3 *= i;
//outputs 3 6 18
NOTE
1. Well shiiiit, it is possible fo' tha body of a while loop never ta be executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This will
happen if tha test evaluates ta false tha last time.
2. Disasta will strike up in tha form of a infinite loop if tha test can never be false.
Don't forget ta chizzle tha loop variable up in tha body of tha loop up in a way that
leadz ta termination!
Example 2
int power2 = 1;
while (power2 != 20)
{
}
System.out.println(power2);
power2 *= 2;
Since power2 aint NEVER gonna exactly equal 20, tha loop will grind merrily along eventually
causin a integer overflow.
Example 3
/* Screen up shitty data .
* Da loop won't allow execution ta continue until a valid
* integer is entered. Y'all KNOW dat shit, muthafucka! */
System.out.println("Enta a positizzle integer from 1 ta 100");
int num = IO.readInt(); //read user input
while (num &lt; 1 I I num &gt; 100)
{
}
System.out.println("Number must be from 1 ta 100.";
System.out.println("Please reenter");
num = IO.readInt();
Control Structures
Example 4
/* Uses a sentinel ta terminizzle data entered all up in tha keyboard.
* Da sentinel be a value dat cannot be part of tha data.
* It signals tha end of tha list. */
final int SENTINEL = -999;
System.out.println("Enta list of positizzle integers," +
II end list wit Pt II + SENTINEL);
int value = IO.readInt(); //read user input
while (value != SENTINEL)
{
process tha value
value = IO.readInt(); //read another value
}
NESTED LOOPS
Yo ass create a nested loop when a loop be a statement up in tha body of another loop.
Example 1
for (int k = 1; k &lt;= 3; k++)
{
}
Think:
for (int i = 1; i &lt;= 4; i++)
System.out.print("*");
System.out.println();
for each of 3 rows
{
}
print 4 stars
go ta next line
Output:
****
****
****
Example 2
This example has two loops nested up in a outa loop.
for (int i = 1; i &lt;= 6; i++)
{
}
for (int j = 1; j &lt;= i; j++)
System.out.print("+");
for (int j = 1; j &lt;= 6 - i; j++)
System.out.print("*");
System.out.println();
Output:
131
132 Chapta 1 Introductory Java Language Features
+*****
++****
+++***
++++**
+++++*
++++++
_____IIi I ___' 'III!_lI_ ____I Pt IIIIiII _______
ERRORS AND EXCEPTIONS
An exception be a error condizzle dat occurs durin tha execution of a Java program.
For example, if you divide a integer by zero, a ArithmeticException will
be thrown. I aint talkin' bout chicken n' gravy biatch. If you bust a wack array index, a ArraylndexOutOfBoundsException
will be thrown.
An unchecked exception is one where you don't provide code ta deal wit tha error.
Such exceptions is automatically handled by Javaz standard exception-handling
methods, which terminizzle execution. I aint talkin' bout chicken n' gravy biatch. Yo ass now need ta fix yo' code!
A checked exception is one where you provide code ta handle tha exception, either a
try/catch/finally statement, or a explicit throw new ... Exception clause. These
exceptions is not necessarily caused by a error up in tha code. For example, a unexpected
end-of-file could be cuz of a gangbangin' fucked up network connection. I aint talkin' bout chicken n' gravy biatch. Checked exceptions
are not part of tha AP Java subset.
Da followin exceptions is up in tha AP Java subset:
Exception
ArithmeticException
NullPointerException
ClassCastException
ArraylndexOutOfBoundsException
IndexOutOfBoundsException
NoSuchElementException
IllegalStateException
IllegalArgumentException
Discussed on page
this page
158
195
288
298
369,475,477,484
476,477
next page, 580
Java allows you ta write code dat throws a standard unchecked exception. I aint talkin' bout chicken n' gravy biatch yo. Here are
typical examples:
Example 1
if (numScores == 0)
throw new ArithmeticException("Cannot divide by zero");
else
findAverageScore();
Example 2
hood void setRadius(int newRadius)
{
}
if (newRadius &lt; 0)
else
throw new IllegalArgumentException
("Radius cannot be negative")j
radius = newRadiusj
ErrorS n' Exceptions
NOTE
1. throw n' freshly smoked up is both reserved lyrics.
2. Da error message is optional: Da line up in Example 1 could have read
throw new ArithmeticException();
Da message, however, is useful, since it  drops some lyrics ta tha thug hustlin tha program
what went wrong.
3 fo' realz. An IllegalArgumentException is thrown ta indicate dat a parameta do not
satisfy a methodz precondition.
4. Freestylin code ta throw yo' own exceptions aint part of tha Level A subset.
Level AB hustlas may be axed ta throw a NoSuchElementException, an
IllegalStateException, or a IllegalArgumentException.
Chapta Summary
Be shizzle dat you KNOW tha difference between primitizzle n' user-defined types,
and between tha followin typez of operators: arithmetic, relational, logical, n' assignment.
Know which conditions lead ta what tha fuck typez of errors.
Yo ass should be able ta work wit numbers-know how tha fuck ta compare them, n' how
to convert between decimal, binary, n' hexadecimal numbers. Know how tha fuck integers
and floating-point numbers is stored up in memory, n' be aware of tha conditions that
can lead ta round-off error.
Be familiar wit each of tha followin control structures: conditionizzle statements,
for loops, while loops, n' for-each loops.
Be aware of tha AP exam expectations concernin input n' output.
133
134 Chapta 1 Introductory Java Language Features
MULTIPLE-CHOICE QUESTIONS ON INTRODUCTORY
JAVA LANGUAGE CONCEPTS
1. Which of tha followin pairz of declarations will cause a error message?
I double x = 14.7;
int y = x;
II double x = 14.7;
int y = (int) x;
III int x = 14;
double y = x;
(A) None
(B) I only
(C) Pt II only
(D) Pt III only
(E) I n' Pt III only
2. What output is ghon be produced by
System.out.print("\\* This is not\n a cold-ass lil comment *\\");
(A) * This aint a cold-ass lil comment *
(B) \* This aint a cold-ass lil comment *\
(C) * This is not
a comment *
(D) \\* This is not
a comment *\\
(E) \* This is not
a comment *\
Multiple-Choice Thangs on Introductory Java Language Concepts
3. Refer ta tha followin code fragment:
double answer = 13 / 5;
System.out.println("13/ 5 = Pt II + answer);
Da output is
13 / 5 = 2.0
Da programmer intendz tha output ta be
13 / 5 = 2.6
Which of tha followin replacements fo' tha straight-up original gangsta line of code aint gonna fix the
problem?
(A) double answer = (double) 13 / 5;
(B) double answer = 13 / (double) 5;
(C) double answer = 13.0 / 5;
0) double answer = 13 / 5.0;
(E) double answer = (double) (13/5);
4. What value is stored up in result if
int result = 13 - 3 * 6 / 4 % 3;
(A) -5
(B) 0
(C) 13
0) -1
(E) 12
5. Right back up in yo muthafuckin ass. Suppose dat addizzle n' subtraction had higher precedence than multiplication
and division. I aint talkin' bout chicken n' gravy biatch. Then tha expression
2 + 3 * 12 / 7 - 4 + 8
would evaluate ta which of tha following?
(A) 11
(B) 12
(C) 5
0) 9
(E) -4
6. Let x be a variable of type double dat is positizzle fo' realz. A program gotz nuff the
boolean expression (Math. pow (x. 0.5) == Math. sqrt (x». Even though x 1/2 is
mathematically equivalent ta IX, tha above expression returns tha value false
in a hustlaz program. Which of tha followin is da most thugged-out likely reason?
(A) Math. pow returns a int, while Math. sqrt returns a thugged-out double.
(B) x was imprecisely calculated up in a previous program statement.
(C) Da computa stores floating-point numbers wit 32-bit lyrics.
0) There is round-off error up in calculatin tha pow n' sqrt functions.
(E) There is overflow error up in calculatin tha pow function.
135
136 Chapta 1 Introductory Java Language Features
7. Consider tha followin code segment
if (n != 0 it x / n &gt; 100)
statementl ;
else
statement2 ;
If n iz of type int n' has a value of 0 when tha segment is executed, what tha fuck will
happen?
(A) An ArithmeticException is ghon be thrown.
(B) A syntax error will occur.
(C) statementl yo, but not statement2, is ghon be executed.
(D) statement2 yo, but not statementl, is ghon be executed.
(E) Neither statementl nor statement2 is ghon be executed; control will pass ta the
first statement followin tha if statement.
8. What will tha output be fo' tha followin skankyly formatted program segment, if
the input value fo' num is 22?
int num = call ta a method dat readz a integer;
if (num &gt; 0)
if (num % 5 == 0)
System.out.println(num);
else System.out.println(num + " is negative");
(A) 22
(B) 4
(C) 2 is negative
(D) 22 is negative
(E) Nothang is ghon be output.
Multiple-Choice Thangs on Introductory Java Language Concepts
9. Look all up in tha followin skankyly formatted program segment. If a = 7 n' c = 6
before execution, which of tha followin represents tha erect jointz of c, d,
p, n' t afta execution, biatch? An undetermined value is represented wit a question
mark.
if (a == 6)
if (c == 6)
{
}
else
{
c = 9;
d = 9;
t = 10;
if (c == 6)
c = 5;
}
else p = 9;
(A) c = 6, d = , biatch? .,
(B) c = 5, d = ?
"
(C) c = 6, d = ?
"
(D) c = 5, d = 9,
(E) c = 9, d = 9,
P = 9, t = ?
P = , biatch? t = 10 "
P = , biatch? t = , biatch? "
P = , biatch? t = 10 "
P = , biatch? t = , biatch? "
10. What joints is stored up in x n' y afta execution of tha followin program segment?
int x = 30, Y = 40;
if (x &gt;= 0)
{
}
else
if (x &lt;= 100)
{
}
else
y = x * 3;
if (y &lt; 50)
x /= 10;
y = x * 2;
y = -x;
(A) x = 30 Y = 90
(B) x = 30 y = -30
(C) x = 30 y = 60
(D) x = 3 Y = -3
(E) x = 30 Y = 40
137
138 Chapta 1 Introductory Java Language Features
11. Da boolean expression !A tt B Pt II C is equivalent to
(A) ! A tt (B I I C)
(B) «!A) tt B) Pt II C
(C) (!A) tt (B Pt II C)
OJ) !(A &amp;&amp; B) I I C
(E) ! (A .t.t B I I C)
12 fo' realz. Assume dat a n' b is integers. Da boolean expression
!(a &lt;= b) .t.t (a * b &gt; 0)
will always evaluate ta legit given that
(A) a = b
(B) a &gt; b
(C) a &lt; b
OJ) a &gt; b aQ,d b &gt; 0
(E) a &gt; crew b &lt; 0
13. Given dat a, b, n' c is integers, consider tha boolean expression
(a &lt; b) I I !«c == a * b) tt (c &lt; a»
Which of tha followin will guarantee dat tha expression is true?
(A) c &lt; a is false.
(B) c &lt; a is true.
(C) a &lt; b is false.
OJ) c == a * b is true.
(E) c == a * b is true, n' c &lt; a is true.
14. Given dat n n' count is both of type int, which statement is legit bout the
followin code segments?
I fo' (count = 1; count &lt;= n; count++)
System.out.println(count);
II count = 1;
while (count &lt;= n)
{
}
System.out.println(count);
count++;
(A) I n' Pt II is exactly equivalent fo' all input joints n.
(B) I n' Pt II is exactly equivalent fo' all input joints n ~ 1 yo, but differ when
n::; O.
(C) I n' Pt II is exactly equivalent only when n = O.
OJ) I n' Pt II is exactly equivalent only when n is even.
(E) I n' Pt II is not equivalent fo' any input jointz of n.
Multiple-Choice Thangs on Introductory Java Language Concepts
15. Da followin fragment intendz dat a user will enta a list of positizzle integers at
the keyboard n' terminizzle tha list wit a sentinel:
int value;
final int SENTINEL = -999;
while (value != SENTINEL)
{
//code ta process value
value = IO.readInt();
}
//read user input
Da fragment aint erect. Which be a legit statement?
(A) Da sentinel gets processed.
(B) Da last nonsentinel value entered up in tha list fails ta git processed.
(C) A skanky chizzle of SENTINEL value causes tha loop ta terminizzle before all
values done been processed.
(D) Hustlin tha program wit dis code causes a cold-ass lil compile-time error.
(E) Enterin tha SENTINEL value as tha straight-up original gangsta value causes a run-time error.
16. Right back up in yo muthafuckin ass. Suppose dat base-2 (binary) numbers n' base-16 (hexadecimal) numbers can be
denoted wit subscripts, as shown below:
Which is equal ta 3Dhex?
(A) 111101bin
(B) 101111 bin
(C) 10011bin
(D) 110100bin
(E) 101101bin
17. Consider dis code segment:
int x = 10, Y = 0;
while (x &gt; 5)
{
}
y = 3;
while (y &lt; x)
{
}
y *= 2;
if (y % x == 1)
Y += x;
x -= 3;
2Ahex = 101010bin
System.out.println(x + " " + y);
What tha fuck iz ghon be output afta execution of dis code segment?
(A) 1 6
(B) 7 12
(C) -3 12
(D) 4 12
(E) -3 6
139
140 Chapta 1 Introductory Java Language Features
Thangs 18 n' 19 refer ta tha followin method, checkNumber, which checks the
validitizzle of its four-digit integer parameter.
//Precondition: n be a 4-digit integer.
//Postcondition: Returns legit if n is valid, false otherwise.
boolean checkNumber(int n)
{
}
int d1,d2,d3,checkDigit,nRemaining,rem;
//strip off digits
checkDigit = n % 10;
nRemainin = ri / 10;
d3 = nRemainin % 10;
nRemainin /= 10;
d2 = nRemainin % 10;
nRemainin /= 10;
d1 = nRemainin % 10;
//check validity
rem = (d1 + d2 + d3) % 7;
return rem == checkDigit;
A program invokes method checkNumber wit tha statement
boolean valid = checkNumber(num);
18. Which of tha followin jointz of num will result up in valid havin a value of true?
(A) 6143
(B) 6144
(C) 6145
(D) 6146
(E) 6147
19. What tha fuck iz tha purpose of tha local variable nRemaining?
(A) It aint possible ta separate n tha fuck into digits without tha help of a temporary
variable.
(B) nRemainin prevents tha parameta num from bein altered.
(C) nRemainin enhances tha readabilitizzle of tha algorithm.
(D) On exitin tha method, tha value of nRemainin may be reused.
(E) nRemainin is needed as tha left-hand side operand fo' integer division.
Multiple-Choice Thangs on Introductory Java Language Concepts 141
20. What output is ghon be produced by dis code segment, biatch? (Ignore spacing.)
for (int i = 5; i &gt;= 1; i--)
{
for (int j = i; j &gt;= 1; j--)
System.out.print(2 * j 1) ;
System.out.println();
}
(A) 9 7 5 3 1
9 7 5 3
9 7 5
9 7
9
(B) 9 7 5 3 1
7 5 3 1
5 3 1
3 1
1
(C) 9 7 5 3 1
7 5 3 1 -1
5 3 1 -1 -3
3 1 -1 -3 -5
1 -1 -3 -5 -7
(D) 1
1 3
1 3 5
1 3 5 7
1 3 5 7 9
(E) 1 3 5 7 9
1 3 5 7
1 3 5
1 3
1
142 Chapta 1 Introductory Java Language Features
21. Which of tha followin program fragments will produce dis output, biatch? (Ignore
spacing.)
2 - - - - -
- 4 - - - -
- - 6 - - -
- - - 8 - -
- - -' - 10 -
- - - - - 12
I fo' (int i = 1; i &lt;= 6; i++)
{
}
for (int k = 1; k &lt;= 6; k++)
if (k == i)
System.out.print(2 * k);
else
System.out.print("-");
System.out.println();
IT fo' (int i = 1; i &lt;= 6; i++)
{
}
for (int k = 1; k &lt;= i - 1; k++)
System.out.print("-");
System.out.print(2 * i);
for (int k = 1; k &lt;= 6 - i; k++)
System.out.print("-");
System.out.println();
III fo' (int i = 1; i &lt;= 6; i++)
{
}
for (int k = 1; k &lt;= i - 1; k++)
System.out.print("-");
System.out.print(2 * i);
for (int k = i + 1; k &lt;= 6; k++)
System.out.print("-");
System.out.println();
(A) I only
(B) IT only
(C) Pt III only
(0) I n' IT only
(E) I, IT, n' Pt III
Multiple-Choice Thangs on Introductory Java Language Concepts
22. Consider dis program segment:
int newNum : 0, temp;
int num : k; Ilk is some predefined integer value ~ 0
while (num &gt; 10)
{
}
temp: num % 10;
num I: 10;
newNum : newNum * 10 + temp;
System.out.print(newNum);
Which be a legit statement bout tha segment?
I H 100 ~ num ~ 1000 initially, tha final value of newNum must be up in tha range
10 ~ newNum ~ 100.
II There is no initial value of num dat will cause a infinite while loop.
m H num ~ 10 initially, newNum gonna git a gangbangin' final value of o.
(A) I only
(B) Pt II only
(C) monly
(D) Pt II n' Pt III only
(E) I, Pt II, n' Pt III
143
144 Chapta 1 Introductory Java Language Features
23. Consider tha method reverse:
//Precondition: n &gt; O.
//Postcondition: returns n wit its digits reversed.
//Example: If n = 234. method reverse returns 432.
int reverse(int n)
{
int rem. revNum = 0:
/ * code segment * /
return revNum:
}
Which of tha followin replacements fo' /* code segment */ would cause the
method ta work as intended?
I fo' (int i = 0: i &lt;= n: i++)
{
}
rem = n % 10:
revNum = revNum * 10 + rem:
n /= 10:
II while (n != 0)
{
}
rem = n % 10:
revNum = revNum * 10 + rem;
n /= 10:
III fo' (int i = n: i != 0; i /= 10)
{
rem = i % 10;
revNum = revNum * 10 + rem;
}
(A) I only
(B) Pt II only
(C) I n' Pt II only
(D) Pt II n' Pt III only
(E) I n' Pt III only
Answers Explained
ANSWER KEY
" "  J'
1. B 9 fo' realz. A 17. D
2. E 10 fo' realz. A 18. B
3. E 11. B 19. C
4. E 12. D 20. B
5. C 13 fo' realz. A 21. E
6. D 14 fo' realz. A 22. D
7. D 15. D 23. D
8. D 16 fo' realz. A
ANSWERS EXPLAINED
1. (B) When x is converted ta a integer, as up in segment I, shiznit is lost. Java
requires dat a explicit cast ta a int be made, as up in segment Pt II. Note dat segment
II'ma cause x ta be truncated: tha value stored up in y is 14. By requirin the
explicit cast, Java don't let you do dis accidentally. In segment ill y will contain
the value 14. o. No explicit cast ta a thugged-out double is required since no shiznit
is lost.
2. (E) Da strang argument gotz nuff two escape sequences: '\ \', which means print
a backslash (\), n' '\n', which means git all up in a freshly smoked up line. Chizzle E is tha only
choice dat do both of these.
3. (E) For dis chizzle, tha integer division 13/5 is ghon be evaluated ta 2, which will
then be cast ta 2. o. Da output is ghon be 13/5 = 2. o. Da compila needz a way
to recognize dat real-valued division is required. Y'all KNOW dat shit, muthafucka! All tha other options provide a
way.
4. (E) Da operators *, /, n' % have equal precedence, all higher than -, n' must
be performed first, from left ta right.
13 - 3 * 6 / 4 % 3
13 - 18 / 4 % 3
13 - 4 % 3
13 - 1
12
5. (C) Da expression must be evaluated as if parenthesized like this:
(2 + 3) * 12 / (7 - 4 + 8)
This becomes 5 * 12 / 11 = 60 / 11 = 5.
6. (0) Anytime arithmetic operations is done wit floating-point numbers, roundoff
error occurs. Da Matti class methodz (see p. 234) like fuckin pow n' s,qrt use
various approximations ta generate they lyrics ta tha required accuracy. Right back up in yo muthafuckin ass. Since
they do different internal arithmetic, however, tha round-off will probably not result
in exactly tha same lyrics. Note dat chizzle A aint erect cuz both
145
146 Chapta 1 Introductory Java Language Features
Math. pow n' Math. sqrt return type double. Chizzle B is wack cuz no matter
how x was previously calculated, tha same x is input ta pow n' sqrt. Chizzle
C is wack since round-off error occurs no matta how tha fuck nuff bits is used ta represent
numbers. Chizzle E is wack cuz if x is representable on tha machine
(i.e., aint overflowed), then its square root, x 1/2, aint gonna overflow.
7. (0) Short-circuit evaluation of tha boolean expression will occur. Shiiit, dis aint no joke. Da expression
(n ! = 0) will evaluate ta false, which make tha entire boolean expression
false. Therefore tha expression (x/n &gt; 100) aint gonna be evaluated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time yo. Hence no division
by zero will occur, causin a ArithmeticException ta be thrown. I aint talkin' bout chicken n' gravy biatch. When
the boolean expression has a value of false, only tha else part of tha statement,
statement2, is ghon be executed.
8. (0) Each else gets paired wit tha nearest unpaired if. Thus when tha test
(22 % 5 == 0) fails, tha else part indicatin dat 22 is wack is ghon be executed.
This is clearly not tha intent of tha fragment, which can be fixed using
delimiters:
int num = call ta a method dat readz a integer;
if (num &gt; 0)
{
}
else
if (num % 5 == 0)
System.out.println(num);
System.out.println(num + Pt II is negative");
9. (A) Since (a == 6) is false, the
if (c == 6)
else
{
t = 10; ...
statement aint gonna be executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da second else matches up wit tha straight-up original gangsta if,
which means dat p = 9 gets executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Variablez d n' t remain undefined.
10. (A) Since tha straight-up original gangsta test (x &gt;= 0) is true, tha matchin else part, y = -x, will not
be executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Right back up in yo muthafuckin ass. Since (x &lt;= 100) is true, tha matchin else part, y = x*2, will not
be executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da variable y is ghon be set ta x*3 (i.e., 90) n' will now fail tha test
y &lt; 50. Thus x aint NEVER gonna be altered up in dis algorithm. Final joints is x = 30
and y = 90.
11. (B) Da order of precedence from highest ta lowest is !, &amp;;&amp;;, I I. Thus, tha order
of evaluation is (! A), ( ( ! A) &amp;;&amp;; B), n' finally ((! A) &amp;;&amp;; B) Pt II C.
12. (0) To evaluate ta true, tha expression must reduce ta legit tt true. We therefore
need ! (false) &amp;;&amp;; true. Chizzle D is tha only condizzle dat guarantees
this: a &gt; b provides muthafucka! (false) fo' tha left-hand expression, n' a &gt; crew b &gt; 0
implies both a n' b positive, which leadz ta legit fo' tha right-hand expression.
Choice E, fo' example, will provide legit fo' tha right-hand expression only if a
&lt; o. Yo ass have no shiznit on some n' can't make assumptions bout dat shit.
13. (A) If (c &lt; a) is false, ((c == a*b) &amp;;&amp;; (c &lt; a» evaluates ta false irrespective
of tha value of c == a*b. In dis case, ! (c == a*b &amp;;&amp;; c &lt; a) evaluates to
true. Then (a &lt; b) Pt II legit evaluates ta legit irrespectizzle of tha value of the
test (a &lt; b). In all tha other chizzles, tha given expression may be true. There is
not enough shiznit given ta guarantee this, however.
Answers Explained
14. (A) If n ~ 1, both segments will print up tha integers from 1 all up in n. I aint talkin' bout chicken n' gravy biatch. If n::S 0,
both segments will fail tha test immediately n' do nothing.
15. (0) Da (value ! = SENTINEL) test occurs before value is initialized, causin an
error at compile time. Da code must be fixed by readin tha straight-up original gangsta value before
fuckin wit tha test:
final int SENTINEL = -999;
int value = IO.readInt();
while (value != SENTINEL)
{
}
//code ta process value
value = IO.readInt();
Choices A, B, C, n' E is all incorrect cuz if tha program don't compile, it
won't run! A note, however, bout chizzle C: -999 be a gangbangin' fine chizzle fo' tha sentinel
given dat only positizzle integers is valid input data.
16. (A) Quick method: Convert each hex digit ta binary.
3 Dhex
=0011 1101 (where D equals 13 up in base 10)
= 111101bin
Slow method: Convert 3Dhex ta base 10.
3Dhex = (3)(161) + (D)(160)
=48+ 13
= 61dec
Now convert 61dec ta binary. Write 61 as a sum of descendin powerz of 2:
61=32+16+8+4+1
= 1(25) + 1(24) + 1(23) + 1(22) + 0(21) + 1(20)
= 111101bin
17. (0) Here be a trace of tha jointz of x n' y durin execution. I aint talkin' bout chicken n' gravy biatch. Note dat the
condizzle (y % x == 1) is never legit up in dis example.
; --_.
IX
1._.
I y 3 6 12' 3 : . __ .L__ _1._. __
Da while loop terminates when x is 4 since tha test while (x &gt; 5) fails.
18. (B) Da algorithm findz tha remainder when tha sum of tha straight-up original gangsta three digits of
n is divided by 7. If dis remainder is equal ta tha fourth digit, checkDigit, the
method returns true, otherwise false. Note dat (6+1+4) % 7 equals 4. Thus,
only chizzle B be a valid number.
19. (C) As n gets fucked up down tha fuck into its digits, nRemainin is tha part of n dat remains
afta each digit is stripped off. Thus nRemainin be a self-documentin name that
helps describe what tha fuck is happening. Chizzle A is false cuz every last muthafuckin digit can be
stripped off rockin some sequence of integer division n' mod. Y'all KNOW dat shit, muthafucka! Chizzle B is false
because num is passed by value n' therefore aint gonna be altered when tha method
is exited (see p. 159). Eliminizzle chizzle D: When tha method is exited, all local
variablez is destroyed. Y'all KNOW dat shit, muthafucka! Chizzle E is nonsense.
147
148 Chapta 1 Introductory Java Language Features
20. (8) Da outa loop produces five rowz of output. Each pass all up in tha inner
loop goes from i down ta 1. Thus five odd numbers startin at 9 is printed in
the first row, four odd numbers startin at 7 up in tha second row, n' so on.
21. (E) All three algorithms produce tha given output. Da outa fo' (int i ... )
loop produces six rows, n' tha inner fo' (int k ... ) loops produce tha symbols
in each row.
22. (0) Statement I is false, since if 100 ~ num ~ 109, tha body of tha while loop
will be executed just once. (Afta dis single pass all up in tha loop, tha value of
num is ghon be 10, n' tha test if (num &gt; 10) will fail.) With just one pass, newNum
will be a one-digit number, equal ta temp (which was tha original gangsta num X 10).
Note dat statement IT is true: there cannot be a infinite loop since num /= 10
guarantees termination of tha loop. Right back up in yo muthafuckin ass. Statement ill is legit cuz if num ~ 10, the
loop is ghon be skipped, n' newNum will keep its original gangsta value of o.
23. (0) Da algorithm works by strippin off tha rightmost digit of n (stored in
rem), multiplyin tha current value of revNum by 10, n' addin dat rightmost
digit. When n has been stripped down ta no digits (i.e., n == 0 is true), revNum
is complete. Right back up in yo muthafuckin ass. Segment I is wack cuz tha number of passes all up in tha loop
dependz on tha number of digits up in n, not tha value of n itself.
Classes n' Objects
 Objects n' classes
 Encapsulation
 References
OBJECTS
A m
Work is tha curse of tha drankin classes.
-Oscar Wilde
Chapta Goals
 Keywordz public, private, and
static
 Methods
Every program dat you write involves at least one thang dat is bein pimped or manipulated
by tha program. This thang, together wit tha operations dat manipulate it,
is called a object.
Consider, fo' example, a program dat must test tha validitizzle of a gangbangin' four-digit code
number dat a thug will enta ta be able ta bust a photocopy machine. Rulez for
validitizzle is provided. Y'all KNOW dat shit, muthafucka! Da object be a gangbangin' four-digit code number n' shit. Right back up in yo muthafuckin ass. Some of tha operations
to manipulate tha object could be readNumber, getSeparateDigits, testValidity,
and writeNumber.
Any given program can have nuff muthafuckin different typez of objects, n' you can put dat on yo' toast. For example, a program
that maintains a thugged-out database of all books up in a library has at least two objects:
1 fo' realz. A Book object, wit operations like getTitle, isOnShelf, isFiction, and
goOutOfPrint.
2 fo' realz. A ListOfBooks object, wit operations like search, addBook, removeBook, and
sortByAuthor.
An object is characterized by its state n' behavior. Shiiit, dis aint no joke. For example, a funky-ass book has a state
busted lyrics bout by its title, lyricist, whether itz on tha shelf, n' so on. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it also has behavior,
like goin outta print.
Notice dat a object be a idea, separate from tha concrete detailz of a programming
language. Well shiiiit, it correspondz ta some real-world object dat is bein represented by the
program.
All object-oriented programmin languages gotz a way ta represent a object as a
variable up in a program. In Java, a variable dat represents a object is called a object
reference.
CHAPTER 2
149
150 Chapta 2 Classes n' Objects
CLASSES
A class be a software blueprint fo' implementin objectz of a given type fo' realz. An object be a
single instizzle of tha class. In a program there will often be nuff muthafuckin different instances
of a given class type.
Da current state of a given object is maintained up in its data fieldz or instizzle variables,
provided by tha class. Da methodz of tha class provide both tha behaviors exhibited
by tha object n' tha operations dat manipulate tha object. Combinin a object's
data n' methodz tha fuck into a single unit called a cold-ass lil class is known as encapsulation.
Here is tha framework fo' a simple bank account class:
hood class BankAccount
{
}
private Strin myPassword;
private double myBalance;
hood static final double OVERDRAWN_PENALTY = 20.00;
Ilconstructors
1* Default constructor.
* Constructs bank account wit default joints, n' you can put dat on yo' toast. *1
hood BankAccount()
{ 1* implementation code *1 }
1* Constructs bank account wit specified password n' balance. *1
hood BankAccount(Strin password, double balance)
{ 1* implementation code *1 }
Ilaccessor
1* Returns balizzle of dis account. *1
hood double getBalance()
{ 1* implementation code *1 }
Ilmutators
1* Deposits amount up in bank account wit given password. Y'all KNOW dat shit, muthafucka! *1
hood void deposit(Strin password, double amount)
{ 1* implementation code *1 }
1* Withdraws amount from bank account wit given password.
* Assesses penalty if myBalizzle is less than amount. *1
hood void withdraw(Strin password, double amount)
{ 1* implementation code *1 }
PUBLIC, PRIVATE, AND STATIC
Da keyword hood precedin tha class declaration signals dat tha class is usable by
all client programs. Boy it's gettin hot, yes indeed it is. If a cold-ass lil class aint public, it can be used only by classes up in its own
package. In tha AP Java subset, all classes is public.
Similarly, hood methodz is accessible ta all client programs. Boy it's gettin hot, yes indeed it is. Clients, however, are
not privy ta tha class implementation, n' may not access tha private instizzle variables
and private methodz of tha class. Restriction of access is known as shiznit
Methods
hiding. In Java, dis is implemented by rockin tha keyword private. Private methods
and variablez up in a cold-ass lil class can be accessed only by methodz of dat class. Even though Java
allows hood instizzle variables, up in tha AP Java subset all instizzle variablez is private.
Static final variablez (constants) up in a cold-ass lil class is often declared hood (see some examples
of Math class constants on p. 234). Da variable OVERDRAWN_PENALTY be a example
in tha BankAccount class. Right back up in yo muthafuckin ass. Since tha variable is public, it can be used up in any client
method. Y'all KNOW dat shit, muthafucka! Da keyword static indicates dat there be a single value of tha variable that
applies ta tha whole class, rather than a freshly smoked up instizzle fo' each object of tha class fo' realz. A
client method would refer ta tha variable as BankAccount. OVERDRAWN_PENALTY. In its
own class it is referred ta as simply OVERDRAWN_PENALTY.
See p. 153 fo' static methods.
METHODS
Headers
All method headers, wit tha exception of constructors (see below) n' static methods
(p. 153), be lookin like this:
public
"-v--"
void
'-v-"
withdraw (Strin password, double amount)
~ , v~----------~'
access specifier return type method name parameta list
NOTE
1. Da access specifier  drops some lyrics ta which other methodz can call dis method (see Public,
Private, n' Static on tha previous page).
2 fo' realz. A return type of void signals dat tha method do not return a value.
3. Items up in tha parameta list is separated by commas.
Da implementation of tha method directly bigs up tha header, enclosed up in a {}
block.
Typez of Methods
CONSTRUCTORS
A constructor creates a object of tha class. Yo ass can recognize a cold-ass lil constructor by its
name-always tha same ol' dirty as tha class fo' realz. Also, a cold-ass lil constructor has no return type.
Havin nuff muthafuckin constructors serves up different wayz of initializin class objects, n' you can put dat on yo' toast. For
example, there be two constructors up in tha BankAccount class.
1. Da default constructor has no arguments, n' you can put dat on yo' toast. Well shiiiit, it serves up reasonable initial joints
for a object yo. Here is its implementation:
/* Default constructor.
* Constructs a funky-ass bank account wit default joints */
hood BankAccount()
{
}
myPassword = "";
myBalizzle = 0.0;
In a cold-ass lil client method, tha declaration
151
152 Chapta 2 Classes n' Objects
BankAccount b = freshly smoked up BankAccount();
constructs a BankAccount object wit a funky-ass balizzle of zero n' a password equal
to tha empty string. Da freshly smoked up operator returns tha address of dis newly constructed
object. Da variable b be assigned tha value of dis address-we say ,"b
is a reference ta tha object.» Picture tha setup like this:
BankAccount
b
c===J----~.~ myPassword 1111
myBalizzle 0
2. Da constructor wit parametas sets tha instizzle variablez of a BankAccount
object ta tha jointz of dem parameters.
NOTE
Here is tha implementation:
/* Constructor . Constructs a funky-ass bank account with
* specified password n' balizzle */
hood BankAccount(Strin password, double balance)
{
}
myPassword = password;
myBalizzle = balance;
In a cold-ass lil client program a thugged-out declaration dat uses dis ,constructor needz matching
parameters:
BankAccount c freshly smoked up BankAccount("KevinC", 800.00);
BankAccount
c
c===J----~.~ myPassword "KevinC"
myBalizzle 800.00
band c is object variablez dat store tha addressez of they respectizzle BankAccount objects.
They do not store tha objects theyselves (see References on p. 156).
ACCESSORS
An accessor method accesses a cold-ass lil class object without alterin tha object fo' realz. An accessor
returns some shiznit bout tha object.
Da BankAccount class has a single accessor method, getBalizzle O yo. Here is its implementation:
Methods
1* Returns tha balizzle of dis account *1
hood double getBalance()
{ return myBalance; }
A client program may use dis method as bigs up:
BankAccount bi = freshly smoked up BankAccount(IMattW", 500.00);
BarikAccount b2 = freshly smoked up BankAccount(IDannyB", 650.50);
if (bi.getBalance() &gt; b2.getBalance(»
NOTE
The. operator (dot operator) indicates dat getBalizzle 0 be a method of tha class to
which bi n' b2 belong, namely tha BankAccount class.
MUTATORS
A mutator method chizzlez tha state of a object by modifyin at least one of its instance
variables.
Here is tha implementationz of tha deposit n' withdraw methods, each of which
altas tha value of myBalizzle up in tha BankAccount class:
1* Deposits amount up in a funky-ass bank account wit tha given password. Y'all KNOW dat shit, muthafucka! *1
hood void deposit(Strin password, double amount)
{
myBalizzle += amount;
}
1* Withdraws amount from a funky-ass bank accoUnt wit tha given password.
* Assesses a penalty if myBalizzle is less than amount. *1
hood void withdraw(Strin password, double amount)
{
}
if (myBalizzle &gt;= amount)
myBalizzle -= amount;
else
myBalizzle -= OVERDRAWN_PENALTY; Iiallows wack balance
A mutator method up in a cold-ass lil client program is invoked up in tha same way as a accessor: using
an object variable wit tha dot operator. Shiiit, dis aint no joke. For example, assumin valid BankAccount
declarations fo' bi n' b2:
b1.withdraw(IMattW",200.00);
b2. deposit (IDannyB" , 35.68);
STATIC METHODS
Static Methodz vs. Instizzle Methodz Da methodz discussed up in tha preceding
sections-constructors, accessors, n' mutatqrs-all operate on individual objectz of a
class. They is called instizzle methodz fo' realz. A method dat performs a operation fo' the
entire class, not its individual objects, is called a static method (sometimes called a cold-ass lil class
method).
Da implementation of a static method uses tha keyword static up in its header n' shit. There
is no implied object up in tha code (as there is up in a instizzle method). Thus if tha code
153
154 Chapta 2 Classes n' Objects
tries ta booty-call a instizzle method or invoke a private instizzle variable fo' dis nonexistent
object, a syntax error will occur.
Herez a example of a static method dat might be used up in tha BankAccount class:
hood static-double getlnterestRate()
{
}
System.out.println("Enta interest rate fo' bank account");
System.out.println("Enta up in decimal form:");
double rate = IO.readDouble(); Pt II read user input
return rate;
Since tha rate thatz returned by dis method applies ta all bank accounts up in tha class,
not ta any particular BankAccount object, itz appropriate dat tha method should be
static.
Recall dat a instizzle method is invoked up in a cold-ass lil client program by rockin a object
variable followed by tha dot operator followed by tha method name:
BankAccount b = freshly smoked up BankAccount();
b.deposit(password, amount); Ilinvokes tha deposit method for
IIBankAccount object b
A static method, by contrast, is invoked by rockin tha class name wit tha dot operator:
double interestRate = BankAccount.getlnterestRate();
Static Methodz up in a Driver Class Often a cold-ass lil class dat gotz nuff tha main 0 method
is used as a thugged-out driver program ta test other classes. Usually such a cold-ass lil class creates no objects
of tha class. Right back up in yo muthafuckin ass. So all tha methodz up in tha class must be static. Note dat all up in tha start of
program execution, no objects exist yet. Right back up in yo muthafuckin ass. So tha main 0 method must always be static.
For example, here be a program dat tests a cold-ass lil class fo' readin integers entered at the
keyboard. Y'all KNOW dat shit, muthafucka! -
import java.util.*;
hood class GetListTest
{
}
1* Return a list of integers from tha keyboard. Y'all KNOW dat shit, muthafucka! *1
hood static List<integer> getList()
{
}
&lt; code ta read integers tha fuck into a&gt;
return a;
1* Write contentz of List a. *1
hood static void writeList(List<integer> a)
{
System.out.println("List is : Pt II + a);
}
hood static void main(String[] args)
{
}
List<integer> list = getList();
writeList(list);
Scope
NOTE
1. Da calls ta writeList(list) n' getListO do not need ta be preceded by
GetListTest plus a thugged-out dot cuz main aint a cold-ass lil client program: It be up in tha same
class as getList n' writeList.
2. If you omit tha keyword static from tha getList or wri teList header, you
get a error message like tha following:
Can't make static reference ta method getList()
in class GetListTest
Da compila has recognized dat there was no object variable precedin the
method call, which means dat tha methodz was static n' should have been
declared as such.
Method Overloading
Overloaded methodz is two or mo' methodz up in tha same class dat have tha same
name but different parameta lists, n' you can put dat on yo' toast. For example,
hood class DoOperations
{
hood int product(int n) { return n * n; }
hood double product(double x) { return x * x; }
hood double product(int x, int y) { return x * y; }
Da compila figures up which method ta booty-call by examinin tha methodz signature.
Da signature of a method consistz of tha methodz name n' a list of tha parameter
types. Thus tha signaturez of tha overloaded thang methodz are
thang (int)
thang (double)
thang (int , int)
Note dat fo' overloadin purposes, tha return type of tha method is irrelevant.
Yo ass can't have two methodz wit identical signatures but different return types. The
compila will diss dat tha method call be ambiguous.
Havin mo' than one constructor up in tha same class be a example of overloading.
Overloaded constructors provide a cold-ass lil chizzle of ways ta initialize objectz of tha class .
 a. ilil!t' JS
SCOPE
&amp;&amp;]a Ib~"'_"'''''''.''''''''_' _I Pt IIII"!!IIIIIIl''''?_''''''''':SZ.''''''''R'''1" "'F~"'i._' ____''' ''iI'Il'''''''''ti!l'''II_''''_'''s!_A_ _____III ...
Da scope of a variable or method is tha region up in which dat variable or method is
visible n' can be accessed.
Da instizzle variables, static variables, n' methodz of a cold-ass lil class belong ta dat class's
scope, which extendz from tha openin brace ta tha closin brace of tha class definition.
Within tha class all instizzle variablez n' methodz is accessible n' can be
referred ta simply by name (no dot operator!).
A local variable is defined inside a method. Y'all KNOW dat shit, muthafucka! Well shiiiit, it can even be defined inside a statement.
Its scope extendz from tha point where it is declared ta tha end of tha block up in which
its declaration occurs fo' realz. A block be a piece of code enclosed up in a {} pair. Shiiit, dis aint no joke. When a funky-ass block is
exited, tha memory fo' a local variable be automatically recycled.
155
156 Chapta 2 Classes n' Objects
Local variablez take precedence over instizzle variablez wit tha same name. (Using
the same name, however, creates ambiguitizzle fo' tha programmer, leadin ta errors. You
should stay tha fuck away from tha practice.)
Da dis Keyword
An instizzle method be always called fo' a particular object. This object be a implicit
parameta fo' tha method n' is referred ta wit tha keyword this.
In tha implementation of instizzle methods, all instizzle variablez can be written
with tha prefix dis followed by tha dot operator.
Example 1
Da deposit method of tha BankAccount class can refer ta myBalizzle as bigs up:
hood void deposit(Strin password, double amount)
{
this.myBalizzle +z amount;
}
Da use of dis is unnecessary up in tha above example.
Example 2
Consider a rationizzle number class called Rational, which has two private instance
variables:
private int num;
private int denom;
//numerator
//denominator
Now consider a cold-ass lil constructor fo' tha Rationizzle class:
hood Rational(int num. int denom)
{
}
this.num = num;
this.denom = denom;
It be definitely not a phat scam ta use tha same name fo' tha explicit parametas n' the
private instizzle variables. But if you do, you can stay tha fuck away from errors by referrin ta all dis bullshit. num
and all dis bullshit. denom fo' tha current object dat is bein constructed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (fhis particular use
of dis aint gonna be tested on tha exam.)
REFERENCES
Reference vs. Primitizzle Data Types
All of tha numerical data types, like double n' int, as well as types char n' boolean,
are primitizzle data types fo' realz. All objects is reference data types. Da difference lies up in the
way they is stored.
Consider tha statements
int numl = 3;
int num2 = numl;
References
Da variablez num1 n' num2 can be thought of as memory slots, labeled num1 n' num2,
respectively:
num1 num2 o 0
If either of tha above variablez is now chizzled, tha other aint affected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Each has its
own memory slot.
Contrast dis wit tha declaration of a reference data type. Recall dat a object is
created rockin new:
Date d = freshly smoked up Date(2, 17, 1948);
This declaration creates a reference variable d dat refers ta a Date object. Da value of
d is tha address up in memory of dat object:
Date
d D-. myMonth 2
myDizzle 17
myYear 1948
Suppose tha followin declaration is now made:
Date birthdizzle = d;
This statement creates tha reference variable birthday, which gotz nuff tha same ol' dirty address
as d:
d Date
D ~
myMonth 2
birthdizzle myDizzle 17
D ~ myYear 1948
Havin two references fo' tha same object is known as aliasin fo' realz. Aliasin can cause
unintended problems fo' tha programmer n' shit. Da statement
d.changeDate();
will automatically chizzle tha object referred ta by birthdizzle as well.
What tha programmer probably intended was ta create a second object called
birthdizzle whose attributes exactly matched dem of d. Y'all KNOW dat shit, muthafucka! This cannot be accomplished
without rockin new. For example,
Date birthdizzle = freshly smoked up Date (d . getMonth(), d.getDay(), d.getYear(»;
Da statement d. Y'all KNOW dat shit, muthafucka! chizzleDate () will now leave tha birthdizzle object unchanged.
157
158
Do not make a
method call wit an
object whose value is
null.
Chapta 2 Classes n' Objects
Da Null Reference
Da declaration
BankAccount b;
defines a reference b dat is uninitialized. Y'all KNOW dat shit, muthafucka! (To construct tha object dat b refers to
requires tha freshly smoked up operator n' a BankAccount constructor.) An uninitialized object
variable is called a null reference or null pointer n' shit. Yo ass can test whether a variable refers
to a object or is uninitialized by rockin tha keyword null:
if (b == null)
If a reference aint null, it can be set ta null wit tha statement
b = null;
An attempt ta invoke a instizzle method wit a null reference may cause your
program ta terminizzle wit a NullPointerException. I aint talkin' bout chicken n' gravy biatch. For example,
hood class PersonalFinances
{
BankAccount b;
b.withdraw(password, amt);
NOTE
lib be a null reference
Iithrows a NullPointerException
Ilif b not constructed wit new
If you fail ta initialize a local variable up in a method before you use it, yo big-ass booty is ghon git a
compile-time error. Shiiit, dis aint no joke. If you make tha same fuck up wit a instizzle variable of a cold-ass lil class,
the compila serves up reasonable default joints fo' primitizzle variablez (0 fo' numbers,
false fo' booleans), n' tha code may run without error. Shiiit, dis aint no joke. But fuck dat shiznit yo, tha word on tha street is dat if you don't
initialize reference instizzle variablez up in a cold-ass lil class, as up in tha above example, tha compiler
will set dem ta null fo' realz. Any method call fo' a object of tha class dat tries ta access
the null reference will cause a run-time error: Da program will terminizzle wit a
NullPointerException.
Method Parameters
FORMAL VS fo' realz. ACTUAL PARAMETERS
Da header of a method defines tha parametaz of dat method. Y'all KNOW dat shit, muthafucka! For example, consider
the withdraw method of tha BankAccount class:
hood class BankAccount
{
hood void withdraw(Strin password, double amount)
This method has two explicit parameters, password n' amount. These is dummy or
formal parameters. Think of dem as placeholdaz fo' tha pair of actual parametas or
arguments dat is ghon be supplied by a particular method call up in a cold-ass lil client program.
For example,
References
BankAccount b = freshly smoked up BankAccount(ITimB", 1000);
b.withdraw(ITimB", 250);
Here ITimB" n' 250 is tha actual parametas dat match up wit password and
amount fo' tha withdraw method.
NOTE
1. Da number of arguments up in tha method call must equal tha number of parameters
in tha method header, n' tha type of each argument must be compatible
with tha type of each correspondin parameter.
2. In addizzle ta its explicit parameters, tha withdraw method has a implicit
parameter, this, tha BankAccount from which scrilla is ghon be withdrawn. I aint talkin' bout chicken n' gravy biatch. In
the method call
b.withdraw(ITimB", 250);
the actual parameta dat matches up wit dis is tha object reference b.
PASSING PRIMITIVE TYPES AS PARAMETERS
Parametas is passed by value. For primitizzle types dis means dat when a method is
called, a freshly smoked up memory slot be allocated fo' each parameter n' shit. Da value of each argument
is copied tha fuck into tha newly pimped memory slot correspondin ta each parameter.
Durin execution of tha method, tha parametas is local ta dat method. Y'all KNOW dat shit, muthafucka! Any
changes made ta tha parametas aint gonna affect tha jointz of tha arguments up in tha calling
program. When tha method is exited, tha local memory slots fo' tha parametas are
erased.
Herez a example: What will tha output be?
hood class ParamTest
{
}
hood static void foo(int x, double y)
{
x = 3;
y = 2.5;
}
hood static void main(String[] args)
{
}
int a = 7;
double b = 6.5;
foo(a, b);
System.out.println(a + Pt II Pt II + b);
Da output will be
7 6.5
Da arguments a n' b remain unchanged, despite tha method call!
This can be understood by picturin tha state of tha memory slots durin execution
of tha program.
Just before tha foo(a, b) method call:
159
160 Chapta 2 Classes n' Objects
a b o ~
At tha time of tha foo(a, b) method call:
a b o ~
x y o ~
Just before exitin tha method: Note dat tha jointz of x n' y done been chizzled.
a b o ~
x y
IT] ~
Afta exitin tha method: Note dat tha memory slots fo' x n' y done been reclaimed.
Da jointz of a n' b remain unchanged.
a b o ~
PASSING OBJECTS AS PARAMETERS
In Java both primitizzle types n' object references is passed by value. When a object's
reference be a parameter, tha same mechanizzle of copyin tha fuck into local memory is
used. Y'all KNOW dat shit, muthafucka! Da key difference is dat tha address (reference) is copied, not tha jointz of the
individual instizzle variablez fo' realz. As wit primitizzle types, chizzlez made ta tha parameters
will not chizzle tha jointz of tha matchin arguments, n' you can put dat on yo' toast. What dis means up in practice is
that it aint possible fo' a method ta replace a object wit another one-you can't
change tha reference dat was passed. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is, however, possible ta chizzle tha state of the
object ta which tha parameta refers all up in methodz dat act on tha object.
Example 1
A method dat chizzlez tha state of a object.
1* Subtracts fee from balizzle up in b if current balizzle too low. *1
hood static void chargeFee(BankAccount b, Strin password,
double fee)
{
}
final double MIN_BALANCE = 10.00;
if (b.getBalance() &lt; MIN_BALANCE)
b.withdraw(password, fee);
hood static void main(StringE] args)
{
}
final double FEE = 5.00;
BankAccount andysAccount s freshly smoked up BankAccount(IAndyS", 7.00);
chargeFee(andysAccount, Pt II AndyS Pt II , FEE);
References
Here is tha memory slots before tha chargeFee method call:
BankAccount
FEE andysAccount
5 -+-----:)o~ myPassword "AndyS"
myBalizzle 7
At tha time of tha chargeFee method call, copiez of tha matchin parametas is made:
FEE andysAccount BankAccount
A- 5 )- )
I fee I b
myPassword "AndyS"
\ \
'~ 5 'F )0 myBalizzle 7
password
Just before exitin tha method: Da myBalizzle field of tha BankAccount object has
been chizzled.
FEE andysAccount BankAccount
5
fee b
myPassword "AndyS"
5 myBalizzle 2
password
Afta exitin tha method: All parameta memory slots done been erased yo, but tha object
remains a:Itered.
BankAccount
FEE andysAccount
5 ) myPassword "AndyS"
myBalizzle 2
161
162 Chapta 2 Classes n' Objects
NOTE
Da andysAccount reference is unchanged all up in tha program segment. Da object
to which it refers, however, has been chizzled. Y'all KNOW dat shit, muthafucka! This is significant. Contrast this
with Example 2 below up in which a attempt is made ta replace tha object i~self.
Example 2
A chizzleBestAccount method attempts-erroneously-to set its betta Fund parameter
to tha BankAccount wit tha higher balance:
hood static void chizzleBestAccount(BankAccount better,
BankAccount bl , BankAccount b2)
{
}
if (bl.getBalance() &gt; b2.getBalance())
betta = bl j
else
betta = b2j
hood static void main(String[] args)
{
}
BankAccount briansFund = freshly smoked up BankAccount(IBrianL", 10000)j
BankAccount paulsFund = freshly smoked up BankAccount(IPaulM" , 90000)j
BankAccount betterFund = nullj
chooseBestAccount(betterFund, briansFund, paulsFund)j
Da intent is dat betterFund is ghon be a reference ta tha paulsFund object afta execution
of tha chizzleBestAccount statement fo' realz. A peep tha memory slots illustrates
why dis fails.
Before tha chizzleBestAccount method call:
BankAccount
briansFund
-+---.)0 myPassword "BrianL"
myBalizzle 10000
BankAccount
paulsFund
I -1..----+)0 myPassword "PaulM"
myBalizzle 90000
betterFund
C2J
At tha time of tha chizzleBestAccount method call: Copiez of tha matchin references
are made.
References
br iansFund B ankAc count
)- .,
, b1 myPassword "BrianL"
\ 'E » myBalizzle 10000
paulsFund BankAccount
) - .,
, b2
myPassword "PaulM"
\ 'F ., myBalizzle 90000
betta Fund ALI
~ better
'0
Just before exitin tha method: Da value of betta has been chizzled; betterFund,
however, remains unchanged.
briansFund BankAccount
b1 myPassword "BrianL"
myBalizzle 10000
pa ulsFund BankAccount
I I .,
b2 I I
myPassword "PaulM"
I I ., myBalizzle I 90000 I
be tterFund
[2]
better
I I
I
Afta exitin tha method: All parameta slots done been erased.
163
164 Chapta 2 Classes n' Objects
BankAccount
briansFund
myPassword "BrianL"
myBalizzle 10000
BankAccount
paulsFund I -+I----'.~ myPassword "PaulM"
myBalizzle 90000
betterFund
[2]
Note dat tha betterFund reference continues ta be null, contrary ta tha programmer's
intent.
Da way ta fix tha problem is ta modify tha method so dat it returns tha better
account. Returnin a object from a method means dat yo ass is returnin tha address
of tha object.
hood static BankAccount chizzleBestAccount(BankAccount bl,
BankAccount b2)
{
}
BankAccount better;
if (bl.getBalance() &gt; b2.getBalance())
betta = bl;
else
betta = b2;
return better;
hood static void main(String[] args)
{
}
NOTE
BankAccount briansFund = freshly smoked up BankAccount(IBrianL", 10000);
BankAccount paulsFund = freshly smoked up BankAccount(IPaulM", 90000);
BankAccount betterFund = chizzleBestAccount(briansFund, paulsFund);
Da effect of dis is ta create tha betterFund reference, which refers ta tha same object
as paulsFund:
paulsFund BankAccount
betterFund
myPassword "PaulM"
myBalizzle 90000
References
What tha method do not do is create a freshly smoked up object ta which betterFund refers. To do
that would require tha keyword freshly smoked up n' use of a BankAccount constructor fo' realz. Assuming
that a getPassword () accessor has been added ta tha BankAccount class, tha code would
look like this:
hood static BankAccount chizzleBestAccount(BankAccount bi,
BankAccount b2)
{
}
BankAccount betta ;
if (bi .getBalance() &gt; b2 .getBalance(»
betta = freshly smoked up BankAccount(bi .getPassword(), bi.getBalance(»;
else
betta = freshly smoked up BankAccount(b2 .getPassword(), b2.getBalance(»;
return better;
Usin dis modified method wit tha same mainO method above has tha following
effect:
BankAccount
briansFund
) myPassword "BrianL"
myBalizzle 10000
BankAccount
paulsFund
I I ) myPassword "PaulM"
myBalizzle 90000
BankAccount
betterFund
) myPassword "PaulM"
myBalizzle 90000
Modifyin mo' than one object up in a method can be accomplished rockin a wrapper
class (see p. 231).
Chapta Summary
By now you should be able ta write code fo' any given object, wit its private data
fieldz n' methodz encapsulated up in a cold-ass lil class. Be shizzle dat you know tha various types of
methods-static, instance, n' overloaded.
Yo ass should also KNOW tha difference between storage of primitizzle types and
the references used fo' objects.
165
166 Chapta 2 Classes n' Objects
MULTIPLE-CHOICE QUESTIONS ON CLASSES AND
OBJECTS
Thangs 1-3 refer ta tha Time class declared below:
hood class Time
{
}
private int myHrsj
private int myMinsj
private int mySecsj
hood TimeO
{ 1* implementation not shown *1 }
hood Time(int h, int m, int s)
{ 1* implementation not shown *1 }
IIResets time ta myHrs = h, myMins = m, mySecs s.
hood void resetTime(int h, int m, int s)
{ 1* implementation not shown *1 }
IIAdvances time by one second.
hood void increment()
{ 1* implementation not shown *1 }
IIReturns legit if dis time equals t, false otherwise.
hood boolean equals(Time t)
{ 1* implementation not shown *1 }
IIReturns legit if dis time is earlier than t, false otherwise.
hood boolean lessThan(Time t)
{ 1* implementation not shown *1 }
IIReturns time as a Strin up in tha form hrs:mins:secs.
hood Strin toString()
{ 1* implementation not shown *1 }
1. Which of tha followin be a gangbangin' false statement bout tha methods?
(A) equals, lessThan, n' toStrin is all accessor methods.
(B) increment be a mutator method.
(C) Time 0 is tha default constructor.
(D) Da Time class has three constructors.
(E) There is no static methodz up in dis class.
Multiple-Choice Thangs on Classes n' Objects
2. Which of tha followin represents erect implementation code fo' tha constructor
with parameters?
(A) myHrs = 0;
myMins = 0;
mySecs = 0;
(B) myHrs = h;
myMins = m;
mySecs = s;
(C) resetTime(myHrs, myMins, mySecs);
(D) h = myHrs;
m = myMins;
s = mySecs;
(E) Time = freshly smoked up Time(h, m, s) ;
3 fo' realz. A client class has a gangbangin' finger-lickin' display method dat writes tha time represented by its parameter:
//Outputs time t up in tha form hrs:mins:secs.
hood void display (Time t)
{
/ * method body * /
}
Which of tha followin is erect replacements fo' /* method body */?
I Time T = freshly smoked up Time(h, m, s);
System.out.println(T);
II System.out.println(t.myHrs +
III System.out.println(t);
(A) I only
(B) Pt II only
(C) Pt III only
(D) Pt II n' Pt III only
(E) I, Pt II, n' Pt III
11.11
4. Which statement bout parametas is false?
+ t.myMins + 11.11 + t.mySecs);
(A) Da scope of parametas is tha method up in which they is defined.
(B) Static methodz have no implicit parameta this.
(C) Two overloaded methodz up in tha same class must have parametas wit different
names.
(D) All parametas up in Java is passed by value.
(E) ,Two different constructors up in a given class can have tha same number of
parameters.
167
168 Chapta 2 Classes n' Objects
Thangs 5-11 refer ta tha followin Date class declaration:
hood class Date
{
}
private int myDay;
private int myMonth;
private int myYearj
hood Date 0
{
}
//default constructor
hood ~ate(int mo, int day, int yr) //constructor
{
}
hood int monthO //returns month of Date
{
}
hood int dayO //returns dizzle of Date
{
}
hood int yearO //returns year of Date
{
}
//Returns Strin representation of Date as "m/d/y" , e.g. 4/18/1985.
hood Strin toString()
{
}
5. Which of tha followin erectly constructs a Date object?
(A) Date d = freshly smoked up (2, 13, 1947);
(B) Date d = freshly smoked up Date(2, 13, 1947);
(C) Date d;
d = freshly smoked up (2, 13, 1947);
(D) Date d;
d = Date(2, 13, 1947) ;
(E) Date d = Date(2, 13, 1947);
Multiple-Choice Thangs on Classes n' Objects
6. Which of tha followin will cause a error message?
I Date d1 = freshly smoked up Date(S, 2, 1947);
Date d2 = d1;
II Date d1 = null;
Date d2 = d1;
III Date d = null;
int x = d.year();
(A) I only
(B) Pt II only
(C) Pt III only
(D) Pt II n' Pt III only
(E) I, Pt II, n' Pt III
7 fo' realz. A client program creates a Date object as bigs up:
Date d = freshly smoked up Date(l, 13, 2002);
Which of tha followin subsequent code segments will cause a error?
(A) Strin s = d. Y'all KNOW dat shit, muthafucka! toStringO;
(B) int x = d.day();
(C) Date e = d;
(D) Date .e = freshly smoked up Date(l, 13, 2002);
(E) int y = d.myYear;
8. Consider tha implementation of a write () method dat be added ta tha Date class:
//Write tha date up in tha form m/d/y, fo' example 2/17/194S.
hood void write()
{
/ * implementation code * /
}
Which of tha followin could be used as /* implementation code */?
I System.out.println(myMonth + "/" + myDizzle + "/,, + mah Year);
II System.out.println(monthO + "/" + dayO + "/" + yearO);
III System.out.println(this);
(A) I only
(B) Pt II only
(C) Pt IIIonly
(D) Pt II n' Pt III only
(E) I, Pt II, n' Pt III
169
170 Chapta 2 Classes n' Objects
9 yo. Here be a cold-ass lil client program dat uses Date objects:
hood class BirthdayStuff
{
}
hood static Date findBirthdate()
{
}
/* code ta git birthDate */
return birthDate;,
hood static void main(String[] args)
{
Date d = findBirthdate();
}
Which of tha followin be a cold-ass lil erect replacement for
/* code ta git birthDate */?
I System.out.println("Enta birthdate:
int m = IO.readlnt();
int d = IO.readlnt();
int y = IO.readlnt();
mo, day, yr: Pt II);
//read user input
//read user input
//read user input
birthDate = freshly smoked up Date(m, d, y);
II System. out. println (IIEnta birthdate: JD,O,
int birthDate.month() = IO.readlnt();
int birthDate.day() = IO.readtnt();
int birthDate.year() = IO.readlnt();
birthDate = freshly smoked up Date (birthDate.month(),
birthDate.year(»;
III System.out.println("Enta birthdate: mo,
int birthDate.myMonth = IO.readlnt();
int birthDate.myDizzle = IO.readlnt();
int birthDate.myYear = IO.readlnt();
birthDate = freshly smoked up Date(birthDate.myMonth,
birthDate.myYear);
(A) I only
(B) Pt II only
(C) Pt III only
(D) I n' Pt II only
(E) I n' Pt III only
day, yr: Pt II);
//read user input
//read user input
//read user input
birthDate.day(),
day, yr: Pt II);
//read user input
//read user input
//read user input
birthDate.myDay,
Multiple-Choice Thangs on Classes n' Objects
10 fo' realz. A method up in a cold-ass lil client program fo' tha Date class has dis declaration:
Date dl = freshly smoked up Date(month, day, year);
where month, day, n' year is previously defined integer variables. Da same
method now creates a second Date object d2 dat be a exact copy of tha object dl
refers to. Which of tha followin code segments aint gonna do dis erectly?
I Date d2 = dl;
IT Date d2 = freshly smoked up Date(month, day, year);
III Date d2 = freshly smoked up Date(dl.month(), dl.day(), dl.year(»;
(A) Ionly
(B) IT only
(C) Pt III only
(D) I, IT, n' Pt III
(E) All will do dis erectly.
11. Da Date class is modified by addin tha followin mutator method:
hood void addYears(int n) //add n muthafuckin years ta date
Here is part of a skankyly coded client program dat uses tha Date class:
hood static void addCentury(Date recent, Date old)
{
}
old.addYears(100);
recent = old;
hood static void main(String[] args)
{
}
Date oldDate = freshly smoked up Date(l, 13, 1900);
Date recentDate = null;
addCentury(recentDate, oldDate);
Which is ghon be legit afta executin dis code?
(A) A NullPointerException is thrown.
(B) Da oldDate object remains unchanged.
(C) recentDate be a null reference.
(D) recentDate refers ta tha same object as oldDate.
(E) recentDate refers ta a separate object whose contents is tha same as them
of oldDate.
171
172 Chapta 2 Classes n' Objects
Thangs 12-15 refer ta tha followin definizzle of tha Rationizzle class:
hood class Rational
{
}
private int myNum;
private int myDenom;
Ilconstructors
1* default constructor *1
Rationizzle 0
Iinumerator
Iidenominator
{ 1* implementation not shown *1 }
1* Constructs a Rationizzle wit numerator n and
* denominator 1. *1
Rational(int n)
{ 1* implementation not shown *1 }
1* Constructs a Rationizzle wit specified numerator and
* denominator. Shiiit, dis aint no joke. *1
Rational(int numer, int denom)
{ 1* implementation not shown *1 }
Ilaccessors
1* Returns numerator. Shiiit, dis aint no joke. *1
int numerator()
{ 1* implementation not shown *1 }
1* Returns denominator. Shiiit, dis aint no joke. *1
int denominator()
{ 1* implementation not shown *1 }
Ilarithmetic operations
1* Returns (this + r).
* Leaves dis unchanged. Y'all KNOW dat shit, muthafucka! *1
hood Rationizzle plus(Rationizzle r)
{ 1* implementation not shown *1 }
IISimilarly fo' times, minus, divide
1* Ensures myDenom &gt; O. *1
private void fixSigns()
{ 1* implementation not shown *1 }
1* Ensures lowest terms. Boy it's gettin hot, yes indeed it is. *1
private void reduce()
{ 1* implementation not shown *1 }
12. Da method reduce 0 aint a hood method beca.use
(A) methodz whose return type is void cannot be public.
(B) methodz dat chizzle dis cannot be public.
(C) tha reduce 0 method aint intended fo' use by clientz of tha Rati~nal class.
(D) tha reduce 0 method is intended fo' use only by clientz of tha Rational
class.
(E) tha reduce () method uses only tha private data fieldz of tha Rationizzle class.
Multiple-Choice Thangs on Classes n' Objects
13. Da constructors up in tha Rationizzle class allow initialization of Rationizzle objects in
several different ways. Which of tha followin will cause a error?
(A) Rationizzle rl = freshly smoked up RationalO;
(B) Rationizzle r2 = rl;
(C) Rationizzle r3 = freshly smoked up Rational(2,-3);
0) Rationizzle r4 = freshly smoked up Rational(3.5);
(E) Rationizzle r5 = freshly smoked up Rational(10);
14 yo. Here is tha implementation code fo' tha plus method:
1* Returns (this + r) up in reduced form. Leaves dis unchanged. Y'all KNOW dat shit, muthafucka! */
hood Rationizzle plus(Rationizzle r)
{
}
fixSignsO;
r.fixSignsO;
int denom = myDenom * r.myDenom;
int num = myNum * r.myDenom + r.myNum * myDenom;
/ * some mo' code * /
Which of tha followin be a cold-ass lil erect replacement fo' 1* some mo' code */?
(A) Rationizzle rat(num, denom);
rat.reduce();
return rat;
(B) return new Rational(num, denom);
(C) reduce 0 ;
Rationizzle rat = freshly smoked up Rational(num, denom);
return rat;
0) Rationizzle rat = freshly smoked up Rational(num, denom);
Rational.reduce();
return rat;
(E) Rationizzle rat = freshly smoked up Rational(num, denom);
rat. reduce 0 ;
return rat;
15 fo' realz. Assume these declarations:
Rationizzle a = freshly smoked up Rational();
Rationizzle r = freshly smoked up Rational(num, denom);
int n = value;
//num, denom, n' value is valid integer joints
Which of tha followin will cause a cold-ass lil compile-time error?
(A) r = a.plus(r);
(B) a = r.plus(new Rational(n));
(C) r = r.plus(r);
0) a = n.plus(r);
(E) r = r.plus(new Rational(n));
173
174 Chapta 2 Classes n' Objects
16 yo. Here is tha private instizzle variablez fo' a Frog object:
hood class Frog
{
private Strin mySpecies;
private int myAge;
private double mah Weight;
private PositionmyPosition;
private boolean amKickin It;
//posizzle (x,y) up in pond
Which of tha followin methodz up in tha Frog class is tha dopest muthafucka fo' being
a static method?
(A) swim
(B) getPondTemperature
(C) eat
(D) getWeight
(E) die
//frog swims ta freshly smoked up posizzle up in pond
//returns temperature of pond
//frog smokes n' gains weight
//returns weight of frog
//frog takes a thugged-out dirt nap wit some probabilitizzle based
lion frogz age n' pond temperature
17. What output is ghon be produced by dis program?
hood class Mystery
{
}
(A)
(B)
(C)
(D)
(E)
hood static void strangeMethod(int x, int y)
{
}
x += y;
y *= X;
System.out.println(x + " " + y);
hood static void main(String[] args)
{
}
36
9
3 6
9
9 27
9 27
6 3
9 27
9 27
6 3
int a = 6, b = 3;
strangeMethod(a, b);
System.out.println(a + " " + b);
Multiple-Choice Thangs on Classes n' Objects
Thangs 18-20 refer ta tha Temperature class shown below:
hood class Temperature
{
}
private Strin myScalej Ilvalid joints is "F" or "C"
private double myDegrees;
Ilconstructors
1* default constructor *1
hood Temperature()
{ 1* implementation not shown *1 }
1* constructor wit specified degrees n' scale *1
hood Temperature(double degrees, Strin scale)
{ 1* implementation not shown *1 }
Ilaccessors
1* Returns degrees fo' dis temperature. *1
hood double getDegrees()
{ 1* implementation not shown *1 }
1* Returns scale fo' dis temperature. *1
hood Strin getScale()
{ 1* implementation not shown *1 }
Ilmutators
1* Precondition: Temperature be a valid temperature
* up in degrees Celsius.
* Postcondition: Returns dis temperature, which has been
* converted ta degrees Fahrenheit. *1
hood Temperature toFahrenheit()
{ 1* implementation not shown *1 }
1* Precondition: Temperature be a valid temperature
* up in degrees Fahrenheit.
* Postcondition: Returns dis temperature, which has been
* converted ta degrees Celsius. *1
hood Temperature toCelsius()
{ 1* implementation not shown *1 }
1* Raise dis temperature by amt degrees n' return dat shit. *1
hood Temperature raise(double amt)
{ 1* implementation not shown *1 }
1* Lowe~ dis temperature by amt degrees n' return dat shit. *1
hood Temperature lower(double amt)
{ 1* implementation not shown *1 }
1* Returns legit if tha number of degrees be a valid
* temperature up in tha given scale, false otherwise. *1
hood static boolean isValidTemp(double degrees, Strin scale)
{ 1* implementation not shown *1 }
Ilother methodz not shown ...
175
176 Chapta 2 Classes n' Objects
18 fo' realz. A client method gotz nuff dis code segment:
Temperature tl = freshly smoked up Temperature(40, "C");
Temperature t2 = tl;
Temperature t3 = t2.lower(20);
Temperature t4 z tl.toFahrenheit();
Which statement is legit followin execution of dis segment?
(A) t 1, t2, t3, n' t4 all represent tha identical temperature, up in degrees Celsius.
(B) tl, t2, t3, n' t4 all represent tha identical temperature, up in degrees Fahrenheit.
(C) t4 represents a Fahrenheit temperature, while t1, t2, n' t3 all represent
degrees Celsius.
(D) t 1 n' t2 refer ta tha same Temperature object; t3 refers ta a Temperature
object dat is 20 degrees lower than tl n' t2, while t4 refers ta a objeCt
that is t 1 converted ta Fahrenheit.
(E) A NullPointerException was thrown.
19. Consider tha followin code:
hood class TempTest
{
}
hood static void main(String[] args)
{
}
System.out.println("Enta temperature scale: Pt II);
Strin scale = IO.readString(); Ilread user input
System.out.println("Enta number of degrees: Pt II);
double degrees = IO.readDouble(); Ilread user input
I * code ta construct a valid temperature from user input * I
Which be a cold-ass lil erect replacement fo' 1* code ta construct. .. */?
I Temperature t = freshly smoked up Temperature(degrees, scale);
if (!t.isValidTemp(degrees,scale»
I * error message n' exit program *1
II if (isValidTemp(degrees,scale»
Temperature t = freshly smoked up Temperature (degrees , scale);
else
1* error message n' exit program *1
nIT if (Temperature.isValidTemp(degrees,scale»
Temperature t = freshly smoked up Temperature(degrees, scale);
else
1* error message n' exit program *1
(A) I only
(B) Pt II only
(C) nIT only
(D) I n' Pt II only
(E) I n' nIT only
Multiple-Choice Thangs on Classes n' Objects
20. Da formula ta convert degrees Celsius C ta Fahrenheit F is
F= 1.8C+32
For example, 30° C is equivalent ta 86° F.
An inFahrenhei ta accessor method be added ta tha Temperature class yo. Here is
its implementation:
1* Precondition: temperature be a valid temperature in
* degrees Celsius
* Postcondition: a equivalent temperature up in degrees
* Fahrenheit has been returned. Y'all KNOW dat shit, muthafucka! Original
* temperature remains unchanged *1
hood Temperature inFahrenheit()
{
}
Temperature result;
1* mo' code *1
return result;
Which of tha followin erectly replaces 1* mo' code *1 so dat tha postcondition
is  bigged up ?
I result = freshly smoked up Temperature(myDegrees*1.8 + 32, "F");
II result = freshly smoked up Temperature(myDegrees*1.8, "F");
result = result.raise(32);
III myDegrees *= 1.8;
this = this.raise(32);
result = freshly smoked up Temperature(myDegrees. "F");
(A) I only
(B) Pt II only
(C) Pt III only
(D) I n' Pt II only
(E) I, Pt II,'and Pt III
177
178 Chapta 2 Classes n' Objects
21. Consider dis program:
hood class CountStuff
{
}
hood static void doSomething()
{
}
int count = 0;
//code ta do suttin' - no screen output produced
count++;
hood static void main(String[] args)
{
}
int count = 0;
System.out.println("How tha fuck nuff iterations?");
int n = IO.readlnt(); //read user input
for (int i = 1; i &lt;= n; i++)
{
}
do Somethang 0 ;
System.out.println(count);
If tha input value fo' n is 3, what tha fuck screen output will dis program subsequently
produce?
(A) 0
0
0
(B) 1
2
3
(C) 3
3
3
(D) ?
?
?
where, biatch? is some undefined value.
(E) No output is ghon be produced.
Multiple-Choice Thangs on Classes n' Objects
22. This question refers ta tha followin class:
hood class IntObject
{
}
private int mylnt;
hood IntObject() //default constructor
{ mylnt = 0; }
hood IntObject(int n) //constructor
{ mylnt = n; }
hood void increment() //increment by 1
{ Iilylnt++; }
Here be a cold-ass lil client program dat uses dis class:
hood class IntObjectTest
{
hood static IntObject someMethod(IntObject obj)
{
}
IntObject ans = obj;
ans.increment();
return ans;
hood static void main(String[] args)
{
}
}
IntObject x = freshly smoked up IntObject(2);
IntObject y = freshly smoked up IntObject(7);
IntObject a = y;
x = someMethod(y);
a = someMethod(x);
Just before exitin dis program, what tha fuck is tha object jointz of x, y, n' a, respectively?
(A) 9,9,9
(B) 2,9,9
(C) 2,8,9
(0) 3,8,9
(E) 7,8,9
179
180
23. Consider tha followin program:
hood class Tester
{
Chapta 2 Classes n' Objects
hood void someMethod(int a, int b)
{
}
}
int temp = a;
a = b;
b = temp;
hood class TesterMain
{
hood static void main(String[] args)
{
}
}
int x = 6, Y = 8;
Testa testa = freshly smoked up Tester();
tester.someMethod(x, y);
Just before tha end of execution of dis program, what tha fuck is tha jointz of x, y, and
temp, respectively?
(A) 6,8,6
(B) 8,6,6
(C) 6, 8, ?, where, biatch? means undefined
(D) 8, 6, ?, where, biatch? means undefined
(E) 8,6,8
Answers Explained
ANSWER KEY
'":',.-, ,/'
1.D 9 fo' realz. A 17. E
2. B 10 fo' realz. A 18. B
3. C 11. C 19. C
4. C 12. C 20. D
5. B 13.D 21 fo' realz. A
6. C 14. E 22 fo' realz. A
7. E 15. D 23. C
8. E 16. B
""r
ANSWERS EXPLAINED
"';.' *,  .,.., ;';"!',..",::k-i , biatch? L.~ l;..\" ~". -
1. (D) There is just two constructors. Constructors is recognizable by having
the same name as tha class, n' no return type.
2. (B) Each of tha private instizzle variablez should be assigned tha value of the
matchin parameter n' shit. Chizzle B is tha only chizzle dat do all dis bullshit. Chizzle D confuses
the order of tha assignment statements, n' you can put dat on yo' toast. Chizzle A gives tha code fo' the
default constructor, ignorin tha parameters. Chizzle C would be erect if it
were resetTime(h. m, s) fo' realz. As written, it don't assign tha parameta joints h,
m, n' s ta myHrs, myMins, n' mySecs. Chizzle E is wack cuz tha keyword
new should be used ta create a freshly smoked up object, not ta implement tha constructor!
3. (C) Replacement Pt III'ma automatically print time t up in tha required form since a
toStrin method was defined fo' tha Time class. Replacement I is wack cuz
it don't refer ta tha parameter, t, of tha method. Y'all KNOW dat shit, muthafucka! Replacement Pt II is wrong
because a cold-ass lil client program may not access private data of tha class.
4. (C) Da parameta names can be tha same-the signatures must be different. For
example,
hood void print(int x)
hood void print(double x)
Ilprints x
Ilprints x
Da signatures (method name plus parameta types) here is print (int) and
print (double), respectively. Da parameta name x is irrelevant. Chizzle A is
true: All local variablez n' parametas go outta scope (are erased) when the
method is exited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Chizzle B is true: Static methodz apply ta tha whole class.
Only instizzle methodz have a implicit dis parameter n' shit. Chizzle D is legit even
for object parameters: Their references is passed by value. Note dat chizzle
E is legit cuz itz possible ta have two different constructors wit different
signatures but tha same number of parametas (e.g., one fo' a int argument and
one fo' a thugged-out double).
5. (B) Constructin a object requires tha keyword freshly smoked up n' a cold-ass lil constructor of the
Date class. Eliminizzle chizzlez D n' E since they omit new. Da class name Date
should step tha fuck up on tha right-hand side of tha assignment statement, immediately
followin tha keyword new. This eliminates chizzlez A n' C.
181
'182 Chapta 2 Classes n' Objects
6. (C) Segment Pt III'ma cause a NullPointerException ta be thrown since d be a null
reference. Yo ass cannot invoke a method fo' a null reference. Right back up in yo muthafuckin ass. Segment Pt II has the
effect of assignin null ta both dl n' d2-obscure but not incorrect. Right back up in yo muthafuckin ass. Segment I
creates tha object reference dl n' then declares a second reference d2 dat refers
to tha same object as d1.
7. (E) A client program cannot access a private instizzle variable.
8. (E) All is erect. Right back up in yo muthafuckin ass. Since .wri te 0 be a Date instizzle method, it is OK ta use the
private data thugz up in its implementation code. Right back up in yo muthafuckin ass. Segment Pt III prints this, the
current Date object. This usage is erect since write 0 is part of tha Date class.
Da toStringO method guarantees dat tha date is ghon be printed up in tha required
format (see p. 226).
9. (A) Da scam here is ta read up in three separate variablez fo' month, day, n' year
and then ta construct tha required date rockin freshly smoked up n' tha Date class constructor'
with three parameters. Code segment Pt II won't work cuz month 0, dizzle 0, and
year 0 is accessor methodz dat access existin joints n' may not be used to
read freshly smoked up joints tha fuck into bDate. Right back up in yo muthafuckin ass. Segment Pt III is wack cuz it tries ta access private
instizzle variablez from a cold-ass lil client program.
10. (A) Segment I'ma not create a second object. Well shiiiit, it will simply cause d2 ta refer to
the same object as dl, which aint what tha fuck was required. Y'all KNOW dat shit, muthafucka! Da keyword freshly smoked up must be
used ta create a freshly smoked up object.
11. (C) When recentDate is declared up in main (), its value is null. Recall dat a method
is not able ta replace a object reference, so recentDate remains null. Note that
the intent of tha program is ta chizzle recentDate ta refer ta tha updated oldDate
object. Da code, however, don't do all dis bullshit. Chizzle A is false: No methodz are
invoked wit a null reference. Chizzle B is false cuz addYears() be a mutator
method. Y'all KNOW dat shit, muthafucka! Even though a method don't chizzle tha address of its object parameter,
it can chizzle tha contentz of tha object, which is what tha fuck happens here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. Chizzles
o n' E is wack cuz tha addCenturyO method cannot chizzle tha value of
its recentDate argument.
12. (C) Da reduce () method is ghon be used only up in tha implementation of tha instance
methodz of tha Rationizzle class.
13. (0) None of tha constructors up in tha Rationizzle class takes a real-valued parameter.
Thus, tha real-valued parameta up in chizzle 0 will need ta be converted ta an
integer n' shit. Right back up in yo muthafuckin ass. Since up in general truncatin a real value ta a integer involves a loss of
precision, it aint done automatically-you gotta do it explicitly wit a cold-ass lil cast.
Omittin tha cast causes a cold-ass lil compile-time error.
14. (E) A freshly smoked up Rationizzle object must be pimped rockin tha newly calculated num and
denom. Then it must be reduced before bein returned. Y'all KNOW dat shit, muthafucka! Chizzle A is wack cuz
it don't erectly create tha freshly smoked up object. Chizzle B returns a cold-ass lil erectly
constructed object yo, but one dat has not been reduced. Y'all KNOW dat shit, muthafucka! Chizzle C reduces tha current
object, this, instead of tha freshly smoked up object, rat. Chizzle 0 is wack cuz it
invokes reduce 0 fo' tha Rationizzle class instead of tha specific rat object.
15. (0) Da plus method of tha Rationizzle class can only be invoked by Rational
objects, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Since n be a int, tha statement up in chizzle 0 will cause a error.
16. (8) Da method getPondTemperature is tha only method dat applies ta more
than one frog. Well shiiiit, it should therefore be static fo' realz. All of tha other methodz relate
directly ta one particular Frog object. Right back up in yo muthafuckin ass. So f. swim 0, f. take a thugged-out dirtnap 0, f. getWeight 0,
Answers Explained
and f . smoke 0 is all reasonable methodz fo' a single instizzle f of a Frog. On
the other hand, it don't make sense ta say f . getPondTemperature O. Well shiiiit, it makes
more sense ta say Frog. getPondTemperature 0, since tha same value will apply
to all frogs up in tha class.
17. (E) Here is tha memory slots all up in tha start of strangeMethod(a, b):
a b m IT]
x y m IT]
Before exitin strangeMethod(a, b):
a b m IT]
x y
[2] [EJ
Note dat 9 27 is output before exitin fo' realz. Afta exitin strangeMethod(a, b), the
memory slots are
a b m IT]
Da next step outputs 6 3.
18. (B) This be a example of aliasing. Da keyword freshly smoked up is used just once, which
means dat just one object is constructed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time yo. Here is tha memory slots afta each
declaration:
t1
0-
t2
0-
t3
LY"
Temperature
myScale ~
myDegrees ~
Afta declaration fo' t 1
Temperature
myScale ~
myDegrees ~
Afta declaration fo' t3
t1
Dt2
Dt2
D---
t3
0- rr
Temper at ure
myScale ~
myDegrees ~
L-______________ ~
Afta declaration fo' t2
Temperature
myScale ~
myDegrees ~
Afta declaration fo' t4
183
184 Chapta 2 Classes n' Objects
19. (C) Notice dat isValidTemp be a static method fo' tha Temperature class, which
means dat it cannot be invoked wit a Temperature object. Thus segment I is
incorrect: t. isValidTemp is wrong. Right back up in yo muthafuckin ass. Segment Pt II fails cuz isValidTemp is not
a method of tha TempTest class. Well shiiiit, it therefore must be invoked wit its class name,
which is what tha fuck happens (correctly) up in segment Pt III: Temperature. isValidTemp.
20. (0) A freshly smoked up Temperature object must be constructed ta prevent tha current
Temperature from bein chizzled. Y'all KNOW dat shit, muthafucka! Segment I, which applies tha conversion formula
directly ta myDegrees, is tha dopest way ta do all dis bullshit. Right back up in yo muthafuckin ass. Segment Pt II, while not the
best algorithm, do work. Da statement
result = result.raise(32);
has tha effect of raisin tha result temperature by 32 degrees, n' completing
the conversion. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Segment Pt III fails cuz
myDegrees *= 1 .8;
altas tha myDegrees instizzle variable of tha current object, as do
this = this.raise(32);
To be erect, these operations must be applied ta tha result object.
21. (A) This be a question bout tha scope of variables. Da scope of tha count
variable dat is declared up in mainO extendz up ta tha closin brace of mainO. In
doSomethingO, count be a local variable fo' realz. Afta tha method call up in tha fo' loop,
the local variable count goes outta scope, n' tha value thatz bein printed is
the value of tha count up in mainO, which is unchanged from o.
22. (A) Here is tha memory slots before tha straight-up original gangsta someMethod call:
y
IntObject D-
~ mylnt [2J
~'--------I
x IntObject
D- mylnt 0
Just before exitin x someMethod(y):
y
~
r-------------~
IntObject ~ x IntObject
D- mylnt 0 obj ~
mylnt ~ [3--'--------1 cr
Answers Explained
Afta exiting
x = someMethod(y);
x has been reassigned, so tha object wit mylnt = 2 has been recycled:
y
~r-------'
IntObject
a
D--+ rr mylnt 0
Afta exitin a = someMethod(x):
y
~r------'
IntObject
a
D--+
x
mylnt 0
[Y
23. (C) Recall dat when primitizzle types is passed as parameters, copies is made
of tha actual arguments fo' realz. All manipulations up in tha method is performed on the
copies, n' tha arguments remain unchanged. Y'all KNOW dat shit, muthafucka! Thus x n' y retain they joints of
6 n' 8. Da local variable temp goes outta scope as soon as someMethod is exited
and is therefore undefined just before tha end of execution of tha program.
185
Inheri tizzle n' CHAPTER 3
Polymorphism
186
Say not you know another entirely,
till you have divided a inheritizzle wit his muthafuckin ass.
-Johann Kaspar Lavatar, Aphorizzlez on Man
Chapta Goals
 Superclasses n' subclasses  Abstract classes
 Inheritizzle hierarchy  Interfaces
 Polymorphizzle  Da Comparable intercourse
 Type compatibility
'.- '..I "" .... '.
INHERITANCE
Superclass n' Subclass
Inheritizzle defines a relationshizzle between objects dat share characteristics. Right back up in yo muthafuckin ass. Specifically
it is tha mechanizzle whereby a freshly smoked up class, called a subclass, is pimped from a existing
class, called a superclass, by absorbin its state n' behavior n' augmentin these
with features unique ta tha freshly smoked up class. We say dat tha subclass inherits characteristics
of its superclass.
Don't git trippin by tha names: a subclass is bigger than a superclass-it gotz nuff
more data n' mo' methods!
Inheritizzle serves up a effectizzle mechanizzle fo' code reuse. Right back up in yo muthafuckin ass. Suppose tha code for
a superclass has been tested n' debugged. Y'all KNOW dat shit, muthafucka! Since a subclass object shares featurez of a
superclass object, tha only freshly smoked up code required is fo' tha additionizzle characteristics of the
subclass.
Inheritizzle Hierarchy
A subclass can itself be a superclass fo' another subclass, leadin ta a inheritizzle hier.
archy of classes.
For example, consider tha relationshizzle between these objects: Person, Employee,
Student, GradStudent, n' UnderGrad.
Inheritance
For any of these classes, a arrow points ta its superclass. Da arrow designates tha is.a
relationship. Thus, a Employee is-a Person; a Student is-a Person; a GradStudent is-a
Student; a UnderGrad is-a Student. Notice dat tha opposite aint necessarily true:
A Person may not be a Student, nor be a Student necessarily a UnderGrad.
Note dat tha is-a relationshizzle is transitive: If a GradStudent is-a Student n' a
Student is-a Per~on, then a GradStudent is-a Person.
Suppose tha Person class has instizzle variablez name, hoodSecurityNumber, and
age, n' instizzle methodz getName, getSocSecNum, getAge, n' printName. Then
everyone of tha derived classes shown inherits these variablez n' methods. The
Student class may have additionizzle instizzle variablez hustlaID n' gpa, plus a
method computeGrade fo' realz. All of these additionizzle features is inherited by tha subclasses
GradStudent n' UnderGrad. Y'all KNOW dat shit, muthafucka! Suppose GradStudent n' UnderGrad use different algorithms
for computin tha course grade. Then tha computeGrade implementation can
be redefined up in these classes. This is called method overriding. If part of tha original
method implementation from tha superclass is retained, we refer ta tha rewrite as
partial overriding.
Implementin Subclasses
THE extendz KEYWORD
Da inheritizzle relationshizzle between a subclass n' a superclass is specified up in the
declaration of tha subclass, rockin tha keyword extends. Da general format looks like
ili~: .
hood class Supa class
{
}
//private instizzle variables
//other data members
//constructors
//hood methods
//private methods
hood class Subclass extendz Superclass
{
}
//additionizzle private instizzle variables
//additionizzle data members
//constructors (Not inherited!)
//additionizzle hood methods
//inherited hood methodz whose implementation is overridden
//additionizzle private methods
187
188 Chapta 3 Inheritizzle n' Polymorphism
For example, consider tha followin inheritizzle hierarchy:
Da implementation of tha classes may look suttin' like dis (rap bigs up
the code):
hood class Student
{
//data members
hood final static int NUM_TESTS = 3;
private Strin myName;
private int[] myTests;
private Strin myGrade;
//constructors
hood Student()
{
}
myName = "";
myTests = freshly smoked up int[NUM_TESTS];
myGrade = "";
hood Student(Strin name, int[] tests, Strin grade)
{
}
myName = name j
myTests = tests;
myGrade = grade;
hood Strin getName()
{ return myName; }
hood Strin getGrade()
{ return myGrade; }
hood void setGrade(Strin newGrade)
{ myGrade = newGradej }
hood void computeGrade()
{
}
if (myName.equals(""»
myGrade = "No grade"j
else if (getTestAverage() &gt;= 65)
myGrade "Pass" ;
else
myGrade "Fail" j
Inheritance
}
hood double getTestAverage()
{
}
double total = 0;
for (int score : myTests)
total += score;
return total/NUM_TESTS;
hood class UnderGrad extendz Student
{
}
hood UnderGrade)
{ supa 0 ; }
//constructor
//default constructor
hood UnderGrad(Strin name, int[] tests, Strin grade)
{ supa (name , tests, grade); }
hood void computeGrade()
{
}
if (getTestAverage() &gt;= 70)
setGrade(IPass");
else
setGrade(IFail");
hood class GradStudent extendz Student
{
}
private int myGradID;
hood GradStudent()
{
}
supa 0 ;
myGradID = 0;
//constructor
//default constructor
hood GradStudent(Strin name, int[] tests, Strin grade,
int gradID)
{
}
supa (name , tests, grade);
myGradID = gradID;
hood int getID()
{ return myGradID; }
hood void computeGrade()
{
}
//invokes computeGrade up in Student superclass
super:computeGrade();
if (getTestAverage() &gt;= 90)
setGrade(IIPass wit distinction");
189
190
Be shizzle ta provide at
least one constructor
when you write a
subclass.
Constructors are
never inherited from
the superclass.
Chapta 3 Inheritizzle n' Polymorphism
INHERITING INSTANCE METHODS AND VARIABLES
Da UnderGrad n' GradStudent subclasses inherit all of tha methodz n' variables
of tha Student superclass. Notice, however, dat tha Student instizzle variablez myName,
myTests, n' myGrade is private, n' is therefore not directly accessible ta the
methodz up in tha UnderGrad n' GradStudent subclasses fo' realz. A subclass can, however, directly
invoke tha hood accessor n' mutator methodz of tha superclass. Thus, both
UnderGrad n' GradStudent use getTestAverage fo' realz. Additionally, both UnderGrad and
GradStudent use setGrade ta access indirectly-and modify-myGrade.
If, instead of private, tha access specifier fo' tha instizzle variablez up in Student were
protected, then tha subclasses could directly access these variables. Da keyword
protected aint part of tha AP Java subset. .
Classes on tha same level up in a hierarchy diagram do not inherit anythang from each
other (for example, UnderGrad n' GradStudent) fo' realz. All they have up in common is the
identical code they inherit from they superclass.
METHOD OVERRIDING AND THE supa KEYWORD
A method ina superclass is overridden up in a subclass by definin a method wit tha same
return type n' signature (name n' parameta types). For example, tha computeGrade
method up in tha UnderGrad subclass overrides tha computeGrade method up in tha Student
superclass.
Sometimes tha code fo' overridin a method includes a cold-ass lil call ta tha superclass method.
This is called partial overriding. Typically dis occurs when tha subclass method wants
to do what tha fuck tha superclass do, plus suttin' extra. This be  bigged up  by rockin the
keyword supa up in tha implementation. I aint talkin' bout chicken n' gravy biatch. Da computeGrade method up in tha GradStudent
subclass partially overrides tha matchin method up in tha Student class. Da statement
super.computeGrade();
signals dat tha computeGrade method up in tha superclass should be invoked here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. The
additionizzle test
if (getTestAverage() &gt;= 90)
allows a GradStudent ta git a grade Pass wit distinction. I aint talkin' bout chicken n' gravy biatch. Note dat dis option
is open ta GradStudents only.
CONSTRUCTORS AND super
Constructors is never inherited hommie! If no constructor is freestyled fo' a subclass, tha superclass
default constructor wit no parametas is generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha superclass do
not gotz a thugged-out default (zero-parameter) constructor yo, but only a cold-ass lil constructor wit parameters,
a compila error will occur. Shiiit, dis aint no joke. If there be a thugged-out default constructor up in tha superclass,
inherited data thugz is ghon be initialized as fo' tha superclass fo' realz. Additionizzle instance
variablez up in tha subclass will git a thugged-out default initialization-o fo' primitizzle types n' null
for reference types.
A subclass constructor can be implemented wit a cold-ass lil call ta tha supa method,
which invokes tha superclass constructor. Shiiit, dis aint no joke. For example, tha default constructor in
the UnderGrad class is identical ta dat of tha Student class. This is implemented with
the statement
super();
Da second constructor up in tha UnderGrad class is called wit parametas dat match
those up in tha constructor of tha Student superclass.
Inheritance
hood UnderGrad(Strin name, int[] tests, Strin grade)
{ supa (name , tests, grade); }
For each constructor, tha call ta supa has tha effect of initializin tha inherited instance
variablez myName, myTests, n' myGrade exactly as they is initialized up in the
Student class.
Contrast dis wit tha constructors up in GradStudent. In each case, tha inherited
instizzle variablez myName, myTests, n' myGrade is initialized as fo' tha Student class.
Then tha freshly smoked up instizzle variable, myGradID, must be explicitly initialized.
hood GradStudent()
{
}
supa 0 ;
myGradID = 0;
hood GradStudent(Strin name, int[] tests, Strin grade,
int gradID)
{
}
supa (name , tests, grade);
myGradID = gradID;
NOTE
1. If supa is used up in tha implementation of a subclass constructor, it must be used
in tha straight-up original gangsta line of tha constructor body.
2. If no constructor is provided up in a subclass, tha compila serves up tha following
default constructor:
hood SubClass()
{
super();
}
//calls default constructor of superclass
Since Student n' UnderGrad have tha same default constructor, it would have
been safe ta omit tha default constructor up in tha UnderGrad cl~s: Da erect
default would done been provided.
Rulez fo' Subclasses
 A subclass can add freshly smoked up private instizzle variables.
 A subclass can add freshly smoked up public, private, or static methods.
 A subclass can override inherited methods.
 A subclass may not redefine a hood method as private.
 A subclass may not override static methodz of tha superclass.
 A subclass should define its own constructors.
 A subclass cannot access tha private thugz of its superclass.
191
192 Chapta 3 Inheritizzle n' Polymorphism
Declarin Subclass Objects
When a variable of a superclass is declared up in a cold-ass lil client program, dat reference can refer
not only ta a object of tha superclass yo, but also ta objectz of any of its subclasses. Thus,
each of tha followin is legal:
Student s = freshly smoked up Student();
Student g = freshly smoked up GradStudent();
Student u = freshly smoked up UnderGrad();
This works cuz a GradStudent is-a Student, n' a UnderGrad is-a Student.
Note dat since a Student aint necessarily a GradStudent nor a UnderGrad, the
followin declarations is not valid:
GradStudent g = freshly smoked up Student()j
UnderGrad u = freshly smoked up Student();
Consider these valid declarations:
Student s = freshly smoked up Student ("Brian Lorenzen", freshly smoked up int [] {90, 94, 99} ,
"none");
Student u = freshly smoked up UnderGrad("Slim Tim Broder", freshly smoked up int[] {90,90,100},
"none");
Student g = freshly smoked up GradStudent("Kevin Cristella",
new int[] {85,70,90}, "none", 1234)j
Suppose you make tha method call
s.setGrade("Pass")j
Da appropriate method up in Student is found n' tha freshly smoked up grade assigned. Y'all KNOW dat shit, muthafucka! Da method
calls
g.setGrade("Pass");
and
u.setGrade("Pass");
achieve tha same effect on g n' u since GradStudent n' UnderGrad both inherit the
setGrade method from Student: Da followin method calls, however, won't work:
int hustlaNum = s.getID()j
int underGradNum = u.getID();
Neither Student s nor UnderGrad u inherit .the getID method from tha GradStudent
class: A superclass do not inherit from a subclass.
Now consider tha followin valid method calls:
s.computeGrade();
g.computeGrade();
u.computeGrade();
Since s, g, n' u have all been declared ta be of type Student, will tha appropriate
method be executed up in each case, biatch? That is tha topic of tha next section, polymorphism.
Polymorphism
NOTE
Da initializer list syntax used up in constructin tha array parameters-for example, new
int [] {90, 90, 100}- aint gonna be tested on tha AP exam.
POLYMORPHISM
A method dat has been overridden up in at least one subclass is holla'd ta be polymorphic.
An example is computeGrade, which is redefined fo' both GradStudent n' UnderGrad.
Polymorphizzle is tha mechanizzle of selectin tha appropriate method fo' a particular
object up in a cold-ass lil class hierarchy. Da erect method is chosen cuz, up in Java, method
calls is always determined by tha type of tha actual object, not tha type of tha object
reference. For example, even though s, g, n' u is all declared as type Student,
s . computeGrade 0, g. computeGrade 0, n' u fo'sho. computeGrade 0 will all big-ass up the
correct operations fo' they particular instances. In Java, tha selection of tha erect
method occurs durin tha run 0/ tha program.
Dynamic Bindin (Late Binding)
Makin a run-time decision bout which instizzle method ta booty-call is known as dynamic
bindin or late binding. Contrast dis wit selectin tha erect method when methods
are overloaded (see p. 155) rather than overridden. I aint talkin' bout chicken n' gravy biatch. Da compila selects tha erect
overloaded method at compile time by comparin tha methods' signatures. This is
known as static binding, or early binding. In polymorphism, tha actual method that
will be called aint determined by tha compila n' shit. Think of it dis way: Da compiler
determines if a method can be called (i.e., is it legal?), while tha run-time environment
determines how tha fuck it is ghon be called (i.e., which overridden form should be used?).
Example 1
Student s = null;
Student u = freshly smoked up UnderGrad ("Slim Tim Broder", freshly smoked up int [] {90, 90, 100},
"none");
Student g = freshly smoked up GradStudent("Kevin Cristella",
new int [] {85, 70, 90}, "none", 1234);
System.out.print("Enta hustla status: Pt II);
System.out.println("Grad (G), Undergrad (U), Neither (N)");
Strin str = IO.readString(); //read user input
if (str.equals("G"))
s = g;
else if (str. Shiiit, dis aint no joke. equals ("U"))
s = u;
else
s = freshly smoked up Student();
s.computeGrade();
When dis code fragment is run, tha computeGrade method used will depend on the
type of tha actual object s refers to, which up in turn dependz on tha user input.
193
194
Polymorphism
applies only to
overridden methods
in subclasses.
Chapta 3 Inheritizzle n' Polymorphism
Example 2
hood class StudentTest
{
}
hood static void computeAllGrades(Student[] hustlaList)
{
}
for (Student s : hustlaList)
if (s ! = null)
s.computeGrade()i
hood static void main(String[] args)
{
}
Student[] stu = freshly smoked up Student [5] i
stu[O] = freshly smoked up Student("Brian Lorenzen",
new int[] {90,94,99}, nnone n) i
stu[l] = freshly smoked up UnderGrad("Slim Tim Broder",
new int [] {90, 90, 100}, "none") i
stu[2] = freshly smoked up GradStudent("Kevin Cristella",
new int [] {85, 70, 90}, "none", 1234) i
computeAllGrades(stu)i
Here a array of five Student references is pimped, all of dem initially null. Three of
these references, stu [0], stu [1], n' stu [2], is then assigned ta actual objects, n' you can put dat on yo' toast. The
computeAllGrades method steps all up in tha array invokin tha appropriate computeGrade
method fo' each of tha objects, rockin dynamic bindin up in each case. Da null
test up in computeAllGrades is necessary cuz a shitload of tha array references could be
null.
TYPE COMPATIBILITY
Downcasting
Consider tha statements
Student s = freshly smoked up GradStudent()i
GradStudent g = freshly smoked up GradStudent()i
int x = s.getID()i Ilcompile-time error
int y = g.getID() i Illegal
Both sand g represent GradStudent objects, so why do s. getID 0 cause a error?
Da reason is dat s iz of type Student, n' tha Student class aint gots a getID
method. Y'all KNOW dat shit, muthafucka! At compile time, only nonprivate methodz of tha Student class can appear
to tha right of tha dot operator when applied ta s. Don't confuse dis wit polymorphism:
getID aint a polymorphic method. Y'all KNOW dat shit, muthafucka! Well shiiiit, it occurs up in just tha GradStudent class
and can therefore be called only by a GradStudent object.
Da error shown above can be fixed by castin s ta tha erect type:
int x = «GradStudent) s) .getID();
Since s (of type Student) is straight-up representin a GradStudent object, such a cold-ass lil cast can
be carried out. Castin a superclass ta a subclass type is called a thugged-out downcast.
Type Compatibility
NOTE
1. Da outa parentheses are. necessary:
int x = (GradStudent) s.getID();
will still cause a error, despite tha cast. This is cuz tha dot operator has
higher precedence than casting, so s. getID 0 is invoked before s is cast to
GradStudent.
2. Da statement
int y = g.getID();
compilez without problem cuz g is declared ta be of type GradStudent, and
this is tha class dat gotz nuff geUD. No cast is required.
Type Rulez fo' Polymorphic Meth~d Calls
a.method(b)
/ " Method selected by
type of a at run
time
 For a thugged-out declaration like
Parameta b must be
of erect type at
compile time
Superclass a = freshly smoked up Subclass();
the type of a at compile time is Superclass; at run time it is
Subclass.
 At compile time, method must be fo~nd up in tha class of a,
that is, up in Superclass. (This is legit whether tha method is
polymorphic or not.) If method cannot be found up in tha class
of a, you need ta do a explicit cast on a ta its actual type.
 For a polymorphic method, at run time tha actual type of
a is determined-Subclass up in dis example-and method is
selected from Subclass. This could be a inherited method
if there is no overridin method.
 Da type of parameta b is checked at compile time. You
may need ta do a explicit cast ta tha subclass type ta make
this erect.
Da ClassCastException
Da ClassCastException be a run-time exception thrown ta signal a attempt ta cast
an object ta a cold-ass lil class of which it aint a instance.
195
196
Student u = freshly smoked up UnderGrad()j
System.out.println«String) u)j
Chapta 3 Inheritizzle n' Polymorphism
IIClassCastException
int x = «GradStudent)
Ilu aint a instizzle of String
u).getID()j Pt IIClassCastException
Ilu aint a instizzle of GradStudent
. ~. '. ;-:
ABSTRACT CLASSES
Abstract Class
An abstract class be a superclass dat represents a abstract concept, n' therefore should
not be instantiated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. For example, a maze program could have nuff muthafuckin different maze
components-paths, walls, entrances, n' exits fo' realz. All of these share certain features (e.g.,
location, n' a way of displaying). They can therefore all be declared as subclasses of
the abstract class MazeComponent. Da program will create path objects, wall objects,
and so on yo, but no instancez of MazeComponent.
An abstract class may contain abstract methodz fo' realz. An abstract method has no implementation
code, just a header n' shit. Da rationale fo' a abstract method is dat there is no
phat default code fo' tha method. Y'all KNOW dat shit, muthafucka! Every subclass will need ta override dis method,
so why bother wit a meaningless implementation up in tha superclass, biatch? Da method
appears up in tha abstract class as a placeholda n' shit. Da implementation fo' tha method occurs
in tha subclasses. If a cold-ass lil class gotz nuff any abstract methods, it must be declared an
abstract class.
Da abstract Keyword
An abstract class is declared wit tha keyword abstract up in tha header:
hood abstract class AbstractClass
{
Da keyword extendz is used as before ta declare a subclass:
hood class SubClass extendz AbstractClass
{
If a subclass of a abstract class do not provide implementation code fo' all the
abstract methodz of its superclass, it too becomes a abstract class n' must be declared
as such ta stay tha fuck away from a cold-ass lil compile-time error:
hood abstract class SubClass extendz AbstractClass
{
Here be a example of a abstract class, wit two concrete (nonabstract) subclasses.
hood abstract class Shape
{
private Strin myNamej
//constructor
hood Shape(Strin name)
{ myName = namej }
Abstract Classes
}
hood Strin getName()
{ return myName; }
hood abstract double area();
hood abstract double perimeter();
hood double semiPerimeter()
{ return perimeter() / 2; }
hood class Circle extendz Shape
{
}
private double myRadius;
//constructor
hood Circle(double radius, Strin name)
{
}
super(name);
myRadius = radius;
hood double perimeter()
{ return 2 * Math.PI * myRadius; }
hood double area()
{ return Math.PI * myRadius * myRadius; }
hood class Square extendz Shape
{
}
private double mySide;
//constructor
hood Square(double side, Strin name)
{
}
super(name);
mySide = side;
hood double perimeter()
{ return 4 * mySide; }
hood double area()
{ return mySide * mySide; }
NOTE
1. Well shiiiit, it is meaningless ta define perimeta n' area methodz fo' Shape-thus, these
are declared as abstract methods.
2 fo' realz. An abstract class can have both instizzle variablez n' concrete (nonabstract)
methods. Right back up in yo muthafuckin ass. See, fo' example, myName, getName, n' semiPerimeta up in tha Shape
class .
.3 fo' realz. Abstract methodz is declared wit tha keyword abstract. There is no method
body. Da header is terminated wit a semicolon.
197
198
A nonabstract class
that implements an
interface must
implement every
method of the
interface.
Chapta 3 Inheritizzle n' Polymorphism
4. No instances can be pimped fo' a abstract class:
Shape a = freshly smoked up Shape("blob"); Pt IIIllegal.
IICan't create instizzle of abstract class.
Shape c = freshly smoked up Circle(1.5, "small circle"); Illegal
5. Polymorphizzle works wit abstract classes as it do wit concrete classes:
Shape circ = freshly smoked up Circle(10, "circle");
Shape sq = freshly smoked up Square(9.4, "square");
Shape s = null;
System.out.println("Which shape?");
Strin str = IO.readString(); Ilread user input
if (str.equals("circle"»
s circ;
else
s sq;
System.out.println("Area of " + s.getNameO + Pt II is "
+ s.areaO);
INTERFACES
Interface
An intercourse be a cold-ass lil collection of related methodz whose headaz is provided without implementations.
All of tha methodz is both hood n' abstract-no need ta explicitly
include these keywordz fo' realz. As such, they provide a gangbangin' framework of behavior fo' any class.
Da classes dat implement a given intercourse may represent objects dat is vastly
different. They all, however, have up in common a cold-ass lil capabilitizzle or feature expressed up in the
methodz of tha intercourse fo' realz. An intercourse called FlyingObject, fo' example, may have the
methodz fly n' isFlying. Right back up in yo muthafuckin ass. Some classes dat implement FlyingObject could be Bird,
Airplane, Pistol, Butterfly, n' Witch fo' realz. A class called Turtle would be unlikely to
implement FlyingObject cuz turtlez don't fly.
An intercourse called Computable may have just three methods: add, subtract,
and multiply. Classes dat implement Computable could be Fraction, Matrix,
Longlnteger, n' ComplexNumber n' shit. Well shiiiit, it would not be meaningful, however, fo' a
TelevisionSet ta implement Computable-what do it mean, fo' example, ta multiply
two TelevisionSet objects?
A class dat implements a intercourse can define any number of methods. In particular,
it contracts ta provide implementations fo' all tha methodz declared up in the
interface. If it fails ta implement any of tha methods, tha class must be declared abstract.
Definin a Interface
An intercourse is declared wit tha intercourse keyword. Y'all KNOW dat shit, muthafucka! For example,
hood intercourse FlyingObject
{
void flyO;
boolean isFlying();
}
Ilmethod dat simulates flight of object
Iitrue if object is up in flight,
Ilfalse otherwise
Interfaces
Da implements Keyword
Interfaces is implemented rockin tha implements keyword. Y'all KNOW dat shit, muthafucka! For example,
hood class Bird implements FlyingObject
{
This declaration means dat two of tha methodz up in tha Bird class must be fly and
isFlying. Note dat any subclass of Bird will automatically implement tha intercourse
FlyingObject, since fly n' isFlyin is ghon be inherited by tha subclass.
A class dat extendz a superclass can also directly implement a intercourse. For example,
hood class Mosquito extendz Insect implements FlyingObject
{
NOTE
1. Da extendz clause must precede tha implements clause.
2 fo' realz. A class can have just one superclass yo, but it can implement any number of intercourses:
hood class SubClass extendz SuperClass
implements Interface1, Interface2,
Da Comparable Interface
Da standard java . lang package gotz nuff tha Comparable intercourse, which provides
a useful method fo' comparin objects, n' you can put dat on yo' toast. Note dat tha AP Java subset uses tha raw
Comparable intercourse, not tha generic Comparable<e> of Java 5.0.
hood intercourse Comparable
{
int compareTo(Object obj);
}
Any class dat implements Comparable must provide a cold-ass lil compareTo method. Y'all KNOW dat shit, muthafucka! This method
compares tha implicit object (this) wit tha parameta object (obj) n' returns a negative
integer, zero, or a positizzle integer dependin on whether tha implicit object is less
than, equal to, or pimped outa than tha parameter n' shit. If tha two objects bein compared are
not type compatible, a ClassCastException is thrown by tha method.
Example
Da abstract Shape class defined previously (p. 196) is modified ta implement the
Comparable intercourse:
hood abstract class Shape implements Comparable
{
private Strin myName;
//constructor
hood Shape(Strin name)
{ myName = name; }
199
CIa ses freestyled for
objects dat need to
be compared should
implement
Comparable.
200
}
Chapta 3 Inheritizzle n' Polymorphism
hood Strin getName()
{ return myName; }
hood abstract double area();
hood abstract double perimeter();
hood double semiPerimeter()
{ return perimeter() / 2; }
hood int compareTo(Object obj)
{
}
final double EPSILON = 1.0e-15; //slightly bigger than
//machine precision
Shape rhs = (Shape) obj;
double diff = area() - rhs.area();
if (Math.abs(diff) &lt;= EPSILON * Math.abs(area(»)
return 0; //area of dis shape equals area of obj
else if (diff &lt; 0)
return -1; //area of dis shape less than area of obj
else
return 1; //area of dis shape pimped outa than area of obj
NOTE
1. Da Circle, Square, n' other subclassez of Shape will all automatically implement
Comparable n' inherit tha compareTo method.
2. Well shiiiit, it is temptin ta bust a simpla test fo' equalitizzle of areas, namely
if (diff == 0)
return 0;
But recall dat real numbers can have round-off errors up in they storage (Box
p. 122). This means dat tha simple test may return false even though tha two
areas is essentially equal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack fo' realz. A mo' robust test is implemented up in tha code given,
namely ta test if tha relatizzle error up in diff is lil' small-ass enough ta be considered zero.
3. Da Object class be a universal superclass (see p. 225). This means dat the
compareTo method can take as a parameta any object reference dat implements
Comparable.
4. Da first step of a cold-ass lil compareTo method must cast tha Object argument ta the
class type, up in dis case Shape. If dis aint done, tha compila won't find the
area method-remember, a Object aint necessarily a Shape.
S. Da algorithm one chizzlez up in compareTo should up in general be consistent with
the equals method (see p. 227): Whenever object1.equals(object2) returns
true, objectl.compareTo(object2) returns O.
Here be a program dat findz tha larger of two Comparable objects.
Interfaces
hood class FindMaxTest
{
}
1* Return tha larger of two objects a n' b. *1
hood static Comparable max (Comparable a, Comparable b)
{
}
if (a.compareTo(b) &gt; 0) Ilif a&gt; b ...
return a;
else
return b;
1* Test max on two Shape objects, n' you can put dat on yo' toast. *1
hood static void main(String[] args)
{
}
Shape s1 = freshly smoked up Circle(3.0, "circle");
Shape s2 = freshly smoked up Square(4.5, "square");
System.out.println("Area of Pt II + s1.getNameO + Pt II is Pt II +
s1.areaO) ;
System.out.println("Area of Pt II + s2.getNameO + Pt II is Pt II +
s2.areaO) ;
Shape s3 = (Shape) max(s1, s2);
System.out.println("Da larger shape is tha Pt II +
s3 . getName 0 ) ;
Here is tha output:
Area of circle is 28.27
Area of square is 20.25
Da larger shape is tha circle
NOTE
1. Da max method takes parametaz of type Comparable. Right back up in yo muthafuckin ass. Since s1 is-a Comparable
object n' s2 is-a Comparable object, no castin is necessary up in tha method call.
2. Da max method can be called wit any two Comparable objects, fo' example,
two Strin objects or two Integer objects (see Chapta 4).
3. Da objects must be type compatible (i.e., it must make sense ta compare
them). For example, up in tha program shown, if s1 is-a Shape n' s2 is-a String,
the compareTo method will throw a ClassCastException all up in tha line
Shape rhs = (Shape) obj;
4. Da cast is needed up in tha line
Shape s3 = (Shape) max(s1, s2);
since max(s1, s2) returns a Comparable.
5 fo' realz. A primitizzle type aint a object n' therefore cannot be passed as Comparable_
Yo ass can, however, bust a wrapper class n' up in dis way convert a primitizzle type
to a Comparable (see p. 231).
ABSTRACT CLASS VS. INTERFACE
Consider freestylin a program dat simulates a game of Battleships_ Da program may
have a Ship class wit subclasses Submarine, Cruiser, Destroyer, n' so on. I aint talkin' bout chicken n' gravy biatch. The
201
202 Chapta 3 Inheritizzle n' Polymorphism
various ships is ghon be placed up in a two-dimensionizzle grid dat represents a part of the
ocean, much like tha grid up in tha GridGhetto Case Study.
An abstract class Ship be a phat design chizzle. There aint gonna be any instances of
Ship objects cuz tha specific featurez of tha subclasses must be known up in order to
place these ships up in tha grid. Y'all KNOW dat shit, muthafucka! A Grid intercourse like dat up in tha case study suggests itself
for tha two-dimensionizzle grid.
Notice dat tha abstract Ship class is specific ta tha Battleships application, whereas
the Grid intercourse is not. Yo ass could use tha Grid intercourse up in any program dat has a
two-dimensionizzle grid.
Interface vs fo' realz. Abstract Class
 Use a abstract class fo' a object dat be applicationspecific,
but incomplete without its subclasses.
 Consider rockin a intercourse when its methodz is suitable
for yo' program yo, but could be equally applicable up in a variety
of programs.
 An intercourse cannot provide implementations fo' any of its
methods, whereas a abstract class can.
 An intercourse cannot contain instizzle variables, whereas an
abstract class can.
 An intercourse n' a abstract class can both declare constants.
 It aint possible ta create a instizzle of a intercourse object
or a abstract class object.
Chapta Summary
Yo ass should be able ta write yo' own subclasses, given any superclass. Level AB
students should be able ta write a cold-ass lil class dat implements Comparable, while all hustlas
should be able ta use tha compareTo method ta compare objects.
Be shizzle you can explain what tha fuck polymorphizzle is: Recall dat it only operates when
methodz done been overridden up in at least one subclass. Yo ass should also be able to
explain tha difference between tha followin c~ncepts:
 An abstract class n' a intercourse.
 An overloaded method n' a overridden method.
 Dynamic bindin Qate binding) n' static bindin (early binding).
Multiple-Choice Thangs on Inheritizzle n' Polymorphism
MULTIPLE-CHOICE QUESTIONS ON INHERITANCE AND
POLYMORPHISM
Thangs 1-10 refer ta tha BankAccount, SavingsAccount, n' CheckingAccount classes
defined below:
hood class BankAccount
{
}
private double myBalance;
hood BankAccount()
{ myBalizzle = 0; }
hood BankAccount(double balance)
{ myBalizzle = balance; }
hood void deposit(double amount)
{ myBalizzle += amount; }
hood void withdraw(double amount)
{ myBalizzle -= amount; }
hood double getBalance()
{ return myBalance; }
hood class SavingsAccount extendz BankAccount
{
}
private double mylnterestRate;
hood SavingsAccount()
{ 1* implementation not shown *1 }
hood SavingsAccount(double balance, double rate)
{ 1* implementation not shown *1 }
hood void addInterest() Pt IIAdd interest ta balance
{ 1* implementation not shown *1 }
hood class CheckingAccount extendz BankAccount
{
}
private static final double FEE = 2.0;
private static final double MIN_BALANCE - 50.0;
hood CheckingAccount(double balance)
{ 1* implementation not shown *1 }
1* FEE of $2 deducted if withdrawal leaves balizzle less
* than MIN_BALANCE fo' realz. Allows fo' wack balance. *1
hood void withdraw(double amount)
{ 1* implementation not shown *1 }
203
204 Chapta 3 Inheritizzle n' Polymorphism
1. Of tha methodz shown, how tha fuck nuff different nonconstructor methodz can be
invoked by a SavingsAccount object?
(A) 1
(B) 2
(C) 3
(0) 4
(E) 5
2. Which of tha followin erectly implements tha default constructor of the
SavingsAccount class?
I mylnterestRate = 0;
supa 0 ;
II supa 0 ;
mylnterestRate = 0;
III supa 0 ;
(A) Pt II only
(B) I n' Pt II only
(C) Pt II n' Pt III only
(0) Pt III only
(E) I, Pt II, n' Pt III
3. Which be a cold-ass lil erect implementation of tha constructor wit parametas up in the
SavingsAccount class?
(A) myBalizzle = balance;
mylnterestRate = rate;
(B) getBalance() = balance;
mylnterestRate = rate;
(C) supa 0 ;
mylnterestRate = rate;
(0) super(balance);
mylnterestRate = rate;
(E) supa (balizzle , rate);
4. Which be a cold-ass lil erect implementation of tha CheckingAccount constructor?
I super(balance);
II superO;
deposit(balance);
~ deposit(balance);
(A) I only
(B) Pt II only
(C) Pt III only
(0) Pt II n' Pt III only
(E) I, Pt II, n' Pt III
Multiple-Choice Thangs on Inheritizzle n' Polymorphism
5. Which is erect implementation code fo' tha withdraw method 10 the
CheckingAccount class?
(A) supa n' shit. withdraw (amount) ;
if (myBalizzle &lt; MIN_BALANCE)
super.withdraw(FEE);
(B) withdraw(amount);
if (myBalizzle &lt; MIN_BALANCE)
withdraw(FEE);
(C) super.withdraw(amount);
if (getBalance() &lt; MIN_BALANCE)
super.withdraw(FEE);
0) withdraw(amount);
if (getBalance() &lt; MIN_BALANCE)
withdraw(FEE);
(E) myBalizzle -= amount;
if (myBalizzle &lt; MIN_BALANCE)
myBalizzle -= FEE;
6. Redefinin tha withdraw method up in tha CheckingAccount class be a example of
(A) method overloading.
(B) method overriding.
(C) downcasting.
0) dynamic bindin (late binding).
(E) static bindin (early binding).
Use tha followin fo' Thangs 7-9.
A program ta test tha BankAccount, SavingsAccount, n' CheckingAccount classes has
these declarations:
BankAccount b = freshly smoked up BankAccount(1400);
BankAccount s = freshly smoked up SavingsAccount(1000, 0.04);
BankAccount c = freshly smoked up CheckingAccount(500);
7. Which method call will cause a error?
(A) b.deposit(200);
(B) s.withdraw(500);
(C) c.withdraw(500);
0) s.deposit(10000);
(E) s.addInterest();
8. In order ta test polymorphism, which method must be used up in tha program?
(A) Either a SavingsAccount constructor or a CheckingAccount constructor
(B) addInterest
(C) deposit
0) withdraw
(E) getBalance
205
206 Chapta 3 Inheritizzle n' Polymorphism
9. Which of tha followin aint gonna cause a ClassCastException ta be thrown?
(1\) «SavingsAccount) b).addlnterest();
(B) «CheckingAccount) b).withdraw(200);
(C) «CheckingAccount) c).deposit(800);
OJ) «CheckingAccount) s).withdraw(150);
(E) «SavingsAccount) c).addlnterest();
10. 1\ freshly smoked up method be added ta tha BankAccount class.
1* Transfer amount from dis BankAccount ta another BankAccount.
* Precondition: myBalizzle &gt; amount *1
hood void transfer(BankAccount another, double amount)
{
}
withdraw(amount);
another.deposit(amount);
1\ program has these declarations:
BankAccount b = freshly smoked up BankAccount(650);
SavingsAccount timsSavings = freshly smoked up SavingsAccount(1500, 0.03);
CheckingAccount daynasCheckin = freshly smoked up CheckingAccount(2000)j
Which of tha followin will transfer scrilla from one account ta another without
error?
I b.transfer(timsSavings, 50)j
IT timsSavings.transfer(daynasChecking, 30);
lIT daynasChecking.transfer(b, 55);
(1\) I only
(B) IT only
(C) lIT only
OJ) I, IT, n' lIT
(E) None
Multiple-Choice Thangs on Inheritizzle n' Polymorphism
11. Consider these class declarations:
hood class Person
{
}
hood class Teacher extendz Person
{
}
Which be a legit statement?
I Teacher inherits tha constructorz of Person.
II Teacher can add freshly smoked up methodz n' private instizzle variables.
III Teac'her can override existin private methodz of Person.
(A) I only
(B) Pt II only
(C) Pt III only
(D) I n' Pt II only
(E) Pt II n' Pt III only
12. Which statement bout abstract classes n' intercourses is false?
(A) An intercourse cannot implement any methods, whereas a abstract class can.
(B) A class can implement nuff intercourses but can have only one superclass.
(C) An unlimited number of unrelated classes can implement tha same intercourse.
(D) It aint possible ta construct either a abstract class object or a intercourse
object.
(E) All of tha methodz up in both a abstract class n' a intercourse is public.
207
208 Chapta 3 Inheritizzle n' Polymorphism
13. Consider tha followin hierarchy of classes:
A p,rogram is freestyled ta print data bout various birds:
hood class BirdStuff
{
}
hood static void printName(Bird b)
{ 1* implementation not shown *1 }
hood static void printBirdCall(Parrot p)
{ 1* implementation not shown *1 }
Iiseveral mo' Bird methods
hood static void main(String[] args)
{
}
Bird birdl = freshly smoked up Bird();
Bird bird2 = freshly smoked up Parrot();
Parrot parrotl = freshly smoked up Parrot();
Parrot parrot2 = freshly smoked up Parakeet();
1* mo' code *1
Assumin dat none of tha given classes be abstract n' all have default constructors,
which of tha followin segmentz of 1* mo' code *1 aint gonna cause a error?
(A) printName (parrot2) ;
printBirdCall«Parrot) bird2)j
(B) printName«Parrot) birdl)j
printBirdCall(bird2)j
(C) printName(bird2)j
printBirdCall(bird2)j
0) printName«Parakeet) parrotl)j
printBirdCall(parrot2)j
(E) printName«Owl) parrot2)j
printBirdCall{(Parakeet) parrot2)j
Multiple-Choice Thangs on Inheritizzle n' Polymorphism
Use tha declarations below fo' Thangs 14-16.
hood abstract class Solid
{
}
private Strin myNamej
//constructor
hood Solid(Strin name)
{ myName = namej }
hood Strin getName()
{ return myNamej }
hood abstract double volume()j
hood class Sphere extendz Solid
{
}
private double myRadiusj
//constructor
hood Sphere(Strin name, double radius)
{
}
super(name)j
myRadius = radius;
hood double volume()
{ return (4.0/3.0) * Math.PI * myRadius * myRadius * myRadiusj }
hood class RectangularPrizzle extendz Solid
{
}
private double myLengthj
private double mah Width;
private double myHeightj
//constructor
hood RectangularPrism(Strin name, double I, double w,
double h)
{
}
super(name)j
myLength = 1 j
my Width = W;
myHeight = hj
hood double volume()
{ return myLength * mah Width * myHeight; }
209
210 Chapta 3 Inheritizzle n' Polymorphism
14 fo' realz. A program dat tests these classes has tha followin declarations n' assignments:
Solid 81, 82, 83, 84;
81 = freshly smoked up Solid("blob");
82 = freshly smoked up Sphere(18phere", 3.8);
83 = freshly smoked up RectangularPri8m(lbox", 2, 4, 6.5);
84 = null;
How tha fuck nuff of tha above linez of code is incorrect?
(A) 1
(B) 2
(C) 3
(D) 4
(E) 5
15. Which is false?
(A) If a program has nuff muthafuckin objects declared as type Solid, tha decision about
which volume method ta booty-call is ghon be resolved at run time.
(B) If tha Solid class was modified ta provide a thugged-out default implementation fo' the
volume method, it would no longer need ta be a abstract class.
(C) If tha Sphere n' RectangularPri8m classes failed ta provide a implementation
for tha volume method, they would need ta be declared as abstract
classes.
(D) Da fact dat there is no reasonable default implementation fo' tha volume
method up in tha Solid class suggests dat it should be a abstract method.
(E) Since Solid be abstract n' its subclasses is nonabstract, polymorphizzle no
longer applies when these classes is used up in a program.
Multiple-Choice Thangs on Inheritizzle n' Polymorphism
16 yo. Here be a program dat prints tha volume of a solid:
hood class SolidMain
{
1* Output volume of Solid s. *1
hood static void printVolume(Solid s)
{
System.out.println("Volume = Pt II + s.volumeO +
II cubic units");
}
}
hood static void main(String[] args)
{
}
Solid sol;
Solid sph = freshly smoked up Sphere ("sphere", 4);
Solid rec = freshly smoked up RectangularPrism(lbox", 3,
int flipCoin = (int) (Math.random() * 2);
if (flipCoin == 0)
sol = sph;
else
sol = rec;
printVolume(sol)j
Which be a legit statement bout dis program?
6, 9);
110 or 1
(A) It will output tha volume of tha sphere or box, as intended.
(B) It will output tha volume of tha default Solid s, which is neither a sphere
nora box.
(C) A ClassCastException is ghon be thrown.
(0) A compile-time error will occur cuz there is no implementation code
for volume up in tha Solid class.
(E) A run-time error will occur cuz of parameta type mismatch up in the
method call printVolume (sol).
211
212 Chapta 3 Inheritizzle n' Polymorphism
17. Consider tha Computable intercourse below fo' struttin simple calculator operations:
hood intercourse Computable
{
}
//Return dis Object + y.
Object add(Object y);
//Return dis Object - y.
Object subtract(Object y);
IIReturn dis Object * y.
Object multiply(Object y);
Which of tha followin is tha least suitable class fo' implementin Computable?
(A) Largelnteger
(B) Fraction
//integers wit 100 digits or more
//implemented wit numerator and
Iidenominator of type int
(C) IrrationalNumber /Inonrepeating, nonterminatin decimal
0) Length //implemented wit different units, such
/Ias inches, centimeters, etc.
(E) BankAccount //implemented wit myBalance
Refer ta tha Player intercourse shown below fo' Thangs 18-21.
hood intercourse Player
{
}
1* Return a integer dat represents a move up in a game. *1
int git Move 0 ;
1* Display tha statuz of tha game fo' dis Player after
* implementin tha next move. *1
void updateDisplay();
18 fo' realz. A class HumanPlayer implements tha Player intercourse fo' realz. Another 'class,
SmartPlayer, be a subclass of HumanPlayer n' shit. Which statement is false?
(A) SmartPlayer automatically implements tha Player intercourse.
(B) HumanPlayer must contain implementationz of both tha updateDisplay and
getMove methods.
(C) It aint possible ta declare a reference of type Player.
0) Da SmartPlayer class can override tha methodz updateDisplay and
getMove of tha HumanPlayer class.
(E) A method up in a cold-ass lil client program can have Player as a parameta type.
Multiple-Choice Thangs on Inheritizzle n' Polymorphism
19 fo' realz. A programmer plans ta write programs dat simulate various games. In each
case he gonna git nuff muthafuckin classes, each representin a gangbangin' finger-lickin' different kind of competitor
in tha game, like fuckin ExpertPlayer, ComputerPlayer, RecklessPlayer,
CheatingPlayer, Beginner, IntermediatePlayer, n' so on. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it mayor may not
be suitable fo' these classes ta implement tha Player intercourse, dependin on the
particular game bein simulated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. In tha game busted lyrics bout below, which is tha least
suitable fo' havin tha competitor classes implement tha given Player intercourse?
(A) High-Low Guessin Game: Da computa be thinkin of a number n' tha competitor
who guesses it wit tha least number of guesses wins. Mta each
guess, tha computa  drops some lyrics ta whether its number is higher or lower than the
guess.
(B) Chips: Start wit a pile of chips. Each playa up in turn removes some number
of chips. Da balla is tha one whoz ass removes tha final chip. Da first playa
may remove any number of chips yo, but not all of dem wild-ass muthafuckas. Each subsequent
player must remove at least one chip n' at most twice tha number removed
by tha precedin playa.
(C) Chess: Played on a square board of 64 squarez of alternatin colors. There
are just two playas, called White n' Black, tha flavaz of they respective
pieces. Da playas each gotz a set of pieces on tha board dat can move
accordin ta a set of rules. Da playas alternate moves, where a move consists
of movin mah playas piece ta another square. If dat square is occupied
by a opponentz piece, tha piece is captured n' removed from tha board.
(0) Tic-Tac-Toe: Two playas alternate placin "X" or "0" on a 3 x 3 grid. Y'all KNOW dat shit, muthafucka! The
first playa ta git three up in a row, where a row can be vertical, horizontal, or
diagonal, wins.
(E) Battleships: There is two playas, each wit a 10 x 10 grid hidden from
his opponent. Various "ships" is placed on tha grid. Y'all KNOW dat shit, muthafucka! A move consists
of callin up a grid location, tryin ta "hit" a opponentz ship. Players
alternate moves. Da first playa ta sink his opponentz fleet wins.
213
214 Chapta 3 Inheritizzle n' Polymorphism
Consider these declarations fo' Thangs 20 n' 21:
hood class HumanPlayer implements Player
{
private Strin myName;
//constructors not shown
//code ta implement getMove n' updateDisplay not shown ...
hood Strin getName()
{ /* implementation not shown */ }
}
hood class ExpertPlayer extendz HumanPlayer implements Comparable
{
private int myRatingj
//constructors not shown
hood int compareTo(Object obj)
{ /* implementation not shown */ }
}
20. Which code segment up in a cold-ass lil client program will cause a error?
I Player pi = freshly smoked up HumanPlayer()j
Player p2 = freshly smoked up ExpertPlayer()j
int xl = pl.getMove()j
int x2 = p2.getMove();
II int Xj
Comparable cl = freshly smoked up ExpertPlayer(f* erectparameterlist *f) j
Comparable c2 = freshly smoked up ExpertPlayer (f * erect parameta list * f) j
if (cl.compareTo(c2) &lt; 0)
x = cl.getMove()j
else
x = c2.getMove()j
III int Xj
HumanPlayer hi = freshly smoked up HumanPlayer (f * erect parameta list * f) j
HumanPlayer h2 = freshly smoked up HumanPlayer (f * erect parameta list * f) j
if (hl.compareTo(h2) &lt; 0)
x = hl.getMove()j
else
x = h2.getMove()j
(A) Pt II only
(B) Pt III only
(C) Pt II n' Pt III only
(0) I, Pt II, n' Pt III
(E) None
Multiple-Choice Thangs on Inheritizzle n' Polymorphism
21. Which of tha followin is erect implementation code fo' tha compareTo method
in tha ExpertPlayer class?
I ExpertPlayerrhs = (ExpertPlayer) objj
if (myRating'== rhs.myRating)
return OJ
else if (myRatin &lt; rhs.myRating)
return -1j
else
return 1j
II ExpertPlayer rhs = (ExpertPlayer) objj
return myRatin - rhs.myRatingj
III ExpertPlayer rhs = (ExpertPlayer) objj
if (getName().equals(rhs.getName()))
return OJ
else if (getName().compareTo(rhs.getName()) &lt; 0)
return -1;
else
return 1j
(A) I only
(B) Pt II only
(C) monly
(D) I n' Pt II only
(E) I, Pt II, n' m
22. Which statement bout intercourses is true?
I An intercourse gotz nuff only hood abstract methodz n' hood static final
fields.
II H a cold-ass lil class implements a intercourse n' then fails ta implement any methods
in dat intercourse, then tha class must be declared abstract.
m While a cold-ass lil class may implement just one intercourse, it may extend mo' than
one class.
(A) I only
(B) I n' Pt II only
(C) I n' m only
(D) Pt II n' m only
(E) I, Pt II, n' m
215
216 Chapta 3 Inheritizzle n' Polymorphism
23. Which of tha followin classes is tha least suitable muthafucka fo' implementing
the Comparable intercourse?
(A) hood class Point
{
}
private double x;
private double y;
//various methodz follow
(B) hood class Name
{
}
private Strin firstName;
private Strin lastName;
//various ~ethodz follow
(C) hood class Car
{
}
private int modelNumber;
private int year;
private double price;
//various methodz follow
(D) hood class Student
{
}
private Strin name;
private double gpa;
//various methodz follow
(E) hood class Employee
{
}
private Strin name;
private int hireDate;
private double salary;
//various methodz follow
Multiple-Choice Thangs on Inheritizzle n' Polymorphism
24 fo' realz. A programmer has tha task of maintainin a thugged-out database of hustlaz of a big-ass university.
There is two typez of hustlas, undergraduates n' graduate hustlas.
On some third of tha graduate hustlas is doctoral muthafuckas.
All of tha hustlas have tha same underground shiznit stored, like name, address,
and beeper number, n' also hustla shiznit like courses taken and
grades. Each hustlaz GPA is computed yo, but differently fo' undergraduates and
graduates. Da doctoral muthafuckas have shiznit bout they dissertations
and faculty advisors.
Da programmer will write a Java program ta handle all tha hustla shiznit.
Which of tha followin is tha dopest design, up in termz of programmer efficiency
and code reusability, biatch? Note: { ... } denotes class code.
(A) hood intercourse Student { ... }
hood class Undergraduate implements Student { ... }
hood class Graduate implements Student { }
hood class DocStudent extendz Graduate { }
(B) hood abstract class Student { ... }
hood class Undergraduate extendz Student { ... }
hood class Graduate extendz Student { ... }
hood class DocStudent extendz Graduate { }
(C) public
public
public
public
class Student { ... }
class Undergraduate extendz Student { ... }
class Graduate extendz Student { ... }
class DocStudent extendz Graduate { }
0) hood abstract class Student { ... }
hood class Undergraduate extendz Student { ... }
hood class Graduate extendz Student { ... }
hood class DocStudent extendz Student { ... }
(E) hood intercourse Personallnformation { ... }
hood class Student implements Personallnformation { ... }
hood class Undergraduate extendz Student { ... }
hood abstract class Graduate extendz Student { ... }
hood class DocStudent extendz Graduate { ... }
217
218 Chapta 3 Inheritizzle n' Polymorphism
25 fo' realz. A certain intercourse provided by a Java package gotz nuff just a single method:
hood intercourse SomeName
{
int methodi(Object 0);
}
A programmer addz some functionalitizzle ta dis intercourse by addin another
method ta it, method2:
hood intercourse SomeName
{
}
int methodi(Object obi);
void method2(Object ob2);
As a result of dis addition, which of tha followin is true?
(A) A ClassCastException will occur if obi n' ob2 is not compatible.
(B) All classes dat implement tha original gangsta SomeName intercourse will need ta be
rewritten cuz they no longer implement SomeName.
(C) A class dat implements tha original gangsta SomeName intercourse will need ta modify
its declaration as bigs up:
hood class ClassName implements SomeName extendz method2
{
(0) SomeName will need ta be chizzled ta a abstract class n' provide implementation
code fo' method2, so dat tha original gangsta n' upgraded versions of
SomeName is compatible.
(E) Any freshly smoked up class dat implements tha upgraded version of SomeName will not
compile.
26. Consider tha Temperature class defined below:
hood class Temperature implements Comparable
{
}
private Strin myScale;
private double myDegrees;
Iidefault constructor
hood Temperature ()
{ 1* implementation not shown *1 }
Ilconstructor
hood Temperature(Strin scale, double degrees)
{ 1* implementation not shown *1 }
hood int compareTo(Object obj)
{ 1* implementation not shown *1 }
hood Strin toString()
{ 1* implementation not shown *1 }
Here be a program dat findz tha lowest of three temperatures:
Multiple-Choice Thangs on Inheritizzle n' Polymorphism
hood class TemperatureMain
{
}
1* Find smalla of objects a n' b. *1
hood static Comparable min (Comparable a, Comparable b)
{
}
if (a.compareTo(b) &lt; 0)
return a;
else
return b;
1* Find smallest of objects a, b, n' c *1
hood static Comparable minThree(Comparable a,
Comparable b, Comparable c)
{
return min(min(a, b), c);
}
hood static void main(String[] args)
{
1* code ta test minThree method *1
}
Which is erect replacements fo' 1* code ta test minThree method */?
I Temperature t1 = freshly smoked up Temperature ("C", 85);
Temperature t2 = freshly smoked up Temperature ("F" , 45);
Temperature t3 = freshly smoked up Temperature ("F" , 120);
System.out.println("Da lowest temperature is Pt II +
minThree(t1, t2, t3»;
II Comparable c1 = freshly smoked up Temperature ("C" , 85);
Comparable c2 = freshly smoked up Temperature ("F", 45);
Comparable c3 = freshly smoked up Temperature ("F" , 120);
System.out.println("Da lowest temperature is Pt II +
minThree(c1, c2, c3»;
m Comparable c1 = freshly smoked up Comparable ("C" , 85);
Comparable c2 = freshly smoked up Comparable ("F" , 45);
Comparable c3 = freshly smoked up Comparable("F", 120);
System.out.println("Da lowest temperature is Pt II +
minThree(c1, c2, c3»;
(A) Pt II only
(B) I n' Pt II only
(C) Pt II n' m only
(0) I n' m only
(E) I, Pt II, n' m
219
220
ANSWERKEV
I.D
2. C
3. D
4. E
5. C
6.B
7. E
8. D
9. C
10. D
11. E
12. E
13 fo' realz. A
14 fo' realz. A
15. E
16 fo' realz. A
17. E
18. C
ANSWERS EXPLAINED
Chapta 3 Inheritizzle n' Polymorphism
19. C
20. C
21. E
22. B
23 fo' realz. A
24. B
25. B
26. B
1. (0) Da methodz is deposit, withdraw, n' getBalance, all inherited from
the BankAccount class, plus addlnterest, which was defined just fo' tha class
SavingsAccount.
2. (C) Implementation I fails cuz supa 0 must be tha straight-up original gangsta line of tha implementation
whenever it is used up in a cold-ass lil constructor. Shiiit, dis aint no joke. Implementation m may step tha fuck up to
be incorrect cuz it don't initialize mylnterestRate. Right back up in yo muthafuckin ass. Since mylnterestRate,
however, be a primitizzle type-double-the compila will provide a thugged-out default initialization
of 0, which was required.
3. (0) First, tha statement super(balance) initializes tha inherited private variable
myBalizzle as fo' tha BankAccount superclass. Then tha statement
mylnterestRate = rate initializes mylnterestRate, which belongs uniquely to
the SavingsAccount class. Chizzle E fails cuz mylnterestRate do not belong
to tha BankAccount class n' therefore cannot be initialized by a super
method. Y'all KNOW dat shit, muthafucka! Chizzle A is wack cuz tha SavingsAccount class cannot directly
access tha private instizzle variablez of its superclass. Chizzle B assigns a value to
an accessor method, which is meaningless. Chizzle C is incorrect cuz super()
invokes tha default constructor of tha superclass. This will cause myBalizzle of the
SavingsAccount object ta be initialized ta 0, rather than balance, tha parameter
value.
4. (E) Da constructor must initialize tha inherited instizzle variable myBalizzle to
the value of tha balizzle parameter n' shiznit fo' realz. All three segments big up all dis bullshit. Implementation
I do it by invokin supa (balance), tha constructor up in tha superclass.
Implementation Pt II first initializes myBalizzle ta 0 by invokin tha default constructor
of tha superclass. Then it calls tha inherited deposit method of the
superclass ta add balizzle ta tha account. Implementation m works cuz super
0 be automatically called as tha straight-up original gangsta line of tha constructor code if there is no
explicit call ta super.
5. (C) First tha withdraw method of tha BankAccount superclass is used ta withdraw
amount fo' realz. A prefix of supa must be used ta invoke dis method, which eliminates
Answers Explained
choices Band D. Then tha balizzle must be tested rockin tha accessor method
getBalance, which is inherited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Yo ass can't test myBalizzle directly since it is private
to tha BankAccount class. This eliminates chizzlez A n' E, n' provides
another reason fo' eliminatin chizzle B.
6. (B) When a superclass method is redefined up in a subclass, tha process is called
method overriding. Which method ta booty-call is determined at run time. This is
called dynamic bindin (p. 193). Method overloadin is two or mo' methodz with
different signatures up in tha same class (p. 155). Da compila recognizes at compile
time which method ta call. This is early binding. Da process of downcastin is
unrelated ta these principlez (p. 194).
7. (E) Da addlnterest method is defined only up in tha SavingsAccount class. It
therefore cannot be invoked by a BankAccount object. Da error can be fixed by
castin s ta tha erect type:
((SavingsAccount) s).addlnterest()~
Da oth$!r method calls do not cause a problem cuz withdraw n' deposit
are both methodz of tha BankAccount class.
8. (0) Da withdraw method is tha only method dat has one implementation in
the superclass n' a gangbangin' finger-lickin' different implementation up in a subclass. Polymorphizzle is
the mechanizzle of selectin tha erect method from tha different possibilitizzles in
the class hierarchy. Notice dat tha deposit method, fo' example, be available to
objectz of all three bank account classes yo, but itz tha same ol' dirty code up in all three cases.
So polymorphizzle aint tested.
9. (C) Yo ass will git a ClassCastException whenever you try ta cast a object ta a
class of which it aint a instance. Chizzle C is tha only statement dat don't
attempt ta do all dis bullshit. Look all up in tha other chizzles: In chizzle A, b aint a instizzle of
SavingsAccount. In chizzle B, b aint a instizzle of CheckingAccount. In chizzle
D, s aint a instizzle of CheckingAccount. In chizzle E, c aint a instizzle of
SavingsAccount.
10. (0) It be OK ta use timsSavings n' daynasCheckin as parametas since each of
these is-a BankAccount object. Well shiiiit, it be also OK fo' timsSavings n' daynasChecking
to call tha transfer method (statements Pt II n' Pt III), since they inherit dis method
from tha BankAccount superclass.
11. (E) Statement I is false: A subclass must specify its own constructors. Otherwise
the default constructor of tha superclass will automatically be invoked. Y'all KNOW dat shit, muthafucka! Note
that statement Pt III is true: It be OK ta override private instizzle methods-they
can even be declared hood up in tha subclass implementation. I aint talkin' bout chicken n' gravy biatch. What aint OK is to
make tha access mo' restrictive, fo' example, ta override a hood method and
declare it private. .
12. (E) All of tha methodz up in a intercourse is by default hood (the hood keyword
aint needed) fo' realz. An abstract class can have both private n' hood methods.
13. (A) There is two quick tests you can do ta find tha answer ta dis question:
(1) Test tha is-a relationshizzle, namely tha parameta fo' printName is-a Bird?
and tha parameta fo' printBirdCall is-a Parrot?
(2) A reference cannot be cast ta suttin' it aint a instizzle of.
Choice A passes both of these tests: parrot2 is-a Bird, n' (Parrot) bird2
221
222 Chapta 3 Inheritizzle n' Polymorphism
is.a Parrot fo' realz. Also bird2 be a instizzle of a Parrot (as you can peep by looking
at tha right-hand side of tha assignment), so tha castin is erect. In
choice B printBirdCall (bird2) is wack cuz bird2 is.a Bird n' the
printBirdCaU method is expectin a Parrot. Therefore bird2 must be
downcast ta a Parrot fo' realz. Also, tha method call printName«Parrot) birdl)
fails cuz birdl be a instizzle of a Bird n' therefore cannot be cast
to a Parrot. In chizzle C, print Name (bird2) is erect: bird2 is.a Bird.
But fuck dat shiznit yo, tha word on tha street is dat printBirdCall (bird2) fails as already discussed. Y'all KNOW dat shit, muthafucka! In chizzle D,
(Parakeet) parrot1 be a incorrect cast: parrotl be a instizzle of a Parrot.
Note dat printBirdCall (parrot2) is OK since parrot2 is.a Parrot. In chizzle
E, (Owl) parrot2 be a incorrect cast: parrot2 be a instizzle of Parakeet. Note
that printBirdCall«Parakeet) parrot2) is erect: A Parakeet is.a Parrot,
and parrot2 be a instizzle of a Parakeet.
14. (A) Da only incorrect line is sl = freshly smoked up Solid("blob"): Yo ass can't create an
instizzle of a abstract class fo' realz. Abstract class references can, however, r~fer ta objects
of concrete (nonabstract) subclasses. Thus, tha assignments fo' s2 n' s3 are
OK. Note dat a abstract class reference can also be null, so tha final assignment,
though redundant, is erect.
15. (E) Da point of havin a abstract method is ta postpone until run time the
decision bout which subclass version ta call. This is what tha fuck polymorphizzle iscalling
the appropriate method at run time based on tha type of tha object.
16. (A) This be a example of polymorphism: Da erect volume method is selected
at run time. Da parameta expected fo' printVolume be a Solid reference,
which is what tha fuck it gets up in main (). Da reference sol will refer either ta a Sphere
or a RectangularPrizzle object dependin on tha outcome of tha coin flip. Right back up in yo muthafuckin ass. Since
a Sphere be a Solid n' a RectangularPrizzle be a Solid, there is ghon be no type mis-'
match when these is tha actual parametas up in tha printVolume method. Y'all KNOW dat shit, muthafucka! (Note:
Da Math. random method is discussed up in Chapta 4.)
17. (E) Each of chizzlez A though D represent Computable objects: It make sense
to add, subtract, or multiply two big-ass integers, two fractions, two irrational
numbers, n' two lengths. (One can multiply lengths ta git a area, fo' example.)
While it may make sense under certain circumstances ta add or subtract two bank
accounts, it do not make sense ta multiply them!
18. (C) Yo ass can declare a reference of type Player n' shit. What you cannot do is construct
an object of type Player n' shit. Da followin declarations is th~refore legal:
Smart Player s = freshly smoked up SmartPlayer()j
Player pi = Sj
Player p2 = freshly smoked up HumanPlayer()j
19. (C) Remember, ta implement tha Player intercourse a cold-ass lil class must provide implementations
for getMove n' updateDisplay. Da updateDisplay method is suitable
for all five game busted lyrics about. Y'all KNOW dat shit, muthafucka! Da git Move method returns a single integer,
which works well fo' tha High-Low game of chizzle A n' tha Chips game of
choice B. In Tic-Tac-Toe (choice D) n' Battleships (choice E) a move consists
of givin a grid location. I aint talkin' bout chicken n' gravy biatch. This can be provided by a single integer if tha grid locations
are numbered up in a unique way. It aint nuthin but not ideal yo, but certainly doable. In
the Chess game, however, a move cannot be busted lyrics bout by a single integer n' shit. The
player need ta specify both tha grid location he is movin tha piece ta n' which
Answers Explained
piece he is moving. Da git Move method would need ta be altered up in a way that
changes its return type. This make tha Player intercourse unsuitable.
20. (C) Segment Pt II has a error up in tha git Move calls. References c1 n' c2 is of
type Comparable, which don't contain a getMove method. Y'all KNOW dat shit, muthafucka! To erect these
statements a cold-ass lil cast is necessary:
x = «ExpertPlayer) c1).getMove();
and similarly fo' tha c2 call. Note dat c1. compareTo (c2) is fine, since
Comparable do contain tha compareTo method n' ExpertPlayer implements
Comparable. Right back up in yo muthafuckin ass. Segment ill fails cuz HumanPlayer do not implement
Comparable n' therefore aint gots a cold-ass lil compareTo method. Y'all KNOW dat shit, muthafucka! Note dat up in segment
I tha git Move calls is fine n' require no downcasting, since p1 n' p2 are
of type Player n' Player has tha git Move method.
21. (E) All implementations is erect. This aint a question bout whether it
is betta ta compare ExpertPlayers based on they ratings or they names muthafucka! One
might need a alphabetized list of playas, or one might need a list according
to ranking. In practice, tha program justification will instruct tha programmer
which ta use. Note dat segment Pt II is erect cuz compareTo don't need to
return lor -1 fo' realz. Any positizzle or wack integer is OK.
22. (B) Statement ill would be erect if it read as bigs up: While a cold-ass lil class may extend
just one class, it may implement mo' than one intercourse.
23. (A) There is no phat way ta write a cold-ass lil compareTo method fo' a Point class. Two
points (xl'Yl) n' (x2'Y2) is equal if n' only if Xl = X2 n' Yl = Y2. But if points
Pl n' P2 is not equal, what tha fuck will determine if Pl &lt; P2 or Pl &gt; P2, biatch? Yo ass could
try rockin tha distizzle from tha origin. I aint talkin' bout chicken n' gravy biatch. Define Pl &gt; P2 if n' only if OPl &gt; OP2,
and Pl &lt; P2, if n' only if OPl &lt; OP2, where 0 is (0,0). This definizzle means
that points (a,b) n' (b,a) is equal, which violates tha definizzle of equals!
Da problem is dat there is no way ta map tha two-dimensionizzle set of points
to a one-dimensionizzle distizzle function n' still be consistent wit tha definition
of equals. Da objects up in each of tha other classes can be compared without a
problem. In chizzle B, two Name objects can be ordered alphabetically. In chizzle
C, two Hoopty objects can be ordered by year or by price. In chizzle D, two Student
objects can be ordered by name or GPA. In chizzle E, two Employee objects can
be ordered by name or senioritizzle (date of hire).
24. (B) Here is tha hierarchy of classes:
Eliminizzle chizzle D which fails ta make DocStudent a subclass of Graduate. This
is a skanky design chizzle since a DocStudent is-a Graduate. Makin Student an
abstract class is desirable since tha methodz dat is common ta all hustlas can
223
224 Chapta 3 Inheritizzle n' Polymorphism
go up in there wit implementations provided. Y'all KNOW dat shit, muthafucka! Da method ta calculate tha GPA,
which differs among hustla types, is ghon be declared up in Student as a abstract
method. Y'all KNOW dat shit, muthafucka! Then unique implementations is ghon be provided up in both tha Graduate
and Undergraduate classes. Chizzle A be a skanky design cuz makin Student
an intercourse means dat all of its methodz will need ta be implemented up in both
the Undergraduate n' Graduate classes. Many of these methodz gonna git the
. same implementations fo' realz. As far as possible, you wanna arrange fo' classes ta inherit
common methodz n' ta stay tha fuck away from repeated code. Chizzle C is slightly inferior
to chizzle B cuz yo ass is holla'd at dat all hustlas is either graduates or undergraduates.
Havin tha Student class abstract guarantees dat you won't create an
instizzle of a Student (who is neither a graduate nor a undergraduate). Chizzle E
has a major design flaw: makin Graduate a abstract class means dat you can't
create any instancez of Graduate objects, n' you can put dat on yo' toast. Disasta playa! H tha keyword abstract is removed
from chizzle E, it becomes a gangbangin' fine design, as phat as dat up in chizzle B. Once
Student has implemented all tha common PersonalInformationmethods, these
are inherited by each of tha subclasses.
25. (B) Classes dat implement a intercourse must provide implementation code fo' all
methodz up in tha intercourse fo' realz. Addin method2 ta tha SomeName intercourse means that
all of dem classes need ta be rewritten wit implementation code fo' method2.
(This aint good-it violates tha sacred principle of code reusability, n' programmers
relyin on tha intercourse will squeal.) Chizzlez A, C, n' D is all
meaningless garbage. Chizzle E may be legit if there is some other error up in the
new class. Otherwise, as long as tha freshly smoked up class serves up implementation code for
both methodl n' method2, tha class will compile.
26. (B) Segment ill is wack cuz you can't construct a intercourse object. (Remember,
Comparable be a intercourse!) Segments I n' Pt II both work cuz the
minThree method is expectin three parameters, each of which be a Comparable.
Since Temperature implements Comparable, each of tha Temperature objects be a
Comparable n' can be used as a parameta up in dis method. Y'all KNOW dat shit, muthafucka! Note dat tha program
assumes dat tha compareTo method be able ta compare Temperature objects
with different scales. This be a internal detail dat would be dealt wit in
the compareTo method, n' hidden from tha client. When a cold-ass lil class implements
Comparable there be always a assumption dat tha compareTo method will be
implemented up in a reasonable way.
Some Standard Classes
 Da Object class
 Da Strin class
 Wrapper classes
THE Obj ect CLASS
Every Muthafucka whoz ass considaz arithmetical methodz of producing
random digits is, of course, up in a state of sin.
-Jizzy von Neumann (1951)
Chapta Goals
 Da Math class
 Random numbers
Da Universal Superclass
Think of Object as tha superclass of tha universe. Every class automatically extends
Object, which means dat Object be a gangbangin' finger-lickin' direct or indirect superclass of every last muthafuckin other class.
In a cold-ass lil class hierarchy tree, Object be all up in tha top:
Methodz up in Object
There is nuff methodz up in Object, all of dem inherited by every last muthafuckin other class. Right back up in yo muthafuckin ass. Since
Object aint a abstract class, all of its methodz have implementations. Da expectation
is dat these methodz is ghon be overridden up in any class where tha default implementation
is not suitable. Da required methodz up in tha AP Java subset is toString,
equals, n' hashCode (which is fo' Level AB only).
CHAPTER 4
225
226 Chapta 4 Some Standard Classes
THE toStrin METHOD
I hood Strin toString() I
This method returns a version of yo' object up in Strin form.
When you attempt ta print a object, tha inherited default toStrin method is
invoked, n' what tha fuck yo big-ass booty is ghon peep is tha class name followed by a G followed by a meaningless
number (the address up in memory of tha object). For example,
SavingsAccount s = freshly smoked up SavingsAccount(500);
System.out.println(s);
produces something. like
SavingsAccountGfea485c4
To have mo' meaningful output, you need ta override tha toStrin method for
your own classes. Even if yo' final program don't need ta output any objects, you
should define a toStrin method fo' each class ta help up in debugging.
Example 1
hood class OrderedPair
{
private double x;
private double y;
Ilconstructors n' other methods
1* Returns dis OrderedPair up in Strin form. *1
hood Strin toString()
{
return "(" + x +
}
}
Now tha statements
II , Pt II + y + ")";
OrderedPair p = freshly smoked up OrderedPair(7,10);
System.out.println(p);
will invoke tha overridden toStrin method n' produce output dat be lookin like an
ordered pair:
(7,10)
Example 2
For a BankAccount class tha overridden toStrin method may look suttin' like
this:
1* Returns dis BankAccount up in Strin form. *1
hood Strin toString()
{
return "Bank Account: balizzle = $" + myBalance;
}
Da statements
THE Object CLASS
BankAccount b = freshly smoked up BankAccount(600);
System . out.println(b) ;
will produce output dat be lookin like this:
Bank Account: balizzle = $600
NOTE
1. Da + sign be a cold-ass lil concatenation operator fo' strings (see p. 229).
2 fo' realz. Array objects is unusual up in dat they aint gots a toStrin method. Y'all KNOW dat shit, muthafucka! To
print tha elementz of a array, tha array must be traversed n' each element
must explicitly be printed.
THE equals METHOD
I hood boolean equals(Object other) I
All classes inherit dis method from tha Object class. Well shiiiit, it returns legit if dis object and
other is tha same object, false otherwise. Bein tha same object means referencing
the same memory slot. For example,
Date d1 = freshly smoked up Date(IJanuary", 14, 2001);
Date d2 = d1;
Date d3 = freshly smoked up Date("January", 14, 2001);
Da test if (d1.equals(d2)) returns true yo, but tha test if (d1.equals(d3)) returns
false, since d1 n' d3 do not refer ta tha same object. Often, as up in dis example, you
may want two objects ta be considered equal if they contents is tha same. In that
case, you gotta override tha equals method up in yo' class ta big up all dis bullshit. Right back up in yo muthafuckin ass. Some of
the standard classes busted lyrics bout lata up in dis chapta have overridden equals up in dis way.
Yo ass aint gonna be required ta write code dat overrides equals on tha AP exam.
NOTE
1. Da default implementation of equals is equivalent ta tha == relation fo' objects:
In tha Date example above, tha test if (d1 == d2) returns true; tha test
if (d1 == d3) returns false.
2. Da operators &lt;, &gt;, n' so on, is not overloaded up in Java. To compare objects,
one must use either tha equals method or tha compareTo method if tha class
implements tha Comparable intercourse (see p. 199).
THE hashCode METHOD
Every class inherits tha hashCode method from Object. Da value returned by
hashCode be a integer produced by some formula dat maps yo' object ta a address
in a hash table fo' realz. A given object must always produce tha same hash code fo' realz. Also, two objects
that is equal should produce tha same hash code; dat is, if obj 1. equals (obj2)
is true, then obj 1 n' obj2 should have tha same hash code. Note dat tha opposite is
not necessarily true yo. Hash codes do not gotta be unique-two objects wit tha same
hash code is not necessarily equal.
To maintain tha condizzle dat obj1.equals(obj2) is legit implies dat obj1 and
obj2 have tha same hash code, overridin equals means dat you should override
hashCode all up in tha same time. Yo ass aint gonna be required ta do dis on tha AP exam.
227
Do not use == ta test
objects fo' equality.
Use tha equals
method.
ABONLY
228 Chapta 4 Some Standard Classes
Yo ass do, however, need ta KNOW dat every last muthafuckin object be associated wit a integer
value called its hash code, n' dat objects dat is equal have tha same hash code.
THE Strin CLASS
Strin Objects
An object of type Strin be a sequence of charactas fo' realz. All strang literals, like fuckin "yikes muthafucka! ",
are implemented as instancez of dis class fo' realz. A strang literal consistz of zero or mo' characters,
includin escape sequences, surrounded by double quotes. (Da quotes is not
part of tha Strin object.) Thus, each of tha followin be a valid strang literal:
1111 //empty string
"2468"
"I must\n bounce back ta tha doggy den"
Strin objects is immutable, which means dat there be no methodz ta chizzle
them afta they've been constructed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Yo ass can, however, always create a freshly smoked up String
that be a mutated form of a existin String.
Constructin Strin Objects
A Strin object is unusual up in dat it can be initialized like a primitizzle type:
Strin s = "abc";
This is equivalent to
Strin s = freshly smoked up String("abc");
in tha sense dat up in both cases s be a reference ta a Strin object wit contents "abc"
(see Box on p. 230).
It be possible ta reassign a Strin reference:
Strin s = "John";
s = "Harry";
This is equivalent to
Strin s = freshly smoked up String("John");
s = freshly smoked up String("Harry");
Notice dat dis is consistent wit tha immutable feature of Strin objects, n' you can put dat on yo' toast. "John" has
not been chizzled; dat schmoooove muthafucka has merely been discarded hommie! Da fickle reference s now refers ta a
new String, "Harry". Well shiiiit, it be also OK ta reassign s as bigs up:
s = s + " Windsor";
s now refers ta tha object "Harry Windsor".
Here is other ways ta initialize Strin objects:
Strin sl = null; //sl be a null reference
Strin s2 = freshly smoked up String(); //s2 be a empty characta sequence
Strin state = "Alaska";
Strin dessert = "baked" + state; //dessert has value "baked Alaska"
THE Strin CLASS
Da Concatenation Operator
Da dessert declaration above uses tha concatenation operator, +, which operates on
Strin objects, n' you can put dat on yo' toast. Given two Strin operandz lhs n' rhs, lhs + rhs produces a single
Strin consistin of lhs followed by rhs. If either lhs or rhs be a object other
than a String, tha toStrin method of tha object is invoked, n' lhs n' rhs are
concatenated as before. If one of tha operandz be a Strin n' tha other be a primitive
type, then tha non-Strin operand is converted ta a String, n' concatenation occurs
as before. If neither lhs nor rhs be a Strin object, a error occurs yo. Here is some
examples:
int five = 5;
Strin state = "Hawaii-";
Strin tvShow = state + five + "-0"; //tvShow has value
//"Hawaii-5-0"
int x = 3, Y = 4;
Strin sum = x + y; //error: can't assign int 7 ta String
Suppose a Date class has a toStrin method dat outputs dates dat be lookin like this:
2/17/1948.
Date d1 = freshly smoked up Date(8, 2, 1947);
Date d2 = freshly smoked up Date(2, 17, 1948);
Strin s = "My fuckin birthdizzle is " + d2; lis has value
//"My fuckin birthdizzle is 2/17/1948"
Strin s2 = d1 + d2; //error: + not defined fo' objects
Strin s3 = d1.toString() + d2.toString(); //s3 has value
//8/2/19472/17/1948
Comparison of Strin Objects
There is two ways ta compare Strin objects:
1. Use tha equals method dat is inherited from tha Object class n' overridden
to do tha erect thang:
if (string1.equals(string2))
This returns legit if string1 n' string2 is identical strings, false otherWise.
2. Use tha compareTo method. Y'all KNOW dat shit, muthafucka! Da Strin class implements Comparable, which
means dat tha compareTo method is provided up in String. This method compares
strings up in doggtionary Oexicographical) order:
 If stringl. compareTo (string2) &lt; 0, then stringl precedes string2 in
the dictionary.
 If string1. compareTo (string2) &gt; 0, then string1 bigs up string2 in
the dictionary.
 If string1. compareTo (string2) == 0, then string1 n' string2 is identical.
(This test be a alternatizzle ta string1. equals (string2).)
Be aware dat Java is case-sensitive. Thus, if s1 is "cat" n' s2 is "Cat", s1. equals (s2)
will return false.
Charactas is compared accordin ta they posizzle up in tha ASCII chart fo' realz. All you
need ta know is dat all digits precede all capital letters, which precede all lowercase
229
230 Chapta 4 Some Standard Classes
letters. Thus "5" comes before "R", which comes before "a". Two strings is compared
as bigs up: Start all up in tha left end of each strang n' do a cold-ass lil character-by-character
comparison until you reach tha straight-up original gangsta characta up in which tha strings differ, tha kth character,
say. If tha kth characta of sl comes before tha kth characta of s2, then sl will
come before s2, n' vice versa. If tha strings have identical characters, except dat sl
terminates before s2, then sl comes before s2 yo. Here is some examples:
Strin sl = "HOT", s2 = "HOTEL", s3 = "dog";
if (sl.compareTo(s2) &lt; 0» //true, sl terminates first
if (sl.compareTo(s3) &gt; 0» //false, "H" comes before "d"
Don't Use == ta Test Strings!
Da expression if (string1 == string2) tests whether string1
and string2 is tha same reference. Well shiiiit, it do not test tha actual
strings. Usin == ta compare strings may lead ta unexpected
results.
Example 1
Strin s = "oh no!";
Strin t = "oh no!";
if (s == t) ...
Da test returns legit even though it appears dat s n' t is different
references. Da reason is dat fo' efficiency Java make only
one Strin object fo' equivalent strang literals. This is safe up in that
a Strin cannot be altered.
Example 2
Strin s = "oh no!";
Strin t = freshly smoked up String("oh no! ");
if (s == t) ...
Da test returns false cuz use of freshly smoked up creates a freshly smoked up object, and
s n' t is different references up in dis example!
Da moral of tha story, biatch? Use equals not == ta test strings. It
always do tha right thang.
Other Strin Methods
Da Java Strin class serves up nuff methods, only a lil' small-ass number of which is in
the AP Java subset. In addizzle ta tha constructors, comparison methods, n' concatenation
operator + discussed so far, you should know tha followin methods:
lint lengthO I
Returns tha length of dis string.
Wrapper Classes
I Strin substring(int startIndex) I
Returns a freshly smoked up strang dat be a substrin of dis string. Da substrin starts wit the
characta at start Index n' extendz ta tha end of tha string. Da first characta be at
index zero. Da method throws a StringIndexOutOfBoundsException if start Index
is wack or larger than tha length of tha string.
Strin substring(int start Index , int endIndex)
Returns a freshly smoked up strang dat be a substrin of dis string. Da substrin starts at index
startIndex n' extendz ta tha characta at endIndex-l, (Think of it dis way:
startIndex is tha straight-up original gangsta characta dat you want; endIndex is tha straight-up original gangsta characta dat you
don't want.) Da method throws a StringIndexOutOfBoundsException if start Index
is negative, or endIndex is larger than tha length of tha string, or startIndex is larger
than endIndex.
lint indexOf(Strin str) I
Returns tha index of tha straight-up original gangsta occurrence of str within dis string. If str aint a
substrin of dis string, -1 is returned. Y'all KNOW dat shit, muthafucka! Da method throws a NullPointerException
if str is null.
Here is some examples:
"unhappy".substring(2)
"cold".substring(4)
"cold".substring(5)
"strawberry".substring(5,7)
"crayfish".substring(4,8)
"crayfish".substring(4,9)
"crayfish".substring(5,4)
Strin s = "funnyfarm" j
int x = s.indexOf("farm");
x = s.indexOf("farmer")j
int y = s.length();
WRAPPER CLASSES
Ilreturns "happy"
Ilreturns "" (empty string)
IIStringIndexOutOfBoundsException
Ilreturns "be"
Ilreturns "fish"
IIStringIndexOutOfBoundsException
IIStringIndexOutOfBoundsException
Ilx has value 5
Ilx has value -1
Ily has value 9
A wrapper class takes either a existin object or a value of primitizzle type, "wraps" or
"boxes" it up in a object, n' serves up a freshly smoked up set of methodz fo' dat type. Da point of
a wrapper class is ta provide extended capabilitizzles fo' tha boxed quantity:
 It can be used up in generic Java methodz dat require objects as parametas .
 It can be used up in Java container classes dat require tha shit be objects (see
Chapta 11).
In each case, tha wrapper class allows
1. Construction of a object from a single value (wrappin or boxin tha primitive
in a wrapper object).
2. Retrieval of tha primitizzle value (unwrappin or unboxin from tha wrapper
object).
231
232 Chapta 4 Some Standard Classes
Java serves up a wrapper class fo' each of its primitizzle types. Da two dat you
should know fo' tha AP exam is tha Integer n' Double classes.
Da Integer Class
Da Integer class wraps a value of type int up in a object fo' realz. An object of type Integer
gotz nuff just one instizzle variable whose type is into
Here is tha Integer methodz you should know fo' tha AP exam:
Itnteger(int value) I
Constructs a Integer object from a tha fuck into (Boxing.)
lint compareTo(Object other) I
If other be a Integer, compareTo returns 0 if tha value of dis Integer is equal ta the
value of other, a wack integer if it is less than tha value of other, n' a positive
integer if it is pimped outa than tha value of other.
NOTE
1. Da Integer class implements Comparable.
2. Da compareTo method throws a ClassCastException if tha argument other
is not a Integer.
lint intValueO I
Returns tha value of dis Integer as a tha fuck into (Unboxing.)
I boolean equals(Object obj) I
Returns legit if n' only if dis Integer has tha same ol' dirty int value as obj.
NOTE
1. This method overrides equals up in class Object.
2. This method throws a ClassCastException if obj aint a Integer.
I Strin toString() I
Returns a Strin representin tha value of dis Integer.
Here is some examplez ta illustrate tha Integer methods:
Integer intObj = freshly smoked up Integer(6);
int j = intObj.intValue();
System.out.println("Integer value
//calls toString() fo' intObj
//output is
Integer value is 6
//boxes 6 up in Integer object
//unboxes 6 from Integer object
is Pt II + intObj);
Wrapper Classes 233
Object object = freshly smoked up Integer(5); Pt IIInteger be a subclass of Object
Integer intObj2 = freshly smoked up Integer(3);
int k = intObj2.intValue();
if (intObj.equals(intObj2» Pt IIOK, evaluates ta false
if (intObj.intValue() == intObj2.intValue(»)
IIOK, since comparin primitizzle types
if (k.equals(j)) Ilerror, k n' j not objects
if «intObj.intValue()).compareTo(intObj2.intValue()) &lt; 0)
Ilerror, can't use compareTo on primitizzle types
if (intObj.compareTo(object) &lt; 0) Pt IIOK
if (object.compareTo(intObj) &lt; 0) Ilerror, no compareTo up in Object
if «(Integer) object).compareTo(intObj) &lt; 0) Pt IIOK
Da Double Class
Da Double class wraps a value of type double up in a object fo' realz. An object of type Double
gotz nuff just one instizzle variable whose type is double.
Da methodz you should know fo' tha AP exam is analogous ta dem fo' type
Integer.
I Double (double value) I
Constructs a Double object from a thugged-out double. (Boxing.)
I double doubleValue() I
Returns tha value of dis Double as a thugged-out double. (Unboxing.)
lint compareTo(Object other) I
Da Double class implements Comparable. If tha argument other aint a Double, the
compareTo method will throw a ClassCastException. I aint talkin' bout chicken n' gravy biatch. If other be a Double, compareTo
returns 0 if tha value of dis Double is equal ta tha value of other, a wack integer if
it is less than tha value of other, n' a positizzle integer if it is pimped outa than tha value of
other.
I boolean equals(Object obj) I
This method overrides equals up in class Object n' throws a ClassCastException if
obj aint a Double. Otherwise it returns legit if n' only if dis Double has tha same
double value as obj.
I Strin toString() I
Returns a Strin representin tha value of dis Double.
234
Remember:
Integer, Double,
and Strin is all
Comparable.
Here is some examples:
Double dObj = freshly smoked up Double(2.5);
double d = dObj.doubleValue();
Chapta 4 Some Standard Classes
//boxes 2.5 up in Double object
//unboxes 2.5 from Double object
Object object = freshly smoked up Double(7.3); //Double be a subclass of Object
Object intObj = freshly smoked up Integer(4);
if (dObj.compareTo(object) &gt; 0) //OK
if (dObj.compareTo(intObj) &gt; 0) //ClassCastException
//can't compare Integer ta Double
NOTE
1. Integer n' Double objects is immutable: There is no mutator methodz in
the classes.
2. Right back up in yo muthafuckin ass. See tha sections on ArrayLists (p. 298) n' Collections (Chapta 11) fo' a gangbangin' finger-lickin' rap
of auto-boxin n' -unboxing. This be a freshly smoked up feature up in Java 5.0 dat is
very useful n' convenient. Well shiiiit, it will not, however, be tested on tha AP exam.
THE !lath CLASS
This class implements standard mathematical functions like fuckin absolute value, square
root, trigonometric functions, tha log function, tha juice function, n' so on. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it also
gotz nuff mathematical constants like fuckin 1T: n' e.
Here is tha functions you should know fo' tha AP exam:
I static int abs(int x) I
Returns tha absolute value of integer x.
I static double abs(double x) I
Returns tha absolute value of real number x.
static double pow (double base, double exp)
Returns baseexP Assumes base&gt; 0, or base = 0 n' exp &gt; 0, or base &lt; 0 n' exp is
an integer.
I static double sqrt(double x) I
Returns .;x, x 2: o.
I static double random() I
Returns a random number r, where 0.0 ~ r &lt; 1.0. (See tha next section, Random
Numbers.)
All of tha functions n' constants is implemented as static methodz n' variables,
which means dat there be no instancez of Math objects, n' you can put dat on yo' toast. Da methodz is invoked
usin tha class name, Math, followed by tha dot operator.
THE Math CLASS
Here is some examplez of mathematical formulas n' tha equivalent Java statements.
1. Da relationshizzle between tha radius n' area of a cold-ass lil circle:
r = JA/n
In code:
radius = Math.sqrt(area / Math.PI);
2. Da amount of scrilla A up in a account afta ten years, given a original gangsta deposit
of P n' a interest rate of 5% compounded annually, is
A = P(1.05)1o
In code:
a = p * Math.pow(1.05, 10);
3. Da distizzle D between two points P(xp,Y) n' Q(xQ'Y) on tha same horizontalline
is
In code:
d = Math.abs(xp - xq);
NOTE
A freshly smoked up feature of Java 5.0, tha static import construct, allows you ta use tha static
thugz of a cold-ass lil class without tha class name prefix. For example, tha statement
import static java.lang.Math.*;
allows use of all Math methodz n' constants without tha Math prefix. Thus, tha statement
in formula 1 above could be written
radius = sqrt(area / PI);
Static imports is not part of tha AP subset.
Random Numbers
RANDOM REALS
Da statement
double r = Math.random();
produces a random real number up in tha range 0.0 ta 1.0, where 0.0 is included n' 1.0
is not.
This range can be scaled n' shifted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. On tha AP exam yo big-ass booty is ghon be sposed ta fuckin write
algebraic expressions involvin Math. random 0 dat represent linear transformations
of tha original gangsta interval 0.0 ~ x &lt; 1.0.
235
236 Chapta 4 Some Standard Classes
Example 1
Produce a random real value x up in tha range 0.0 ~ x &lt; 6.0.
double x = 6 * Math.random();
Example 2
Produce a random real value x up in tha range 2.0 ~ x &lt; 3.0.
double x = Math.random() + 2;
Example 3
Produce a random real value x up in tha range 4.0 ~ x &lt; 6.0.
double x = 2 * Math.random() + 4;
In general, ta produce a random real value up in tha range lowValue ~ x &lt; highValue:
double x = (highValue - lowValue) * Math.random() + lowValue;
RANDOM INTEGERS
Usin a cold-ass lil cast ta int, a scalin factor, n' a gangbangin' finger-lickin' dirty-ass shiftin value, Math.random() can be used to
produce random integers up in any range.
Example 1
Produce a random integer, from 0 ta 99.
int num = (int) (Math.random() * 100);
In general, tha expression
(int) (Math.random() * k)
produces a random int up in tha range 0, 1, ... ,k - 1, where k is called tha scalin factor.
Note dat tha cast ta int truncates tha real number Math. random 0 * k.
Example 2
Produce a random integer, from 1 ta 100.
int num = (int) (Math.random() * 100) + 1;
In general, if k be a scalin factor, n' p be a gangbangin' finger-lickin' dirty-ass shiftin value, tha statement
int n = (int) (Math.random() * k) + p;
produces a random integer n up in tha range p, p + 1, ... , p + (k - 1).
Example 3
Produce a random integer from 5 ta 24.
int num = (int) (Math.random() * 20) + 5;
NOTE
There is 20 possible integers from 5 ta 24, inclusive.
THE Math CLASS
Chapta Summary
All hustlas should know bout overridin tha equals n' toStrin methodz of
the Object class. Level AB should KNOW bout hashCode. Everyone should be
familiar wit tha Integer n' Double wrapper classes.
Know tha AP subset methodz of both tha Strin n' Math classes, especially tha use
of Math. random () fo' generatin both random reals n' random integers. Be shizzle to
check where exceptions is thrown up in tha Strin methods.
237
238 Chapta 4 Some Standard Classes
MULTIPLE-CHOICE QUESTIONS ON STANDARD
CLASSES
1 yo. Here be a program segment ta find tha quantitizzle baseeXP Both base n' exp are
entered all up in tha keyboard.
System.out.println("Enta base n' exponent: Pt II):
double base = IO.readDouble(): Ilread user input
double exp = IO.readDouble(): Ilread user input
1* code ta find power, which equals baseexp *1
System.out.print(base + Pt II raised ta tha juice Pt II + exp):
System.out.println(" equals Pt II + power):
}
Which be a cold-ass lil erect replacement for
1* code ta find power, which equals baseexP *I?
I double power:
Math m = freshly smoked up Math():
power = m.pow(base, exp):
II double power;
power = Math.pow(base, exp):
III int power;
power = Math.pow(base, exp):
(A) I only
(B) Pt II only
(C) Pt III only
(D) I n' Pt II only
(E) I n' Pt III only
Multiple-Choice Thangs on Standard Classes
2. Consider tha squareRoot method defined below:
hood Double squareRoot(Double d)
IIPrecondition: value of d &gt;= O.
IIPostcondition: Returns a Double whose value is tha square
II root of tha value represented by d.
{
I * implementation code *1
}
Which 1* implementation code *1 satisfies tha postcondition?
I double x = d.doubleValue();
x = Math.sqrt(x);
return new Double(x);
II return new Double(Math.sqrt(d.doubleValue(»);
III return «Double) Math).sqrt(d.doubleValue(»;
(A) I only
(B) I n' Pt II only
(C) I n' Pt III only
(D) Pt II n' Pt III only
(E) I, Pt II, n' Pt III
3 yo. Here is some examplez of wack numbers rounded ta tha nearest integer.
Negatizzle real number
-3.5
-8.97
-5.0
-2.487
-0.2
Refer ta tha declaration
double d = -4.67;
Rounded ta nearest integer
-4
-9
-5
-2
o
Which of tha followin erectly roundz d ta tha nearest integer?
(A) int rounded = Math.abs(d);
(B) int rounded = (int) (Math. random () * d);
(C) int rounded = (int) (d - 0.5);
(D) int rounded = (int) (d + 0.5);
(E) int rounded = Math.abs«int) (d - 0.5»;
239
240 Chapta 4 Some Standard Classes
4 fo' realz. A program is ta simulate plant game under harsh conditions. In tha program, plants
die randomly accordin ta some probabilitizzle yo. Here is part of a Plant class defined
in tha program.
hood class Plant
{
}
private double myProbDeath; Ilprobabilitizzle dat plant dies,
Ilreal number between 0 n' 1
II other private instizzle variables
hood Plant (double probDeath, &lt; other parameters»
{
myProbDeath = probDeath;
&lt; initialization of other instizzle variablez &gt;
}
Ilplant dies
hood void die()
{
}
I * statement ta generate random number * I
if (f * test ta determine if plant takes a thugged-out dirt nap * /)
&lt; code ta implement plantz dirtnap&gt;
else
&lt; code ta make plant continue living&gt;
Ilother methods
Which of tha followin is erect replacements for
(1) 1* statement ta generate random number *1 and
(2) 1* test ta determine if plant takes a thugged-out dirt nap */?
(A) (1) double x = Math. random 0 ;
(2) x == myProbDeath
(B) (1) double x = (int) (Math. random 0 ) ;
(2) x &gt; myProbDeath
(C) (1) double x = Math.random();
(2) x &lt; myProbDeath
(0) (1) int x = (int) (Math.random()) * 100);
(2) x &lt; (int) myProbDeath
(E) (1) int x = (int) (Math.random()) * 100) + 1;
(2) x == (int) myProbDeath
Multiple-Choice Thangs on Standard Classes
5 fo' realz. A program simulates fifty slipz of paper, numbered 1 all up in 50, placed up in a
bowl fo' a raffle drawing. Which of tha followin statements stores up in balla a
random integer from 1 ta 50?
(A) int balla = (int) (Math.randomO * 50) + 1;
(B) int balla = (int) (Math.random() * 50);
(C) int balla = (int) (Math.random() * 51);
0) int balla = (int) (Math.random() * 51) + 1;
(E) int balla = (int) (1 + Math.random() * 49);
6. Consider tha code segment
Integer i = freshly smoked up Integer(20);
1* mo' code *1
Which of tha followin replacements fo' 1* mo' code *1 erectly sets i ta have
an integer value of 25?
I i = freshly smoked up Integer(25);
II i.intValue() = 25;
III Integer j = freshly smoked up Integer(25);
i = j;
(A) I only
(B) Pt II only
(C) Pt III only
0) I n' Pt III only
(E) Pt II n' Pt III only
7. Consider these declarations:
Integer intOb = freshly smoked up Integer(3);
Object ob = freshly smoked up Integer(4);
Double doubOb = freshly smoked up Double(3.0);
Which of tha followin aint gonna cause a error?
(A) if «(Integer) ob.compareTo(intOb) &lt; 0)
(B) if (ob.compareTo(intOb)' &lt; 0) ...
(C) if (intOb.compareTo(doubOb) &lt; 0)
0) if (doubOb.compareTo(intOb) &lt; 0)
(E) if (intOb.compareTo(ob) &lt; 0) ...
241
242
8. Refer ta these declarations:
Integer k = freshly smoked up Integer(S)j
Integer m = freshly smoked up Integer(4)j
Which test aint gonna generate a error?
Chapta 4 Some Standard Classes
I if (k. intValue 0 == m. intValue 0) .. ,.
II if «k.intValue()).equals(m.intValue())) .. .
III if «k.toString()).equals(m.toString())) .. .
(A) I only
(B) Pt II only
(C) Pt III only
(0) I n' Pt III only
(E) I, Pt II, n' Pt III
9. Consider tha code fragment
Object intObj = freshly smoked up Integer(9)j
System.out.println«String) intObj)j
What tha fuck iz ghon be output as a result of hustlin tha fragment?
(A) No output fo' realz. A ClassCastException is ghon be thrown.
(B) No output fo' realz. An Ari thmeticException is ghon be thrown.
(C) 9
(0) "9"
(E) nine
10. Consider these declarations:
Strin sl = "crab" j
Strin s2 = freshly smoked up String("crab")j
Strin s3 = sl j
Which expression involvin these strings evaluates ta true?
I sl == s2
II s1.equals(s2)
III s3.equals(s2)
(A) I only
(B) Pt II only
(C) Pt II n' Pt III only
(0) I n' Pt II only
(E) I, Pt II, n' Pt III
Multiple-Choice Thangs on Standard Classes 243
11. Right back up in yo muthafuckin ass. Suppose dat strA = "TOMATO", strB = "tomato", n' strC = "tom". Given
that "A" comes before "a" up in doggtionary order, which is true?
(1\) strA.compareTo(strB) &lt; 0 &amp;&amp; strB.compareTo(strC) &lt; 0
(B) strB.compareTo(strA) &lt; 0 I I strC.compareTo(strA) &lt; 0
(C) strC.compareTo(strA) &lt; 0 &amp;&amp; strA.compareTo(strB) &lt; 0
0) !(strA.equals(strB» &amp;&amp; strC.compareTo(strB) &lt; 0
(E) !(strA.equals(strB» &amp;&amp; strC.compareTo(strA) &lt; 0
12. This question refers ta tha followin declaration:
Strin line = "Some mo' wack-ass shiznit on strings!";
lithe lyrics is separated by a single space
What strang will str refer ta afta execution of tha following?
int x = line.indexOf("m");
Strin str = line.substring(10, 15) + line.substring(25, 25 + x);
(1\) "sillyst"
(B) "sillystr"
(C) "silly st"
0) "silly str"
(E) "sillystrin"
13. Refer ta tha followin method:
hood static Strin weirdString(Strin s, Strin sub)
{
}
Strin temp;
Strin w = ""; Ilempty string
for (int i = 0; i &lt; s.lengthO; i++)
{
}
temp = s.substring(i, i + 1);
if (temp.compareTo(sub) &lt; 0)
w = w + temp;
return w;
What will weirdStr contain afta tha followin code is executed?
Strin str = "conglomeration";
Strin weirdStr = weirdString(str, "m");
(1\) "cglmeai"
(B) "cgleai"
(C) "coglloeratio"
0) "onomrton"
(E) No value. Right back up in yo muthafuckin ass. StringlndexOutOfBoundsException.
244 Chapta 4 Some Standard Classes
14 fo' realz. A program has a Strin variable fullName dat stores a gangbangin' first name, followed by
a space, followed by a last name. There is no spaces up in either tha straight-up original gangsta or last
names yo. Here is some examplez of fullName joints: "Anthony Coppola", "Jimmy
Carroll", n' "Tomothy DeWire". Consider dis code segment dat extracts tha last
name from a gangbangin' fullName variable, n' stores it up in lastName wit no surrounding
blanks: .
int k = fullName.indexOf(" "); Ilfind index of blank
Strin lastName = 1* expression *1
Which be a cold-ass lil erect replacement fo' 1* expression *I?
I fullName.substring(k);
IT fullName.substring(k + 1);
III fullName.substring(k + 1, fullName.length(»;
(A) I only
(B) IT only
(C) monly
(0) IT n' m only
(E) I n' m only
15. One of tha rulez fo' convertin Gangsta ta Pig Latin states: If a word begins with
a consonant, move tha consonant ta tha end of tha word n' add "ay". Thus
"dog" becomes "ogday," n' "crisp" becomes "rispcay". Right back up in yo muthafuckin ass. Suppose s be a String
containin a Gangsta word dat begins wit a cold-ass lil consonant. Which of tha following
creates tha erect correspondin word up in Pig Latin, biatch? Assume tha declarations
Strin ayStrin = "ay";
Strin pigString;
(A) pigStrin = s.substring(O,
+ ayStringj
(B) pigStrin = s.substring(l,
+ ayStringj
(C) pigStrin = s.substring(O,
+ ayStringj
(0) pigStrin = s.substring(l,
+ ayStringj
s.lengthO) + s.substring(O,l)
s.lengthO) + s.substring(O,O)
s .lengthO-l) + s.substring(O,l)
s .lengthO-l) + s.substring(O,O)
(E) pigStrin = s.substring(l, s.length(» + s.substring(O,l)
+ ayStringj
Multiple-Choice Thangs on Standard Classes
16. This question refers ta tha getStrin method shown below:
hood static Strin getString(Strin sl, Strin s2)
{
int index = sl.indexOf(s2);
return sl.substring(index, index + s2.length(»;
}
Which is legit bout getString, biatch? It may return a strang that
I Is equal ta s2.
II Has no charactas up in common wit s2.
III Is equal ta s 1.
(A) I n' Pt III only
(B) Pt II n' Pt III only
(C) I n' Pt II only
(D) I, Pt II, n' Pt III
(E) None is true.
17. Consider dis method:
hood static Strin doSomething(Strin s)
{
}
final Strin BLANK = " ";
Strin str = "";
Strin temp;
//BLANK gotz nuff a single space
//empty string
for (int i = 0; i &lt; s.length(); i++)
{
}
temp = s.substring(i, i + 1);
if (l(temp.equals(BLANK»)
str += temp;
return str;
Which of tha followin is da most thugged-out precise description of what tha fuck doSomethang do?
(A) It returns s unchanged.
(B) It returns s wit all its blanks removed.
(C) It returns a Strin dat is equivalent ta s wit all its blanks removed.
(D) It returns a Strin dat be a exact copy of s.
(E) It returns a Strin dat gotz nuff s . length 0 blanks.
245
246 Chapta 4 Some Standard Classes
Thangs 18-20 refer ta tha classes Posizzle n' Posi tionTest below.
hood class Posizzle implements Comparable
{
}
private int myRow, myCol:
1* myRow n' myCol is both &gt;= 0 except in
* tha default constructor where they is initialized ta -1 *1
hood Position()
{
Ilconstructor
}
myRow = -1:
myCol = -1:
hood Position(int r, int c)
{
}
myRow = r;
myCol = c;
1* Returns row of Position. I aint talkin' bout chicken n' gravy biatch. *1
hood int getRow()
{ return myRow: }
1* Returns column of Position. I aint talkin' bout chicken n' gravy biatch. *1
hood int getCol()
{ return myCol: }
Ilconstructor
1* Returns Posizzle uptown of (up from) dis position. I aint talkin' bout chicken n' gravy biatch. *1
hood Posizzle north()
{ return new Position(myRow - 1, myCol): }
IISimilar methodz south, eastside, n' westside
1* Compares dis Posizzle ta another Posizzle object.
* Returns -1 (less than), 0 (equals), or 1 (greata than). *1
hood int compareTo(Object 0)
{
}
Posizzle p = (Position) 0:
if (this.getRow() &lt; p.getRow() I I this.getRow() == p.getRow()
&amp;&amp; this.getCol() &lt; p.getCol(»
return -1:
if (this.getRow() &gt; p.getRow() I I this.getRow() == p.getRow()
&amp;&amp; this.getCol() &gt; p.getCol(»
return 1:
return 0; Ilrow n' col both equal
1* Returns strang form of Position. I aint talkin' bout chicken n' gravy biatch. *1
hood Strin toString()
{ return "(" + myRow + "," + myCol + 11)11: }
Multiple-Choice Thangs on Standard Classes
hood class PositionTest
{
}
hood static void main(String[] args)
{
}
Posizzle pl = freshly smoked up Position(2. 3);
Posizzle p2 = freshly smoked up Position(4. 1);
Posizzle p3 = freshly smoked up Position(2. 3);
//tests ta compare positions
18. Which is legit bout tha value of pl. compareTo (p2)?
(A) It equals true.
(B) It equals false.
(C) It equals o.
(0) It equals 1.
(E) It equals -1.
19. Which boolean expression bout pl n' p3 is true?
I pl == p3
II p1.equals(p3)
III p1. compareTo (p3) == 0
(A) I only
(B) Pt II only
(C) Pt III only
(0) Pt II n' Pt III only
(E) I, Pt II, n' Pt III
247
248 Chapta 4 Some Standard Classes
20. Da Posizzle class is modified so dat tha equals n' hashCode methodz of class
Object is overridden. I aint talkin' bout chicken n' gravy biatch yo. Here is tha implementations:
1* Returns legit if dis Posizzle equals another Position
* object. false otherwise. *1
hood boolean equals(Object 0)
{
Posizzle p = (Position) 0;
return p.myRow =- myRow &amp;&amp; p.myCol == myCol;
}
1* Returns a hashCode fo' dis Position. I aint talkin' bout chicken n' gravy biatch. *1
hood int hashCode()
{ return myRow * 10 + myCol; }
Which is false bout tha hashCode method?
I Every Posizzle object has exactly one hashCode value.
II For two Posizzle objects pl n' p2, if pl. equals (p2) is true, then pl and
p2 have tha same hashCode value.
ill A given hashCode value correspondz ta exactly one Posizzle object.
(A) I only
(B) Pt II only
(C) monly
(D) I n' Pt II only
(E) I, Pt II, n' m
Thangs 21 n' 22 deal wit tha problem of swappin two integer joints, n' you can put dat on yo' toast. Three
methodz is proposed ta solve tha problem, rockin primitizzle int types, Integer objects,
and IntPair objects, where IntPair is defined as bigs up:
hood class IntPair
{
}
private int firstValue;
private int secondValue;
hood IntPair(int first. int second)
{
}
firstValue = first;
secondValue = second;
hood int getFirst()
{ return firstValue; }
hood int getSecond()
{ return secondValue; }
hood void setFirst(int a)
{ firstValue = a; }
hood void setSecond(int b)
{ secondValue = b;}
Multiple-Choice Thangs on Standard Classes
21 yo. Here is three different swap methods, each intended fo' use up in a cold-ass lil client program.
I hood static void swap(int a, int b)
{
}
int temp = a;
a = b;
b = temp;
IT hood static void swap(Integer obj_a, Integer obj_b)
{
}
Integer temp = freshly smoked up Integer(obj_a.intValue(»;
obj_a = obj_b;
obj_b = temp;
III hood static void swap(IntPair pair)
{
}
int temp = pair.getFirst();
pair.setFirst(pair.getSecond(»;
pair.setSecond(temp);
When erectly used up in a cold-ass lil client program wit appropriate parameters, which
method will swap two integers, as intended?
(A) I only
(B) IT only
(C) ill only
(D) IT n' ill only
(E) I, IT, n' ill
249
250 Chapta 4 Some Standard Classes
22. Consider tha followin program dat uses tha IntPair class:
hood class TestSwap
{
}
hood static void swap(IntPair pair)
{
}
int temp = pair.getFirst()j
pair.setFirst(pair.getSecond(»j
pair.setSecond(temp)j
hood static void main(String[] args)
{
int x = 8, Y = 6j
1* code ta swap x n' y *1
}
Which be a cold-ass lil erect replacement fo' 1* code ta swap x n' y */?
I IntPair iPair = freshly smoked up IntPair(x, y) ;
swap (x , y)j
x = iPair.getFirst()j
y = iPair.getSecond();
II IntPair iPair = freshly smoked up IntPair(x, y) j
swap(iPair);
x = iPair.getFirst();
y = iPair.getSecond();
m IntPair iPair = freshly smoked up IntPair(x, y)j
swap(iPair);
x = iPair.setFirst()j
y = iPair.setSecond();
(A) I only
(B) Pt II only
(C) monly
(D) Pt II n' m only
(£) None is erect.
Multiple-Choice Thangs on Standard Classes
Refer ta tha Name class below fo' Thangs 23 n' 24.
hood class Name implements Comparable
{
}
private Strin firstName;
private Strin lastName;
hood Name(Strin first, Strin last) Pt II constructor
{
}
firstName = first;
lastName = last:
hood Strin toString()
{ return firstName + Pt II Pt II + lastName; }
hood boolean equals(Object obj)
{
}
Name n = (Name) obj;
return n.firstName.equals(firstName) &amp;&amp;
n.lastName.equals(lastName);
hood int hashCode()
{ 1* implementation not shown *1 }
hood int compareTo(Object obj)
{
}
Name n = (Name) obj;
1* mo' code *1
251
252 Chapta 4 Some Standard Classes
23. Da compareTo method implements tha standard name-orderin algorithm where
last names take precedence over first names. Lexicographic or doggtionary ordering
of Strings is used. Y'all KNOW dat shit, muthafucka! For example, tha name Scott Dentes comes before Nick
Elser, n' Adam Cooper comes before Sara Cooper.
Which of tha followin be a cold-ass lil erect replacement fo' 1* mo' code */?
lint lastComp = lastName.compareTo(n.lastName);
if (lastComp != 0)
return lastComp;
else
return firstName.compareTo(n.firstName);
IT if (lastName.equals(n.lastName»
return firstName.compareTo(n.firstName);
else
return 0;
III if (!(lastName.equals(n.lastName»)
return firstName.compareTo(n.firstName);
else
return lastName.compareTo(n.lastName);
(A) I only
(B) IT only
(C) Pt III only
(0) I n' IT only
(E) I, IT, n' Pt III
24. Which statement bout tha Name class is false?
(A) Name objects is immutable.
(B) It be possible fo' tha methodz up in Name ta throw a NullPointerException.
(C) Da hashCode method should be redefined since tha Name class redefines the
equals method.
(0) Da compareTo method throws a run-time exception if tha parameta is null
or tha parameta is incompatible wit Name objects.
(E) Since tha Name class implements Comparable, it must provide a implementation
for a equals method.
Answers Explained
~. ;'-.i- .,,' ..
ANSWER KEY
1. B 9 fo' realz. A 17. C
2. B 10. C 18. E
3. C 11. D 19. C
4. C 12 fo' realz. A 20. C
5 fo' realz. A 13. B 21. C
6. D 14. D 22. B
7. E 15. E 23 fo' realz. A
8. D 16 fo' realz. A 24. E
ANSWERS EXPLAINED
1. (B) All tha Math class methodz is static methods, which means there is 'no instance
of a Math object dat calls tha method. Y'all KNOW dat shit, muthafucka! Da method is invoked rockin the
class name, Math, followed by tha dot operator. Shiiit, dis aint no joke. Thus segment Pt II is erect, and
segment I is incorrect. Right back up in yo muthafuckin ass. Segment Pt III'ma cause a error: Since tha parametas of
pow iz of type double, tha result should be stored up in a thugged-out double.
2. (B) Da Math. sqrt method must be invoked on a primitizzle type double, which is
the reason d. Y'all KNOW dat shit, muthafucka! doubleValue 0 is needed. Y'all KNOW dat shit, muthafucka! A erect segment must create a Double
object rockin new, which eliminates segment Pt III. Right back up in yo muthafuckin ass. Segment Pt III is egregiously bad:
It tries ta cast Math ta Double. But Math aint a object son! Math. sqrt be a static
method.
3. (C) Da value -4.67 must be rounded ta -5. Right back up in yo muthafuckin ass. Subtractin 0.5 gives a value of
-5.17. Castin ta int truncates tha number (chops off tha decimal part) and
leaves a value of -5. None of tha other chizzlez produces -5. Chizzle A gives the
absolute value of d: 4.67. Chizzle B be a incorrect use of Random. Da parameter
for nextInt should be a integer n, n ~ 2. Da method then returns a random
int k, where 0 ~ k &lt; n. I aint talkin' bout chicken n' gravy biatch. Chizzle D is tha way ta round a positizzle real number to
the nearest integer n' shit. In tha actual case it produces -4. Chizzle E gives tha absolute
, value of -5, namely 5.
4. (C) Da statement double x = Math. random 0 ; generates a random double in
the range 0 ~ x &lt; 1. Right back up in yo muthafuckin ass. Suppose myProbDeath is 0.67, or 67% fo' realz. Assumin dat random
doublez is uniformly distributed up in tha interval, one can expect dat 67% of
the time x is ghon be up in tha range 0 ~ x &lt; 0.67. Yo ass can therefore simulate tha probability
of dirtnap by testin if x is between 0 n' 0.67, dat is, if x &lt; 0.67. Thus, x &lt;
myProbDeath is tha desired condizzle fo' plant dirtnap, eliminatin chizzlez A and
B. Chizzlez D n' E fail cuz (int) myProbDeath truncates myProbDeath ta o.
Da test x &lt; 0 will always be false, n' tha test x == 0 will only be legit if the
random number generator returned exactly 0, a mad unlikely occurrence!
Neither of these chizzlez erectly simulates tha probabilitizzle of dirtnap.
5. (A) Da expression
253
254 Chapta 4 Some Standard Classes
(int) (Math.random() * 50);
returns a int from 0 ta 49. Therefore, addin 1 shifts tha range ta be 1 ta 50,
which was required.
6. (0) Da Integer class has no methodz dat can chizzle tha contentz of i yo. However,
i can be reassigned so dat it refers ta another object. This happens up in both
segments I n' m. Right back up in yo muthafuckin ass. Segment n is wack cuz intValue be a accessor-it cannot
be used ta chizzle tha value of object i.
7. (E) Chizzle E works cuz tha actual type of ob is Integer, which is what tha fuck the
compareTo method is expectin when tha callin object be a Integer n' shit. Chizzlez C
and D will cause a ClassCastException since tha callin n' parameta objects
are incompatible types. Da compareTo method will try erroneously ta cast its
parameta ta tha type of tha object callin tha method. Y'all KNOW dat shit, muthafucka! Chizzle A almost works:
It fails cuz tha dot operator has higher precedence than casting, which means
that ob. compareTo is parsed before ob is cast ta Integer, generatin a message
that tha compareTo method aint up in class Object. Chizzle A can be fixed wit an
extra pair of parentheses:
if «(Integer) ob).compareTo(intOb) &lt; 0) ' "
Choice B causes tha same ol' dirty error message as chizzle A: no compareTo method in
class Object.
8. (0) Test I is erect cuz itz OK ta compare primitizzle types (in dis case
int joints) rockin ==. Test Pt III works cuz k. toStringO n' m. toStringO are
Strings, which should be compared wit equals. Test Pt II is wack cuz you
can't invoke a method (in dis case equals) on a into
9. (A) An Integer cannot be cast ta a String. Don't confuse dis with
System.out.println(intObj .toString()); Iioutputs 9
Note dat if tha straight-up original gangsta line of tha code fragment were
Integer intObj = freshly smoked up Integer(9);
then tha error would be detected at compile time.
10. (C) Here is tha memory slots:
81
String
52
0----. Right back up in yo muthafuckin ass. String
r83I _ "crab" 0- Pt II crab Pt II
~L..-.----'
Statements Pt II n' In is legit cuz tha contentz of sl n' s2 is tha same, and
the contentz of s3 n' s2 is tha same. Right back up in yo muthafuckin ass. Statement I is false cuz sl n' 82 are
not tha same reference. Note dat tha expression 81 == 83 would be legit since
81 n' 83 is tha same reference.
11. (0) Note dat "TOMATO" precedes both "tomato" n' "tom", since "T" precedes
"t" fo' realz. Also, "tom" precedes "tomato" since tha length of "tom" is less than the
length of "tomato". Therefore each of tha followin is true:
Answers Explained
So
strA.compareTo(strB) &lt; 0
strA.compareTo(strC) &lt; 0
strC.compareTo(strB) &lt; 0
Choice A is T n' F which evaluates ta F
Choice B is F or F which evaluates ta F
Choice C is F n' T which evaluates ta F
Choice D is T n' T which evaluates ta T
Choice E is T n' F which evaluates ta F
12. (A) x gotz nuff tha index of tha straight-up original gangsta occurrence of "m" up in line, namely 2. (Remember
that "S" be at index 0.) Da method call line . substrin (10 ,15) returns
"silly", tha substrin startin at index 10 n' extendin though index 14. The
method call line . substrin (25,27) returns" st" (don't include tha characta at
index 27!). Da concatenation operator, +, joins these.
13. (B) Da statement temp = s. substring(i, i +1) places up in temp tha strang containing
the characta at posizzle i. Da fo' loop thus cyclez all up in "conglomeration",
startin at "C", n' compares each single characta strang ta "m". If
that characta precedes "m", a freshly smoked up Strin reference "w" is pimped, which consists
of tha current value of "w" concatenated wit dat character.
14. (D) Da first characta of tha last name starts all up in tha straight-up original gangsta characta afta tha space.
Thus, startIndex fo' substrin must be k+1. This eliminates expression I. Expression
II takes all tha charactas from posizzle k+l ta tha end of tha fullName
string, which is erect. Expression Pt III takes all tha charactas from posizzle k+l
to posizzle fullName .lengthO-l, which be also erect.
15. (E) Suppose s gotz nuff "cat". Yo ass want pigStrin = "at" + "c" + "ay".
Now tha strang "at" is tha substrin of s startin at posizzle 1 n' endin at
posizzle s . length 0 -1. Da erect substrin call fo' dis piece of tha word is
S. substring(l, s . length 0 ), which eliminates chizzlez A, C, and, D. (Recall that
the first parameta is tha startin posizzle n' tha second parameta is one position
past tha last index of tha substring.) Da first letta of tha word-"c" up in the
example-starts at posizzle 0 n' endz at posizzle O. Da erect expression is
S. substring(O ,1), which eliminates chizzle B.
16. (A) Statement I is legit whenever s2 occurs up in s1. For example, if strings
sl = "catastrophe" n' s2 = "cat", then getStrin returns "cat". Right back up in yo muthafuckin ass. Statement
II aint NEVER gonna happen. I aint talkin' bout chicken n' gravy biatch. If s2 aint contained up in sl, tha indexOf call will return
-1. Usin a wack integer as tha straight-up original gangsta parameta of substrin will cause
a StringlndexOutOfBoundsException. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Statement Pt III'ma be legit whenever sl
equals 82.
17. (C) Da Strin temp represents a single-characta substrin of S. Da method
examines each characta up in s and, if it aint nuthin but a nonblank, appendz it ta str, which
is initially empty. Each assignment str += temp assigns a freshly smoked up reference ta str.
Thus, str endz up as a cold-ass lil copy of s but without tha blanks fo' realz. A reference ta tha final
str object is returned. Y'all KNOW dat shit, muthafucka! Chizzle A is erect up in dat s is left unchanged yo, but it is
not tha dopest characterization of what tha fuck tha method do. Chizzle B aint precise
because a object parameta is never modified: Chizzles, if any, is performed on
a copy. Chizzlez D n' E is wack cuz tha method removes blanks.
18. (E) Da compareTo method returns a int, so eliminizzle chizzlez A n' B. In the
255
256
AB6NLY
Chapta 4 Some Standard Classes
implementation of compareTo, tha code segment dat applies ta tha particular
example is
if (this.getRow() &lt; p.getRow() I I ...
return -1;
Since 2 &lt; 4, tha value -1 is returned.
19. (C) Expression Pt III is true: tha compareTo method is implemented ta return 0
if two Posizzle objects have tha same row n' column. I aint talkin' bout chicken n' gravy biatch. Expression I is false
because objectl == object2 returns legit only if objectl n' object2 is the
same reference. Expression Pt II is tricky. One wanna pi n' p3 ta be equal
since they have tha same row n' column joints, n' you can put dat on yo' toast. This aint goin ta happen
automatically, however n' shit. Da equals method must explicitly be overridden for
the Posizzle class. If dis aint been done, tha default equals method, which
is inherited from class Object, will return legit only if pi n' p3 is tha same
reference, which aint true.
20. (C) Here be a cold-ass lil counterexample fo' statement Pt III: a hashCode value of 32 corresponds
to (3,2) n' (2, 12).
21. (C) Recall dat primitizzle types n' object references is passed by value. This
means dat copies is made of tha actual ar~ments fo' realz. Any chizzlez dat is made
are made ta tha copies. Put ya muthafuckin choppers up if ya feel dis! Da actual parametas remain unchanged. Y'all KNOW dat shit, muthafucka! Thus, in
methodz I n' Pt II, tha parametas will retain they original gangsta joints n' remain
unswapped.
To illustrate, fo' example, why method Pt II fails, consider dis piece of code that
tests it:
hood static void main(String[] args)
{
int x = 8, Y = 6;
Integer xObject = freshly smoked up Integer(x);
Integer yObject = freshly smoked up Integer(y);
swap(xObject, yObject);
x = xObject.intValue();
y = yObject.intValue();
//surprise biaaatch! still has value 8
//surprise biaaatch! still has value 6
}
Here is tha memory slots before swap is called:
x y xObject Integer.
0 0 0 ~
yObject Integer
0  ~
Here they is when swap is invoked:
Answers Explained
xObject
x y 0 ,. Integer
0 0 obj_a 0 ,. 0
yObject
temp Integer 0 ~
Integer
0----. 0 obj_b 0 ~ 0
Just before exitin tha swap method:
x y xObject Integer
0 0 0 0
temp yObject
[]--- Integer 0 ~
Integer
obj_b 0 obj_a []--- 0 ~ 0
Afta exiting, xObject n' yObject have retained they original gangsta joints:
x y xObject Integer
0 0 0 ~ 0
yObject Integer
0 0
Da reason method Pt III works is dat instead of tha object references bein chizzled,
the object contents is chizzled. Y'all KNOW dat shit, muthafucka! Thus, afta exitin tha method, tha IntPair reference
is as it was yo, but tha straight-up original gangsta n' second joints done been interchanged. Y'all KNOW dat shit, muthafucka! (See
explanation ta next question fo' diagramz of tha memory slots.) In dis question,
IntPair is used as a wrapper class fo' a pair of integers whose joints need ta be
swapped.
22. (B) Da swap method has just a single IntPair parameter, which eliminates segment
I. Right back up in yo muthafuckin ass. Segment Pt III fails cuz setFirst n' setSecond is used incorrectly.
These is mutator methodz dat chizzle a IntPair object. What tha fuck iz desired is to
return tha (newly swapped) first n' second jointz of tha pair: Accessor methods
257
258 Chapta 4 Some Standard Classes
getFirst n' getSecond do tha trick. To peep why dis swap method works, look
at tha memory slots.
Before tha swap method is called:
x y iPair 00 Ol---~"~
IntPair
firstValue G
secondValue G
Just afta tha swap method is called:
x y iPair IntPair
J3---~"
I . firstValue f8l I pa1T L..J
00
temp o \,t:==J--~"~1 secondValue G
Just before exitin tha swap method:
x y
00
temp o
iPair IntPair
pair firstValue G
01------') .... 1 secondValue G
Just afta exitin tha swap method:
x y
00
Afta tha statements:
x iPair.getFirst();
y = iPair .getSecond();
x y
00
iPair Ol----.~.
iPair Ol----.~.
Notice dat x n' y done been swapped!
IntPair
firstValue G
secondValue G
IntPair
firstValue G
secondValue G
Answers Explained
23. (A) Da first statement of segment I compares last names. If these is different,
the method returns tha int value lastComp, which is wack if lastName
precedes n .lastName, positizzle otherwise. If last names is tha same, tha method
returns tha int result of comparin first names. Right back up in yo muthafuckin ass. Segments Pt II n' Pt III use incorrect
algorithms fo' comparin names. Right back up in yo muthafuckin ass. Segment Pt II would be erect if tha else part
were
return lastName.compareTo(n.lastName);
Segment Pt III would be erect if tha two return statements was interchanged.
24. (E) Da Comparable intercourse has just one method, compareTo. Chizzle E would
be legit if equals was replaced by compareTo. Chizzle A is true. Yo ass know this
because tha Name class has no mutator methods. Thus, Name objects can never be
changed. Y'all KNOW dat shit, muthafucka! Chizzle B is true: If a Name is initialized wit null references, each of
the methodz will throw a NullPointerException. I aint talkin' bout chicken n' gravy biatch. Chizzle C is true: hashCode
must be redefined ta satisfy tha condizzle dat two equal Name objects have the
same hash code. Chizzle D is true: If tha parameta is null, compareTo will throw
a NullPointerException. I aint talkin' bout chicken n' gravy biatch. If tha parameta is incompatible wit Name objects, its
first statement will throw a ClassCastException.
259
ABONLY
Program Design and
Analysis
CHAPTER 5
260
Weekz of codin can save you minutez of planning.
-Anonymous
Chapta Goals
 Program pimpment,
includin design n' testing
 Program analysis
 Big-O notation
 Object-oriented program design  Loop invariants
 Relationships between classes
&lt;~:~:.;: tudentz of introductory computa science typically peep theyselves as program-:-~-
-"., .!.,; mers. They no sooner gotz a freshly smoked up programmin project up in they headz than
they all up in tha computer, typin madly ta git some code up n' hustlin. (Is dis yo slick ass?)
To succeed as a programmer, however, you gotta combine tha practical game of a
software engineer wit tha analytical mindset of a cold-ass lil computa scientist fo' realz. A software engineer
oversees tha game cycle of software pimpment: initiation of tha project, analysis
of tha justification, n' design of tha program, as well as implementation, testing, and
maintenizzle of tha final thang fo' realz. A computa scientist (among other thangs!) analyzes
the implementation, erectness, n' efficiency of algorithms fo' realz. All these topics
are tested on tha APCS exam.
THE SOFTWARE DEVELOPMENT LIFE CYCLE
Da Waterfall Model
Da waterfall model of software pimpment came bout up in tha 1960s up in order to
brin structure n' efficiency tha fuck into tha process of bustin big-ass programs.
Each step up in tha process flows tha fuck into tha next: Da picture resemblez a waterfall.
Da Software Development Life Cycle
Analysiz of the
Specification
Program Design
Implementation 1------.
Testin &amp; Debugging
Maintenance
Program Justification
Da justification be a gangbangin' freestyled description of tha project. Typically it is based on a cold-ass lil hustla's
requirements, n' you can put dat on yo' toast. Da first step up in freestylin a program is ta analyze tha justification,
make shizzle you KNOW it, n' clarify wit tha hustla anythang dat is
unclear.
Program Design
Even fo' a small-scale program a phat design can save programmin time n' enhance
the reliabilitizzle of tha final program. Da design be a gangbangin' fairly detailed plan fo' solvin the
problem outlined up in tha justification. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it should include all objects dat is ghon be used in
the solution, tha data structures dat will implement them, plus a thugged-out detailed list of the
tasks ta be performed by tha program.
A phat design serves up a gangbangin' fairly detailed overall plan at a glance, without including
the minutiae of Java code.
Program Implementation
Program implementation is tha codin phase. Design n' implementation is discussed
in mo' detail on p. 263.
Testin n' Debugging
TEST DATA
Not every last muthafuckin possible input value can be tested, so a programmer should be diligent in
selectin a representatizzle set of test data. Typical joints up in each part of a thugged-out domain of the
program should be selected, as well as endpoint joints n' out-of-range joints, n' you can put dat on yo' toast. If only
positizzle input is required, yo' test data should include a wack value just ta check
that yo' program handlez it appropriately.
261
262 Chapta 5 Program Design n' Analysis
Example
A program must be freestyled ta bang a value tha fuck into its erect posizzle up in dis sorted
list:
2 5 9
Test data should include
 A value less than 2
 A value between 2 n' 5
 A value between 5 n' 9
 A value pimped outa than 9
 2,5, n' 9
 A wack value
TYPES OF ERRORS (BUGS)
 A compile-time error occurs durin compilation of tha program. Da compiler
is unable ta translate tha program tha fuck into bytecode n' prints a appropriate error
message fo' realz. A syntax error be a cold-ass lil compile-time error caused by violatin tha rulez of
the programmin language. Examplez include omittin semicolons or braces,
usin undeclared identifiers, rockin keywordz inappropriately, havin parameters
that don't match up in type n' number, n' invokin a method fo' a object
whose class definizzle don't contain dat method.
 A run-time error occurs durin execution of tha program. Da Java run-time
environment throws a exception, which means dat it stops execution n' prints
an error message. Typical causez of run-time errors include attemptin ta divide
an integer by zero, rockin a array index dat is outta bounds, attemptin to
open a gangbangin' file dat cannot be found, n' so on. I aint talkin' bout chicken n' gravy biatch fo' realz. An error dat causes a program to
run forever ("infinite loop") can also be regarded as a run-time error. Shiiit, dis aint no joke. (See also
Errors n' Exceptions, p. 132.)
 An intent or logic error is one dat fails ta carry up tha justification of the
program. Da program compilez n' runs but do not do tha thang. These are
sometimes tha hardest typez of errors ta fix.
ROBUSTNESS
Always assume dat any user of yo' program aint as smart-ass as yo ass is. Yo ass must
therefore aim ta write a robust program, namely one that
 Won't give inaccurate lyrics fo' some input data.
 Won't crash if tha input data is invalid.
 Won't allow execution ta proceed if invalid data is entered.
Examplez of shitty input data include out-of-range numbers, charactas instead of numerical
data, n' a response of "maybe" when "yes" or "no" was axed for.
Note dat shitty input data dat invalidates a cold-ass lil computation won't be detected by Java.
Yo crazy-ass program should include code dat catches tha error, allows tha error ta be fixed,
and allows program execution ta resume.
Obje,ct-Oriented Program Design
Program Maintenance
Program maintenizzle involves upgradin tha code as circumstances chizzle. New features
may be added. Y'all KNOW dat shit, muthafucka! New programmers may come on board. Y'all KNOW dat shit, muthafucka! To make they task easier,
the original gangsta program must have clear n' precise documentation.
OBJECT-ORIENTED PROGRAM DESIGN
Object-oriented programmin has been tha dominant programmin methodologizzle since
the mid 1990s. Well shiiiit, it uses a approach dat blurs tha linez of tha waterfall model fo' realz. Analysis
of tha problem, pimpment of tha design, n' piecez of tha implementation all
overlap n' influence one another.
Here is tha steps i'n object-oriented design:
 Identify classes ta be written.
 Identify behaviors(i.e., methods) fo' each class.
 Determine tha relationshizzlez between classes.
 Write tha intercourse (hood method headers) fo' each class.
 Implement tha methods.
Identifyin Classes
. Identify tha objects up in tha program by pickin up tha nouns up in tha program justification.
Ignore pronouns n' nouns dat refer ta tha user n' shit. Right back up in yo muthafuckin ass. Select dem nouns tha~
seem suitable as classes, tha "big-picture" nouns dat describe tha major objects up in the
application. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Some of tha other nouns may end up as'attributez of tha classes.
Identifyin Behaviors
Find all verbs up in tha program description dat help lead ta tha solution of tha programming
task. These is likely behaviors dat will probably become tha methodz of the
classes.
Encapsulation
Now decizzle which methodz belong up in which classes. Recall dat tha process of bundling
a crew of methodz n' data fieldz tha fuck into a cold-ass lil class is called encapsulation.
Yo ass will also need ta decizzle which data fieldz each class will need n' which data
structures should store dem wild-ass muthafuckas. For example, if a object represents a list of items, consider
an array or ArrayList as tha data structure.
Determinin Relationships Between Classes
INHERITANCE RELATIONSHIPS
Look fo' classes wit common behaviors. This will help identify inheritizzle relationshizzles.
Recall tha is-a relationshizzle-if object son! is-a object2, then object2 be a cold-ass lil muthafucka
for a superclass.
263
264 Chapta 5 Program Design n' An?'ysis
COMPOSITION RELATIONSHIPS
Composizzle relationshizzlez is defined by tha has-a relationshizzle. For example, a Nurse
has-a Uniform. Typically, if two classes gotz a cold-ass lil composizzle relationshizzle, one of them
gotz nuff a instizzle variable whose type is tha other class.
Note dat a wrapper class always implements a has-a relationshizzle wit any objects
that it wraps.
UML Diagrams
An pimpin way ta keep track of tha relationshizzlez between classes n' show tha inheritance
hierarchy up in yo' programs is wit a UML (Unified Modelin Language)
diagram. This be a standard graphical scheme used by object-oriented programmers.
Although it aint part of tha AP subset, on tha AP exam you may be sposed ta fuckin
interpret simple UML diagrams n' inheritizzle hierarchies.
Here be a simplified version of tha UML rules:
 Represent classes wit rectangles.
 Use angle brackets wit tha word "abstract" or "interface" ta indicate either an
abstract class or intercourse.
 Show tha is-a relationshizzle between classes wit a open up-arrow.
 Show tha is-a relationshizzle dat involves a intercourse wit a open, dotted uparrow.
 Show tha has-a relationshizzle wit a thugged-out down arrow (indicates composition).
Example
Comparable
«interface»
Player
«abstract»
Board
ScoreCard
From dis diagram you can peep at a glizzle dat GoodPlayer n' BadPlayer is subclasses
of a abstract class Player, n' dat each Player implements tha Comparable intercourse.
Every Player has a Board n' a ScoreCard, while only tha BadPlayer has a Tutor.
Object-Oriented Program Design
Implementin Classes
BOTTOM-UP DEVELOPMENT
For each method up in a cold-ass lil class, list all of tha other classes needed ta implement dat particular
method. Y'all KNOW dat shit, muthafucka! These classes is called collaborators fo' realz. A class dat has no collaborators is
independent.
To implement tha classes, often a incremental, bottom-up approach is used. Y'all KNOW dat shit, muthafucka! This
means dat independent classes is straight-up implemented n' tested before bein incorporated
into tha overall project. These unrelated classes can be implemented by different
programmers.
Note dat a cold-ass lil class can be tested rockin a thugged-out dummy Testa class dat is ghon be discarded
when tha methodz of tha class is working. Constructors, then methods, should be
added, n' tested, one at a time fo' realz. A driver class dat gotz nuff a main method can be used
to test tha program as you go. Da purpose of tha driver is ta test tha class straight-up before
incorporatin it as a object up in a freshly smoked up class.
When each of tha independent classes is working, classes dat depend on just one
other class is implemented n' tested, n' so on. I aint talkin' bout chicken n' gravy biatch. This may lead ta a working, bare
bones version of tha project. New features n' enhancements can be added later.
Design flaws can be erected at each stage of pimpment. Remember, a thugged-out design is
never set up in stone: It simply guides tha implementation.
TOP-DOWN DEVELOPMENT
In a top-down design, tha programmer starts wit a overview of tha program, selecting
the highest-level controllin object n' tha tasks needed. Y'all KNOW dat shit, muthafucka! Durin pimpment of
the program, subsidiary clas~es may be added ta simplify existin classes.
Implementin Methods
PROCEDURAL ABSTRACTION
A phat programmer avoidz chunkz of repeated code wherever possible. To dis end,
if nuff muthafuckin methodz up in a cold-ass lil class require tha same task, like a search or a swap, you should
use helper methods. Da reduce method up in tha Rationizzle class on p. 172 be a example
of such a method. Y'all KNOW dat shit, muthafucka! Also, wherever possible you should enhizzle tha readabilitizzle of your
code by rockin helper methodz ta break long methodz tha fuck into smalla tasks. Da use of
helper methodz within a cold-ass lil class is known as procedural abstraction n' be a example of
top-down pimpment within a cold-ass lil class. This process of breakin a long-ass method tha fuck into a
sequence of smalla tasks is sometimes called stepwise refinement.
INFORMATION HIDING
Instizzle variablez n' helper methodz is generally declared as private, which prevents
client classes from accessin dem wild-ass muthafuckas. This game is called shiznit hiding.
STUB METHOD
Sometimes it make mo' sense up in tha pimpment of a cold-ass lil class ta test a cold-ass lil callin method
before testin a method it invokes fo' realz. A stub be a thugged-out dummy method dat standz up in fo' a
method until tha actual method has been freestyled n' tested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. A stub typically has an
output statement ta show dat dat shiznit was called up in tha erect place, or it may return some
reasonable joints if necessary.
265
266 Chapta 5 Program Design n' Analysis
ALGORITHM
An algorithm be a precise step-by-step procedure dat solves a problem or achieves a
goal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Don't write any code fo' a algorithm up in a method until tha steps is straight-up
clear ta you, biatch.
Example 1
A program must test tha validitizzle of a gangbangin' four-digit code number dat a thug will enter
to be able ta bust a photocopy machine. Da number is valid if tha fourth digit equals
the remainder when tha sum of tha straight-up original gangsta three digits is divided by seven.
Classes up in tha program may include a IDNumber, tha four-digit code; Display,
which would handle input n' output; n' IDMain, tha driver fo' tha program. The
data structure used ta implement a IDNumber could be a instizzle variable of type
int, or a instizzle variable of type String, or four instizzle variablez of type int-one
per digit, n' so on.
A top-down design fo' tha program dat tests tha validitizzle of tha number is reflected
in tha stepz of tha main method of IDMain:
Smoke Display
Read up in IDNumber
Peep validity
Print message
Each method up in dis design is tested before tha next method be added ta main. I aint talkin' bout chicken n' gravy biatch. If the
display is ghon be handled up in a GUI (graphical user intercourse), stepwise refinement of the
design might be lookin like this:
Smoke Display
Construct a Display
Smoke window panels
Set up text fields
Add panels n' fieldz ta window
Read up in IDNumber
Prompt n' Read
Peep validitizzle of IDNumber
Peep input
Peep characters
Peep range
Separate tha fuck into digits
Peep validitizzle property
Print message
Write number
State if valid
NOTE
1. Da IDNumber class, which gotz nuff tha four-digit code, is responsible fo' the
followin operations:
Split value tha fuck into separate objects
Peep condizzle fo' validity
Object-Oriented Program Design
Da Display class, which gotz nuff objects ta read n' display, must also contain
an IDNumber object. Well shiiiit, it is responsible fo' tha followin operations:
Set up display .
Read up in code number
Display validitizzle message
Creatin these two classes wit they data fieldz n' operations (methods) be an
example of encapsulation.
2. Da Display method readCodeNumber needz private helper methodz ta check
the input: checkCharactas n' checkRange. This be a example of procedural
abstraction (use of helper methods) n' shiznit hidin (makin them
private).
3. Initially tha programmer had just a IDNumber class n' a thugged-out driver class. The
Display class was added as a refinement, when dat shiznit was realized dat handling
the input n' message display was separate from checkin tha validitizzle of the
IDNumber n' shit. This be a example of top-down pimpment (addin a auxiliary
class ta clarify tha code).
4. Da IDNumber class gotz nuff no data fieldz dat is objects, n' you can put dat on yo' toast. Well shiiiit, it is therefore a independent
class. Da Display class, which gotz nuff a IDNumber data member,
has a cold-ass lil composizzle relationshizzle wit IDNumber (Display has-a IDNumber).
5. When testin tha final program, tha programmer should be shizzle ta include
each of tha followin as a user-entered code number: a valid four-digit number,
an invalid four-digit number, a n-digit number, where n t- 4, n' a "number"
that gotz nuff a nondigit character n' shiznit fo' realz. A robust program should be able ta deal
with all these cases.
Example 2
A program must create a mackdaddyz grade book. Da program should maintain a cold-ass lil class
list of hustlas fo' any number of classes up in tha mackdaddyz schedule fo' realz. A menu should be
provided dat allows tha mackdaddy to
 Smoke a freshly smoked up class of hustlas.
 Enta a set of scores fo' any class.
 Correct any data thatz been entered.
 Display tha record of any hustla.
 Calculate tha final average n' grade fo' all hustlas up in a cold-ass lil class.
 Print a cold-ass lil class list, wit or without grades.
 Add a hustla, delete a hustla, or transfer a hustla ta another class.
 Save all tha data up in a gangbangin' file.
IDENTIFYING CLASSES
Use tha nouns up in tha justification as a startin point fo' identifyin classes up in the
program. Da nouns are: program, mackdaddy, grade book, class list, class, hustla,
schedule, menu, set of scores, data, record, average, grade, n' file.
Eliminizzle each of tha following:
267
Use nouns up in the
specification to
identify possible
classes.
268
Use verbs up in the
specification to
identify possible
methods.
program
mackdaddy
schedule
data, record
class
Chapta 5 Program Design n' Analysis
(Always eliminizzle "program" when used up in dis context.)
(Eliminate, cuz he or her ass is tha user.)
(This is ghon be reflected up in tha name of tha external file for
each class, e.g., apcs_period3. dat.)
(These is synonymous wit hustla name, scores, grades,
etc., n' is ghon be covered by these features.)
(This is synonymous wit class list.)
Da followin seem ta be pimpin muthafuckas fo' classes: GradeBook, ClassList,
Student, n' FileHandlez n' shit. Other possibilitizzles is Menu, ScoreList, n' a GUI_Display.
RELATIONSHIPS BETWEEN CLASSES
There is no inheritizzle relationshizzles. There is nuff composizzle relationshizzles
between objects, however n' shit. Da GradeBook has-a Menu, tha ClassList has-a Student
(several, up in fact!), a Student has-a name, average, grade, list_oCscores, etc. The
programmer must decizzle whether ta code these attributes as classes or data fields.
IDENTIFYING BEHAVIORS
Use tha verbs up in tha justification ta identify required operations up in tha program.
Da verbs are: maintain <list>, provide <menu>, allow <user>, create <list>,
enta <scores>, erect <data>, display <record>, calculate <average>, calculate
<grade>, print <list>, add <student>, delete <student>, transfer <student>, and
save <data>.
Yo ass must cook up some fuckin design decisions bout which class is responsible fo' which
behavior. Shiiit, dis aint no joke. For example, will a ClassList display tha record of a single Student, or will
a Student display his or her own record, biatch? Dum diddy-dum, here I come biaaatch! Who tha fuck will enta scores-the GradeBook, a
ClassList, or a Student, biatch? Therez no right or wack answer n' shit. Yo ass may start it one way
and re-evaluate lata on.
DECISIONS
Here is some preliminary decisions. Da GradeBook will provideMenu fo'sho. Da menu
selection will bust execution ta tha relevant object.
Da ClassList will maintain a updated list of each class. Well shiiiit, it gonna git these public
methods: addStudent, deleteStudent, transferStudent, createNewClass,
printClassList, printScores, n' updateList fo' realz. A phat muthafucka fo' a helper method
. up in dis class is search fo' a given hustla.
Each Student gonna git complete underground n' grade shiznit. I aint talkin' bout chicken n' gravy biatch. Public methods
will include setName, getName, enterScore, erectData, findAverage, getAverage,
getGrade, n' displayRecord.
Savin n' retrievin shiznit is crucial ta dis program. Da FileHandlez will
take care of openFileForReading, openFileForWriting, closeFiles, loadClass, and
saveClass. Da FileHandlez class should be freestyled n' tested right all up in tha beginning,
usin a lil' small-ass dummy class list.
ScoreList n' Student is easy as fuck  classes ta implement. When these is working, the
programmer can go on ta ClassList. This be a example of bottom-up pimpment.
Vocabulary Summary
Know these terms fo' tha AP exam:
Program Analysis
Vocabulary
software pimpment
object-oriented program
program justification
program design
program implementation
test data
program maintenance
top-down pimpment
independent class
bottom-up pimpment
driver class
inheritizzle relationshizzle
composizzle relationshizzle
inheritizzle hierarchy
UMLdiagram
data structure
encapsulation
information hiding
stepwise refinement
procedural abstraction
algorithm
stub method
debugging
robust program
compile-time error
syntax error
run-tIme error
exception
logic error
Meaning
Freestylin a program
Uses interactin objects
Description of a task
A freestyled plan, a overview of tha solution
Da code
Input ta test tha program
Keepin tha program hustlin n' up ta date
Implement main classes first, subsidiary classes later
Doesn't use other classez of tha program up in its code
Implement lowest level, independent classes first
Used ta test other classes; gotz nuff main method
is-a relationshizzle between classes
has-a relationshizzle between classes
Inheritizzle relationshizzle shown up in a tree-like diagram
Graphical representation of relationshizzle between classes
Java construct fo' storin a thugged-out data field (e.g., array)
Combinin data fieldz n' methodz up in a cold-ass lil class
Usin pri vate ta restrict access
Breakin methodz tha fuck into smalla methods
Usin helper methods
Step-by-step process dat solves a problem
Dummy method called by another method bein tested
Fixin errors
Screens up shitty input
Usually a syntax error; prevents program from compiling
Shiznitty language usage (e.g., missin brace)
Occurs durin execution (e.g., int division by 0)
Run-time error thrown by Java method
Program runs but do tha wack thang
PROGRAM ANALYSIS
Program Correctness
Testin dat a program works do not prove dat tha program is erect fo' realz. Afta all, you
can hardly expect ta test programs fo' every last muthafuckin conceivable set of input data. Computer
scientists have pimped mathematical steez ta prove erectnizz up in certain cases,
but these is beyond tha scope of tha APCS course. Nevertheless, yo ass is expected
to be able ta make assertions bout tha state of a program at various points durin its
execution.
Assertions
An assertion be a precise statement on some program at any given point. Da scam is
that if a assertion is proved ta be true, then tha program is hustlin erectly at that
point.
An informal step on tha way ta freestylin erect algorithms is ta be able ta make
three kindz of assertions bout yo' code.
269
270
_ .. -_ ..
. ~.:.
Chapta 5 Program Design n' Analysis
PRECONDITION
Da precondizzle fo' any piece of code~ whether it aint nuthin but a method, loop, or block, be a
statement of what tha fuck is legit immediately before execution of dat code.
POSTCONDITION
Da postcondizzle fo' a piece of code be a statement of what tha fuck is legit immediately after
execution of dat code.
LOOP INVARIANT
A loop i1'jvariant applies only ta a loop. Well shiiiit, it aint nuthin but a precise statement, up in termz of tha loop
variables, of what tha fuck is legit before n' afta each iteration of tha loop. Well shiiiit, it includes an
assertion bout tha range of tha loop variable. Informally, it raps bout how tha fuck much of
the loopz task has been completed at each stage.
*
*
* Example
Da asterisks show tha points at which the
loop invariant must be true:
 Afta initialization
 Afta each iteration
 Afta tha final exit
II method ta generate n! Pt II
IIPrecondition: n &gt;= o.
IIPostcondition: n! has been returned.
hood static int factorial(int n)
{
}
int thang = 1;
int i = 0;
while (i &lt; n)
{
i++;
thang *= i;
}
return product;
Afta initialization
Afta first pass
Afta second pass
Afta kth pass
i = 0, thang = 1, i.e., O! .
i = 1, thang = 1, i.e., 1!
i = 2, thang = 2, i.e., 2!
i = k, thang = k!
Da loop invariant fo' tha while loop is
Program Analysis
thang = i!. 0 ~ i ~ n
Here be a alternatizzle method body fo' dis method. Y'all KNOW dat shit, muthafucka! (Assume tha same method header,
comment, n' pre- n' postconditions.)
{
}
int thang = 1;
for (int i = 1; i &lt;= n; i++)
thang *= i;
return product;
Da loop invariant fo' tha f or loop is
thang = (i-i)!. 1 ~ i ~ n+l
Here (i -i)! (rather than i!) is erect cuz i is incremented all up in tha end of each
iteration of tha loop fo' realz. Also, n+l is needed up in tha second part of tha loop invariant
because i has a value of n+l afta tha final exit from tha loop. Remember, tha invariant
must also be legit afta tha final exit.
Efficiency
An efficient algorithm is one dat is economical up in tha use of
 CPU time. This refers ta tha number of machine operations required ta carry
out tha algorithm (arithmetic operations, comparisons, data movements, etc.).
 Memory. This refers ta tha number n' complexitizzle of tha variablez used.
Some factors dat affect run-time efficiency include ~nnecessary tests, excessive movement
of data elements, n' redundant computations, especially up in loops.
Always aim fo' early detection of output conditions: Yo crazy-ass sortin algorithm should
halt when tha list is sorted; yo' search should stop if tha key element has been found.
In discussin efficiency of a algorithm, we refer ta tha dopest case, most shitty case, and
average case. Da dopest case be a cold-ass lil configuration of tha data dat causes tha algorithm to
run up in tha least possible amount of time. Da most shitty case be a cold-ass lil configuration dat leadz to
the top billin possible run time. Typical configurations (i.e., not specially chosen data)
give tha average case. Well shiiiit, it is possible dat best, worst, n' average cases don't differ much
in they run times.
For example, suppose dat a list of distinct random numbers must be searched fo' a
given key value. Da algorithm used be a sequential search startin all up in tha beginnin of
the list. In tha dopest case, tha key is ghon be found up in tha straight-up original gangsta posizzle examined. Y'all KNOW dat shit, muthafucka! In the
worst case, it is ghon be up in tha last posizzle or not up in tha list at all. On average, tha key
will be somewhere up in tha middle of tha list.
Big-O Notation
Big-O notation serves up a quantitatizzle way of describin tha run time or space efficiency
of a algorithm. This method is independent of both tha programmin language
and tha computa used.
Let n be tha number of elements ta be processed. Y'all KNOW dat shit, muthafucka! For a given algorithm, express
the number of comparisons, exchanges, data movements, n' primitizzle operations as
a function of n, T(n). (primitizzle operations involve simple built-in types n' take one
unit of time, fo' example, addin two ints, multiplyin two doub1.es, assignin a int,
271
AB (continued)
ABONLY
272
AD (continued)
Use average-case
behavior to
determine the
big-O run time of
an algorithm.
Chapta 5 Program Design n' Analysis
and struttin simple tests.) Da type of function dat you git fo' T(n) determines
the "order" of tha algorithm. For example, if T(n) be a linear function of n, we say the
algorithm is O( n) ("order n "). Da scam is dat fo' big-ass jointz of n, tha run time will
be proportionizzle ta n. I aint talkin' bout chicken n' gravy biatch yo. Here be a list of da most thugged-out common cases.
Example 1
Function Type fo' T(n) Big-O Description
constant
logarithmic
linear
quadratic
cubic
exponential
0(1)
O(logn)
O(n)
0(n2)
O(n3)
0(2n)
An algorithm dat searches a unordered list of n elements fo' tha phattest value
could need n comparisons n' n reassignments ta a variable max. Thus, T(n)::::: 2n,
which is linear, so tha search algorithm is O( n).
Example 2
An algorithm dat prints up tha last five elementz of a long-ass list stored as a array
takes tha same ol' dirty amount of time irrespectizzle of tha length of tha list. Thus, T(n) = 5, a
constant, n' tha algorithm is 0(1).
Example 3
Algorithm 1 executes wit T(n) = 3n2 - Sn + 10 n' Algorithm 2 has T(n) =
!n2 - 50n + 100. Both of these "re quadratic, n' tha algorithms is therefore 0(n2).
Constants, low-order terms, n' coefficientz of tha highest order term is ignored in
assessin big-O run times.
NOTE
1. Big-O notation is only meaningful fo' big-ass n. I aint talkin' bout chicken n' gravy biatch. When n is large, there is some
value n above which a 0(n2) algorithm will always take longer than a O(n)
algorithm, or a O( n ) algorithm will take longer than a O(log n) algorithm,
and so on.
2. Da followin table shows approximately how tha fuck nuff computa operations could
be expected given n n' tha big-O description: of tha algorithm. For example,
an 0(n2) algorithm performed on 100 elements would require on tha order
of 1002 = 104 computa operations, whereas a 0(log2 n) algorithm would
require approximately seven operations.
n o (log 2 n) O(n) 0(n2) Of?)
.- -- ~-.- - "._ - .- -
16 4 16 256 216
100 7 100 104 2100
1000 10 1000 106 21000
3. Notice dat one can solve only straight-up lil' small-ass problems wit a algorithm dat has
exponential behavior fo' realz. At tha other extreme, a logarithmic algorithm is hella
efficient.
Program Analysis
ma.
Chapta Summary
a
Therez a shitload of vocabulary dat yo ass is sposed ta fuckin know up in dis chapter n' shit. Peep the
words!
Never make assumptions on some program justification, n' always write a thugged-out design
before startin ta write code. Even if you don't do dis fo' yo' own programs, these
are tha lyrics yo big-ass booty is ghon be sposed ta fuckin give on tha AP exam. Yo ass is certain ta get
questions bout program design. I aint talkin' bout chicken n' gravy biatch. Know tha procedures n' terminologizzle involved in
developin a object-oriented program.
Be shizzle you KNOW what tha fuck is meant by dopest case, most shitty case, n' average case for
an algorithm. There is ghon be nuff thangs bout efficiency on tha AP exam. Level
AB hustlas must know tha big-O run time fo' all standard algorithms.
By now you should know what tha fuck a precondizzle n' postcondizzle are. Level AB
students only, practice some loop invariants.
273
274 Chapta 5 Program Design n' Analysis
MULTIPLE-CHOICE QUESTIONS ON PROGRAM DESIGN
AND ANALYSIS
1 fo' realz. A program dat readz up in a gangbangin' five-digit identification number is ta be written. I aint talkin' bout chicken n' gravy biatch. The
specification do not state whether zero can be entered as a gangbangin' first digit. Da programmer
should
(A) Write tha code ta accept zero as a gangbangin' first digit since zero be a valid digit.
(B) Write tha code ta reject zero as a gangbangin' first digit since five-digit integers do not
start wit zero.
(C) Eliminizzle zero as a possibilitizzle fo' any of tha digits.
(D) Treat tha identification number as a gangbangin' four-digit number if tha user entas a
number startin wit zero.
(E) Peep wit tha writa of tha justification whether zero be aaight as a
first digit.
2. Refer ta tha followin three program descriptions:
I Test whether there exists at least one three-digit integer whose value equals
the sum of tha squarez of its digits.
II Read up in a three-digit code number n' check if it is valid accordin ta some
given formula.
III Passwordz consist of three digits n' three capital lettas up in any order n' shit. Read
in a password, n' check if there be any repeated characters.
For which of tha precedin program descriptions would a ThreeDigi tNumber
class be suitable?
(A) I only
(B) Pt II only
(C) Pt III only
(D) I n' Pt II only
(E) I, Pt II, n' Pt III
3. Top-down programmin is illustrated by which of tha following?
(A) Freestylin a program from top ta bottom up in Java
(B) Freestylin a essay describin how tha fuck tha program will work, without including
any Java code
(C) Usin driver programs ta test all methodz up in tha order dat they called in
the program
(D) Freestylin n' testin tha lowest level methodz first n' then combinin them
to form appropriate abstract operations
(E) Freestylin tha program up in termz of tha operations ta be performed n' then
refinin these operations by addin mo' detail
Multiple-Choice Thangs on Program Design n' Analysis
4. Which of tha followin should influence yo' chizzle of a particular algorithm?
I Da run time of tha algorithm
II Da memory requirementz of tha algorithm
III Da ease wit which tha logic of tha algorithm can be understood
(A) I only
(B) Pt III only
(C) I n' Pt III only
(D) I n' Pt II only
(E) I, Pt II, n' Pt III
5 fo' realz. A list of numbers is stored up in a sorted array. Well shiiiit, it is required dat tha list be maintained
in sorted order n' shit. This requirement leadz ta inefficient execution fo' which
of tha followin processes?
I Summin tha five smallest numbers up in tha list
II Findin tha maximum value up in tha list
III Insertin n' deletin numbers
(A) I only
(B) Pt III only
(C) Pt II n' Pt III only
(D) I n' Pt III only
(E) I, Pt II, n' Pt III
6. Which of tha followin aint necessarily a gangbangin' feature of a robust program?
(A) Do not allow execution ta proceed wit invalid data
(B) Uses algorithms dat give erect lyrics fo' off tha hook data joints
(C) Will run on any computa without modification
(D) Will not allow division by zero
(E) Will anticipate tha typez of errors dat playaz of tha program may make
7 fo' realz. A certain freight company charges its hustlas fo' shippin overseas according
to dis scale:
$80 per ton fo' a weight of 10 tons or less
$40 per ton fo' each additionizzle ton over 10 tons but
not exceedin 25 tons
$30 per ton fo' each additionizzle ton over 25 tons
For example, ta shizzle a weight of 12 tons will cost 10(80) + 2(40) = $880. To ship
26 tons will cost 10(80) + 15(40) + 1(30) = $1430.
A method takes as parameta a integer dat represents a valid shippin weight
and outputs tha charge fo' tha shipment. Which of tha followin is tha smallest
set of input joints fo' shippin weights dat will adequately test dis method?
(A) 10,25
(B) 5, 15,30
(C) 5, 10, 15,25, 30
(D) 0,5,10,15,25,30
(E) 5, 10, 15,20,25,30
275
276 Chapta 5 Program Design n' Analysis
8 fo' realz. A code segment calculates tha mean of joints stored up in integers nl, n2, n3, n' n4
and stores tha result up in average, which iz of type double. What kind of error is
caused wit dis statement?
double average = nl + n2 + n3 + n4 / (double) 4;
(A) Logic
(B) Run-time
(C) Overflow
(D) Syntax
(E) Type mismatch
9 fo' realz. A program evaluates binary arithmetic expressions dat is read from a input
file fo' realz. All of tha operandz is integers, n' tha only operators is +, -, *, and
/. In freestylin tha program, tha programmer forgot ta include a test dat checks
whether tha right-hand operand up in a gangbangin' finger-lickin' division expression equals zero. When will
this oversight be detected?
(A) At compile time
(B) While editin tha program
(C) As soon as tha data from tha input file is read
(D) Durin evaluation of tha expressions
(E) When at least one incorrect value fo' tha expressions is output
10. Which dopest raps bout tha precondizzle of a method, biatch? It be a assertion that
(A) raps bout precisely tha conditions dat must be legit all up in tha time tha method
is called.
(B) initializes tha parametaz of tha method.
(C) raps bout tha effect of tha method on its postcondition.
(D) explains what tha fuck tha method do.
(E) states what tha fuck tha initial jointz of tha local variablez up in tha method must be.
Multiple-Choice Thangs on Program Design n' Analysis
11. Consider tha followin code fragment:
IIPrecondition: al, a2, a3 contain 3 distinct integers.
IIPostcondition: max gotz nuff tha phattest of al, a2, a3.
Ilfirst set max equal ta larger of al n' a2
if (al &gt; a2)
max = al;
else
max = a2;
Iiset max equal ta larger of max n' a3
if (max &lt; a3)
max = a3;
For dis algorithm, which of tha followin initial setups fo' al, a2, n' a3 will
cause
(1) tha least number of computa operations (best case) and
(2) tha top billin number of computa operations (worst case)?
(A) (1) phattest value up in al or a2
(B) (1) phattest value up in a2 or a3
(C) (1) smallest value up in al
(D) (1) phattest value up in a2
(E) (1) smallest value up in al or a2
(2) phattest value up in a3
(2) phattest value up in al
(2) phattest value up in a2
(2) smallest value up in a3
(2) phattest value up in a3
Refer ta tha followin code segment fo' Thangs 12 n' 13.
IICompute tha mean of integers 1 .. N.
liN be a integer &gt;= 1 n' has been initialized.
int k = 1;
double mean, sum = 1.0;
while (k &lt; N)
{
1* loop body *1
}
mean = sum I N;
12. What tha fuck iz tha precondizzle fo' tha while loop?
(A) k ~ N, sum = 1. 0
(B) sum = 1 + 2 + 3 + ... + k
(C) k &lt; N, sum = 1.0
(D) N ~ 1, k = 1, sum = 1.0
(E) mean = sum I N
278 Chapta 5 Program Design n' Analysis
13. What should replace 1* loop body *1 so dat tha followin is tha loop invariant
for tha while loop:
sum = 1 + 2 + + k, 1 ::;k::;N
(A) sum += k;
k++;
(B) k++;
sum += k;
(C) sum++;
k += sum;
(D) k += sum;
sum++;
(E) sum += k;
Thangs 14 n' 15 refer ta tha Fibonacci sequence busted lyrics bout here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. Da sequence of
Fibonacci numbers is 1, 1,2,3,5,8, 13,21, .... Da first two Fibonacci numbers are
each 1. Each subsequent number is obtained by addin tha previous two. Consider
this method:
IIPrecondition: n &gt;= 1.
IIPostcondition: Da nth Fibonacci number has been returned.
hood static int fib(int n)
{
}
int prey = 1, next = 1, sum = 1;
for (int i = 3; i &lt;= n; i++)
{
}
sum = next + prey;
prey .. next;
next = sum;
return sum;
14. Which of tha followin be a cold-ass lil erect assertion bout tha loop variable i?
(A) 1 ::; i ::; n
(B) 0 ::; i ::; n
(C) 3 ::; i ::; n
(D) 3 ::; i ::; n+l
(E) 3 &lt; i &lt; n+l
15. Which of tha followin be a cold-ass lil erect loop invariant fo' tha fo' loop, assumin the
correct boundz fo' tha loop variable i?
(A) sum = ith Fibonacci number
(B) sum = (i+l)th Fibonacci number
(C) sum = (i-1)th Fibonacci number
(D) sum = (prev-l)th Fibonacci number
(E) sum = (next+l)th Fibonacci number
Multiple-Choice Thangs on Program Design n' Analysis
16 fo' realz. An efficient algorithm dat must delete tha last two elements up in a long-ass list of n
elements stored as a array is
(A) O(n)
(B) 0(n2)
(C) 0(1)
(D) 0(2)
(E) O(logn)
17 fo' realz. An algorithm ta remove all wack joints from a list of n integers sequentially
examines each element up in tha array. When a wack value is found, each element
is moved down one posizzle up in tha list. Da algorithm is
(A) 0(1)
(B) O(logn)
(C) O(n)
(D) 0(n2 )
(E) 0(n3)
18 fo' realz. A certain algorithm is O(logz n). Which of tha followin is ghon be closest ta the
number of computa operations required if tha algorithm manipulates 1000 elements?
(A) 10
(B) 100
(C) 1000
(D) 106
(E) 109
19 fo' realz. A certain algorithm examines a list of n random integers n' outputs tha number
of times tha value 5 appears up in tha list. Usin big-O notation, dis algorithm is
(A) 0(1)
(B) 0(5)
(C) O(n)
(D) 0(n2)
(E) O(logn)
279
AB (continued)
280 Chapta 5 Program Design n' Analysis
Refer ta tha followin method fo' Thangs 20 n' 21.
//Precondition: a n' b is initialized integers.
hood static int mystery(int a, int b)
{
}
int total = 0, count = 1;
while (count &lt;= b)
{
}
total += a;
count++;
return total;
20. What tha fuck iz tha postcondizzle fo' method mystery?
(A) total = a + b
(B) total =ab
(C) total = ba
(D) total = a * b
!E) total = aj b
21. Which be a loop invariant fo' tha while loop?
(A) total = (count-1)*a, 0 ~ count ~ b
(B) total = counUa, 1 ~ count ~ b
(C) total = (count-1)*a, 1 ~ count ~ b
(D) total = counUa, 1 ~ count ~ b+1
(E) total = (count-1)*a, 1 ~ count ~ b+1
22 fo' realz. A program is ta be freestyled dat prints a invoice fo' a lil' small-ass store fo' realz. A copy of the
invoice is ghon be given ta tha hustla n' will display
 A list of shit purchased.
 Da quantity, unit price, n' total price fo' each item.
  Da amount due.
Three muthafucka classes fo' dis program is Invoice, Item, n' ItemList, where
an Item be a single item purchased n' ItemList is tha list of all shit purchased.
Which class be a reasonable chizzle ta be responsible fo' tha amountDue method,
which returns tha amount tha hustla must pay?
I Item
IT ItemList
III Invoice
(A) I only
(B) Pt III only
(C) I n' IT only
(D) IT n' Pt III only
(E) I, Pt II, n' Pt III
Multiple-Choice Thangs on Program Design n' Analysis
23. Which be afolse statement bout classes up in object-oriented program design?
(A) H a cold-ass lil class Cl has a instizzle variable whose type be another class, C2, then Cl
has-a C2.
(B) If a cold-ass lil class Cl be associated wit another class, C2, then Cl dependz on C2 for
its implementation.
(C) H classes Cl n' C2 is related such dat Cl is-a C2, then C2 has-a C1.
(D) If class Cl is independent, then none of its methodz gonna git parameters
that is objectz of other classes.
(E) Classes dat have common methodz do not necessarily define a inheritance
relationship.
24 fo' realz. A Java program maintains a big-ass database of vehiclez n' parts fo' a cold-ass lil hoopty dealership.
Some of tha classes up in tha program is Vehicle, Car, Truck, Tire, Circle,
SteeringWheel, n' AirBag. Da declarations below show tha relationshizzlez between
classes. Which be a skanky chizzle?
(A) hood class Vehicle
{
}
private Tire[] tires;
private SteeringWheel sw;
(B) hood class Tire extendz Circle
{
//inherits methodz dat compute circumference
//and centa point
}
(C) hood class Hoopty extendz Vehicle
{
//inherits private Tire[] tires from Vehicle class
//inherits private SteeringWheel sw from Vehicle class
}
(D) hood class Tire
{
}
private Strin rating;
private Circle boundary;
(E) hood class SteeringWheel
{
//speed ratin of tire
private AirBag ab; //AirBag is stored up in SteeringWheel
private Circle boundary;
}
281
282 Chapta 5 Program Design n' Analysis
25 fo' realz. A Java programmer has completed a preliminary design fo' a big-ass program. The
programmer has pimped a list of classes, determined tha methodz fo' each class,
established tha relationshizzlez between classes, n' freestyled a intercourse fo' each
class. Which class(es) should be implemented first?
(A) Any superclasses
(B) Any subclasses
(C) All collaborator classes (classes dat is ghon be used ta implement other classes)
(D) Da class dat represents tha dominant object up in tha program
(E) All independent classes (classes dat have no references ta other classes)
Use tha program description below fo' Thangs 26-28.
A program is ta be freestyled dat simulates bumper rides up in a vizzle game. Da cars
move on a square grid n' is located on grid points (x, y), where x n' y is integers '
between -20 n' 20 fo' realz. A bumper hoopty moves up in a random direction, either left, right, up,
or down. I aint talkin' bout chicken n' gravy biatch. If it reaches a funky-ass boundary (i.e., x or y is ±20), then it reverses direction. I aint talkin' bout chicken n' gravy biatch. If it is
about ta collide wit another bumper car, it reverses direction. I aint talkin' bout chicken n' gravy biatch. Yo crazy-ass program should
be able ta add bumper rides n' run tha simulation. I aint talkin' bout chicken n' gravy biatch. One step of tha simulation allows
each hoopty up in tha grid ta move fo' realz. Afta a funky-ass bumper hoopty has reversed direction twice, its turn
is over n' tha next hoopty gets ta move.
26. To identify classes up in tha program, tha nouns up in tha justification is listed:
program, bumper car, grid, grid point, integer, direction, boundary,
simulation
How tha fuck nuff nouns up in tha list should immediately be discarded cuz they are
unsuitable as classes fo' tha program?
(A) 0
(B) 1
(C) 2
(D) 3
(E) 4
Multiple-Choice Thangs on Program Design n' Analysis
A programmer decides ta include tha followin classes up in tha program. Refer ta them
for Thangs 27 n' 28.
 Simulation will run tha simulation.
 Display will show tha state of tha game.
 BumperCar will know its identification number, posizzle up in tha grid, n' current
direction when moving.
 GridPoint is ghon be a posizzle up in tha grid. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is ghon be represented by two integer
fields, x_coord n' y_coord.
 Grid will keep track of all bumper rides up in tha game, tha number of cars, and
their positions up in tha grid. Y'all KNOW dat shit, muthafucka! Well shiiiit, it will update tha grid each time a cold-ass lil hoopty moves. Well shiiiit, it will
be implemented wit a two-dimensionizzle array of BumperCar.
27. Which operation should not be tha responsibilitizzle of tha GridPoint class?
(A) isEmpty returns false if grid point gotz nuff a BumperCar, true
otherwise
(B) at Boundary returns legit if x or y coordinizzle = ±20, false other-
WIse
(C) left if not at left boundary, chizzle grid point ta 1 unit left
of current point
(D) up if not at top of grid, chizzle grid point ta 1 unit above
current point
(E) get_x return x-coordinizzle of dis point
28. Which method aint suitable fo' tha BumperCar class?
(A) hood boolean atBoundaryO
IIReturns legit if BumperCar at boundary, false otherwise.
(B) hood void selectRandomDirection()
IISelect random direction (up, down, left, or right)
.11 at start of turn.
(C) hood void reverseDirection()
IIMova ta grid posizzle dat is up in direction opposite to
II current direction.
(D) hood void move()
IITake turn ta move. Right back up in yo muthafuckin ass. Quit move afta two chizzles
II of direction.
(E) hood void update()
IIModify Grid ta reflect freshly smoked up posizzle afta each stage
II of move.
283
284 Chapta 5 Program Design n' Analysis
f"C_~~&lt; !Aii.:.~b~
ANSWER KEY
B~~"+i_~:J-tJlOf!""J$ ~~.t'J.i&lt;~1i
1. E 11 fo' realz. A 21. E
2. D 12. D 22. D
3. E 13. B 23. C
4. E 14. D 24. B
5. B 15. C 25. E
6. C 16. C 26. C
7. C 17. D 27 fo' realz. A
8 fo' realz. A 18 fo' realz. A 28. E
9. D 19. C
10 fo' realz. A 20. D
ANSWERS EXPLAINED
1. (E) A programmer should never make unilateral decisions on some program justification.
When up in doubt, check wit tha thug whoz ass freestyled tha justification.
2. (0) In I n' Pt II a three-digit number is tha object bein manipulated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. For ill,
however, tha object be a s~x-characta string, which suggests a cold-ass lil class other than a
ThreeDigitNumber.
3. (E) Top-down programmin consistz of listin tha methodz fo' tha main object
and then rockin stepwise refinement ta break each method tha fuck into a list of subtasks.
Eliminizzle chizzlez A, C, n' D: Top-down programmin refers ta tha design and
plannin stage n' do not involve any actual freestylin of code. Chizzle B is closer
to tha mark yo, but "top-down" implies a list of operations, not a essay describing
the methods.
4. (E) All three considerations is valid when choosin a algorithm. ill is especially
important if yo' code is ghon be part of a larger project pimped by several
programmers. Yet even if yo ass is tha sole writa of a piece of software, be aware
that yo' code may one dizzle need ta be modified by others.
5. (B) A process dat causes excessive data movement is inefficient. Insertin an
element tha fuck into its erect (sorted) posizzle involves movin elements ta create a
slot fo' dis element. In da most thugged-out shitty case, tha freshly smoked up element must be banged tha fuck into the
first slot, which involves movin every last muthafuckin element up one slot. Right back up in yo muthafuckin ass. Similarly, deleting
an element involves movin elements down a slot ta close tha "gap." In tha worst
case, where tha straight-up original gangsta element is deleted, all elements up in tha array will need to
be moved. Y'all KNOW dat shit, muthafucka! Summin tha five smallest elements up in tha list means summin the
first five elements, n' you can put dat on yo' toast. This requires no testin of elements n' no excessive data
movement, so it is efficient. Findin tha maximum value up in a sorted list is hella
fast-just select tha element all up in tha appropriate end of tha list.
6. (C) "Robustness" implies tha mobilitizzle ta handle all data input by tha user n' to
give erect lyrics even fo' off tha hook jointz of data fo' realz. A program dat aint robust
Answers Explained
may well run on another computa without modification, n' a robust program
may need modification before it can run on another computa .
. 7. (C) Eliminizzle chizzle D cuz 0 be a invalid weight, n' you may infer from the
method description dat invalid data have already been screened out. Eliminate
choice E cuz it tests two joints up in tha range 10-25. (This aint wrong yo, but
choice C is better.) Eliminizzle chizzle A since it tests only tha endpoint joints.
. Eliminizzle B cuz it tests no endpoint joints.
8. (A) Da statement is syntactically erect yo, but as freestyled it aint gonna find the
mean of tha integers. Da bug is therefore a intent or logic error. Shiiit, dis aint no joke. To execute as
intended, tha statement needz parentheses:
double average = (n1 + n2 + n3 + n4) / (double) 4;
9. (D) Da error dat occurs be a run-time error caused by a attempt ta divide
by zero (ArithmeticException). Don't be fooled by chizzle C. Right back up in yo muthafuckin ass. Simply readin an
expression 8/0 from tha input file won't cause tha error. Shiiit, dis aint no joke. Note dat if tha operands
were of type double, tha erect answer would be E. In dis case, dividin by zero
does not cause a exception; it gives a answer of Infinity. Only on inspecting
the output would it be clear dat suttin' was wrong. '
10. (A) A precondizzle do not concern itself wit tha action of tha method, the
local variables, tha algorithm, or tha postcondition. I aint talkin' bout chicken n' gravy biatch. Nor do it initialize the
parameters. Well shiiiit, it simply asserts what tha fuck must be legit directly before execution of the
method.
11. (A) Da dopest case causes tha fewest computa operations, n' da most thugged-out shitty case
leadz ta tha maximum number of operations. In tha given algorithm, tha initial
test if (a1 &gt; a2) n' tha assignment ta max will occur irrespectizzle of which
value is tha phattest. Da second test, if (max &lt; a3), will also always occur. Shiiit, dis aint no joke. The
final statement, max = a3, will occur only if tha phattest value is up in a3; thus, this
represents da most thugged-out shitty case. Right back up in yo muthafuckin ass. So tha dopest case must have tha freshest value up in a1 or
a2.
12. (D) Da precondizzle be a assertion bout tha variablez up in tha loop just before
the loop is executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Variablez N, k, n' sum have all been initialized ta tha joints
shown up in chizzle D. Chizzle C is wack cuz k may equal N. Chizzle A is wrong
because k may be less than N. Chizzle E is wack cuz mean aint defined until
the loop has been exited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Chizzle B is wack cuz it omits tha assertions about
N andk.
13. (B) Note dat A n' B is tha only reasonable chizzles. Chizzle E thangs up in dis biatch up in an
infinite loop, n' chizzlez C n' D increment sum by 1 instead of by k. For chizzle
A, 1 be added ta sum up in tha straight-up original gangsta pass all up in tha loop, which is wrong; 2 should
be added. Y'all KNOW dat shit, muthafucka! Thus, k should be incremented before uppimpin sum. Note dat for
choice B afta tha straight-up original gangsta pass k = 2 n' sum = 1 + 2 fo' realz. Afta tha second pass, k =
3 n' sum = 1 + 2 + 3 fo' realz. Also note dat kz initial value is 1 n' final value on
exitin tha loop fo' tha last time is N, as up in tha given loop invariant.
14. (D) Eliminizzle chizzlez A, B, n' E since i is initialized ta 3 up in tha fo' loop.
Choice C is wack cuz tha value of i afta final exit from tha loop is n+1.
15. (C) Eliminizzle chizzlez D n' E, since tha loop invariant should include tha loop
variable up in its statement. Notice dat tha straight-up original gangsta exit from tha fo' loop has i = 4
and sum = 2, which is tha third Fibonacci number n' shit. In general, at each exit from
the loop, sum is equal ta tha (i-1)th Fibonacci number.
285
ABONLY
286
;. p"~ .::V. '
". .-~ 'W. ~-' &amp;. _.
Chapta 5 Program Design n' Analysis
16. (C) Deletin a cold-ass lil constant number of elements all up in tha end of a array is independent
of n, n' therefore 0(1). Don't let yo ass be caught by chizzle D: There is no
such thang as 0(2)!
17. (0) In da most thugged-out shitty case, every last muthafuckin element up in tha array is negative. Thus, tha number
of data moves is ghon be (n-l)+(n-2)+..+2+1 = n(n-l)/2. This be a quadratic
function, so tha algorithm is 0(n2) fo' realz. Alternatively, you can peep dat each of tha n
elements must be examined, n' up in tha average case it is moved bout n/2 places.
So again n' again n' again you git 0(n2). Note dat unless yo ass is specifically asked, you should
not quote tha order of tha dopest case-always assume most shitty case or average case
behavior yo. Here up in tha dopest case there be no wack joints up in tha list n' so no
data movements, n' you can put dat on yo' toast. Da algorithm is O(n).
18. (A) If n = 1000, log2 n ~ 10 since 210 ~ 1000.
19. (C) Da entire list of n integers must be examined once; thus, tha algorithm is
O(n).
20. (0) a is bein added ta total b times, which means dat all up in tha end of execution
total = a*b.
21. (E) Since count is incremented all up in tha end of tha loop, total = (count-1)*a, not
count*a. Thus, eliminizzle chizzlez Band D. Chizzle A is wack cuz count is
initialized ta 1, not o. Note dat afta tha final exit from tha loop, count has value
b+1, which eliminates chizzle C.
22. (0) It make sense fo' a Item ta be responsible fo' its name, unit price, quantity,
and total price. Well shiiiit, it aint reasonable fo' it ta be responsible fo' other Items. Boy it's gettin hot, yes indeed it is. Right back up in yo muthafuckin ass. Since
an ItemList, however, will contain shiznit fo' all tha Items purchased, it is
reasonable ta have it also compute tha total amountDue. Well shiiiit, it make just as much
sense ta give a Invoice tha responsibilitizzle fo' displayin shiznit fo' the
items purchased, as well as providin a gangbangin' final total, amountDue.
23. (C) Da is-a relationshizzle defines inheritance, while tha has-a relationshizzle defines
association. I aint talkin' bout chicken n' gravy biatch. These typez of relationshizzle is mutually exclusive. For example, a
graduate hustla is-a hustla. Well shiiiit, it don't make sense ta say a hustla has-a graduate
student!
24. (B) Even though itz convenient fo' a Tire object ta inherit Circle meth~, an
inheritizzle relationshizzle between a Tire n' a Circle is incorrect: It be false'to say
that a Tire is-a Circle fo' realz. A Tire be a cold-ass lil hoopty part, while a Circle be a geometric shape.
Notice dat there be a association relationshizzle between a Tire n' a Circle: A
Tire has-a Circle as its boundary.
25. (E) Independent classes aint gots relationshizzlez wit other classes n' can
therefore be mo' easily coded n' tested.
26. (C) Da word "program" is never included when itz used up in dis context. The
word "integer" raps bout tha type of coordinates x n' y n' has no further use
in tha justification. I aint talkin' bout chicken n' gravy biatch. While lyrics like "direction," "boundary," n' "simulation"
may lata be removed from consideration as classes, it aint unreasonable ta keep
them as muthafuckas while you ponder tha design.
27. (A) A GridPoint object knows only its x n' y coordinates. Well shiiiit, it has no shiznit
about whether a 8umperCar be at dat point. Notice dat operations up in all of
the other chizzlez depend on tha x n' y coordinatez of a GridPoint object fo' realz. An
isEmpty method should be tha responsibilitizzle of tha Grid class dat keeps track of
Answers Explained
the statuz of each posizzle up in tha grid.
28. (E) A BumperCar is responsible fo' itself-keepin track of its own position, selecting
an initial direction, bustin a move, n' reversin direction. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it is not,
however, responsible fo' maintainin n' uppimpin tha grid. Y'all KNOW dat shit, muthafucka! That should be done
by tha Grid class.
287
Arra ys n' Array Lists CHAPTER &amp;
288
....~ r~~~j. ................
Should array indices start at 0 or 1?
My fuckin compromise of 0.5 was rejected,
without, I thought, proper consideration.
-So Kelly-Bootie
Chapta Goals
 One-dimensionizzle arrays  Two-dimensionizzle arrays
 Da ArrayList<e> class
ONE-DIMENSIONAL ARRAYS
An array be a thugged-out data structure used ta implement a list object, where tha elements up in the
list iz of tha same type; fo' example, a cold-ass lil class list of 25 test scores, a membershizzle list of
100 names, or a store inventory of 500 items.
For a array of N elements up in Java, index joints ("subscripts") go from a ta N - 1.
Individual elements is accessed as bigs up: If arr is tha name of tha array, tha elements
are arr [0], arr [1], ... , arr [N-1]. If a wack subscript is used, or a subscript k where
k 2: N, a ArraylndexOutOfBoundsException is thrown.
Initialization
In Java, a array be a object; therefore, tha keyword freshly smoked up must be used up in its creation.
Da size of a array remains fixed once it has been pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. As wit Strin objects,
however, a array reference may be reassigned ta a freshly smoked up array of a gangbangin' finger-lickin' different size.
Example
All of tha followin is equivalent. Each creates a array of 25 double joints and
assigns tha reference data ta dis array.
1. double[] data = freshly smoked up double[25]i
2. double data[] = freshly smoked up double[25]i
3. double[] data;
data = freshly smoked up double[25]i
A subsequent statement like
One-Dimensionizzle Arrays
data = freshly smoked up double[40);
reassigns data ta a freshly smoked up array of length 40. Da memory allocated fo' tha previous
data array is recycled by Javaz automatic garbage collection system.
When arrays is declared, tha elements is automatically initialized ta zero fo' the
primitizzle numeric data types (int n' double), ta false fo' boolean variables, or to
null fo' object references.
It be possible ta declare nuff muthafuckin arrays up in a single statement. For example,
int[) intList1, intList2; //declares intList1 n' intList2 to
//contain int joints
int[) arr1 = freshly smoked up int[15) , arr2 = freshly smoked up int[30); //reserves 15 slots
//for arr1, 30 fo' arr2
INITIALIZER LIST
Lil Small-Ass arrays whose joints is known can be declared wit a initializer list. For example,
instead of writing
int[) coins = freshly smoked up int[4);
coins [0) 1;
coins [1) 5;
coins [2) 10;
coins [3) 25;
you can write
int[) coins = {1, 5, 10, 25};
This construction is tha one case where freshly smoked up aint required ta create a array.
Length of Array
A Java array has a gangbangin' final hood instizzle variable (i.e., a cold-ass lil constant), length, which can be
accessed when you need tha number of elements up in tha array. For example,
String[) names = freshly smoked up String[25) ;
&lt; code ta initialize names &gt;
//loop ta process all names up in array
for (int i = 0; i &lt; names.length; i++)
<process names="">
NOTE
1. Da array subscripts go from 0 ta names .length-1; therefore, tha test on i in
the f or loop must be strictly less than names . length.
2. length aint a method n' therefore aint followed by parentheses. Contrast
this wit Strin objects, where length be a method n' must be followed by
parentheses. For example,
Strin s "Confusin syntax!";
int size s.length(); //assigns 17 ta size
289
290
Do not bust a gangbangin' for-each
loop ta remove or
replace elements of
an array.
Chapta 6 Arrays n' Array Lists
Traversin a Array
Use a gangbangin' for-each loop whenever you need access ta every last muthafuckin element up in a array without
replacin or removin any elements, n' you can put dat on yo' toast. Use a gangbangin' fo' loop up in all other cases: ta access the
index of any element, ta replace or remove elements, or ta access just a shitload of the
elements.
Note dat if you have a array of objects (not primitizzle types), you can use tha foreach
loop n' mutator methodz of tha object ta modify tha fieldz of any instizzle (see
the shuffleAll method on p. 294).
Example 1
//Return tha number of even integers up in array arr of integers.
hood static int countEven(int[) arr)
{
}
int count = 0;
for (int num : arr)
if ( num % 2
count++;
return count;
0) //num is even
Example 2
//Change each even-indexed element up in array arr ta O.
//Precondition: arr gotz nuff integers .
//Postcondition: arr[O), arr(2), arr(4) , . . . have value O.
hood static void chizzleEven(int[) arr)
{
}
for (int i = 0; i &lt; arr.length; i += 2)
arr[i) = 0;
Arrays as Parameters
Since arrays is treated as objects, passin a array as a parameta means passin its
object reference. No copy is made of tha array. Thus, tha elementz of tha actual array
can be accessed-and modified.
Example 1
Array elements accessed but not modified:
//Return index of smallest element up in array arr of integers.
hood static int findMin (int[) arr)
{
}
int min = arr[O);
int minlndex = 0;
for (int i = 1; i &lt; arr.length; i++)
if (arr[i) &lt; min) //found a smalla element
{
}
min = arr [i) ;
minlndex = i;
return minIndex;
To call dis method (in tha same class dat itz defined):
One-Dimensionizzle Arrays
int (] array j
&lt; code ta initialize array &gt;
int min = findMin(arraY)j
NOTE
An alternatizzle header fo' tha method is
hood static int findMin(int arr[])
Example 2
Array elements modified:
//Add 3 ta each element of array b.
hood static void chizzleArray(int[] b)
{
}
for (int i = OJ i &lt; b.lengthj i++)
b[i] += 3j
To call dis method (in tha same class):
int[] list = {1, 2, 3, 4}j
changeArray(list)j
System.out.print("Da chizzled list is Pt II)j
for (int num : list)
System.out.print(num + Pt II Pt II)j
Da output produced is
Da chizzled list is 4 5 S 7
Look all up in tha memory slots ta peep how tha fuck dis happens:
Before tha method call:
list [J---.I11213141
Just before exitin tha method:
list [J---.14151s171
D
Example 3
At tha start of tha method call:
list [J---.I1 21 3141 o
Afta exitin tha method:
list [J---.14151s171
Contrast tha chizzleArray method wit tha followin attempt ta modify one array
element:
//Add 3 ta a element.
hood static void chizzleElement(int n)
{ n += 3j }
Here is some code dat invokes dis method:
291
When a array is
passed as a parameter,
it is possible ta alter
the contentz of the
array.
292
int[] list = {1, 2, 3, 4};
System.out.print("Original Gangsta array: Pt II);
for (int num : list)
System.out.print(num + Pt II Pt II);
changeElement(list[O]);
System.out.print("\nModified array: Pt II);
for (int num : list)
System.out.print(num + Pt II Pt II);
Chapta 6 Arrays n' Array Lists
Contrary ta tha programmerz expectation, tha output is
Original Gangsta array: 1 2 3 4
Modified array: 1 2 3 4
A peep tha memory slots shows why tha list remains unchanged.
Before tha method call:
Just before exitin tha method:
list []--.111213141
n
~
At tha start of tha method call:
list []--.111213141
n o
Afta exitin tha method:
list []--.111213141
Da point of dis is dat primitizzle types-includin single array elementz of type int
or double-are passed by value fo' realz. A copy is made of tha actual parameter, n' tha copy
is erased on exitin tha method.
Example 4
//Swap arr[i] n' arr[j] up in array arr.
hood static void swap(int[] arr, int i, int j)
{
}
int temp = arr[i];
arr[i] = arr[j];
arr[j] = temp;
To call tha swap method:
int [] list = {1, 2, 3, 4};
swap(list, 0, 3);
System.out.print("Da chizzled list is: Pt II);
for (int num : list)
System.out.print(num + Pt II Pt II);
Da output shows dat tha program hit dat shiznit as intended:
Da chizzled list is: 4 2 3 1
One-Dimensionizzle Arrays
ExampleS
IIPrecondition: Array undefined.
IIPostcondition: Returns array containin NUM_ELEMENTS integers
II read from tha keyboard.
hood int[] getlntegers()
{
}
int[] arr = freshly smoked up int[NUM_ELEMENTS];
for (int i = 0; i &lt; arr.length; i++)
{
System.out.println("Enta integer: Pt II);
arr[i] = IO.readlnt(); Ilread user input
}
return arr;
To call dis method:
int[] list = getlntegers();
Array Variablez up in a Class
Consider a simple Deck class up in which a thugged-out deck of cardz is represented by tha integers 0
to 51.
hood class Deck
{
private int[] myDeck;
hood static final int NUMCARDS = 52;
II constructor
hood Deck 0
{
}
myDeck = freshly smoked up int[NUMCARDS];
for (int i = 0; i &lt; NUMCARDS; i++)
myDeck[i] = i;
IIWrite contentz of Deck.
hood void writeDeck()
{
}
for (int card : myDeck)
System.out.print(card + Pt II Pt II);
System.out.println();
System.out.println();
IISwap arr[i] n' arr[j] up in array arr.
private void swap(int[] arr, int i, int j)
{
}
int temp = arr[i];
arr [i] = arr [j] ;
arr[j] = temp;
293
294
}
Chapta 6 Arrays n' Array Lists
IIShuffle Deck: Generate a random permutation by pickin a
II random card from dem remainin n' puttin it up in the
II next slot, startin from tha right.
hood void shuffle()
{
}
int index;
for (int i = NUMCARDS - 1; i &gt; 0; i--)
{
}
Ilgenerate a int from 0 ta i
index = (int) (Math.random() * (i + 1»;
swap (myDeck, i, index);
Here be a simple driver class dat tests tha Deck class:
hood class DeckMain
{
}
hood static void main(Strin args[])
{
}
Deck d = freshly smoked up Deck();
d.shuffleO;
d. Y'all KNOW dat shit, muthafucka! wri teDeck 0 ;
NOTE
There is no evidence of tha array dat holdz tha deck of cards-myDeck be a private
instizzle variable n' is therefore invisible ta clientz of tha Deck class.
Array of Class Objects
Suppose a big-ass card tournament need ta keep track of nuff decks. Da code ta do
this could be implemented wit a array of Deck:
hood class ManyDecks
{
private Deck[] allDecks;
hood static final int NUMDECKS = 500;
II constructor
hood ManyDecks()
{
}
allDecks = freshly smoked up Deck[NUMDECKS];
for (int i = 0; i &lt; NUMDECKS; i++)
allDecks[i] = freshly smoked up Deck();
IIShuffle tha Decks.
hood void shuffleAll()
{
}
for (Deck d : allDecks)
d.shuffleO;
One-Dimensionizzle Arrays
}
//Write contentz of all tha Decks.
hood void printDecks()
{
}
for (Deck d : allDecks)
d. Y'all KNOW dat shit, muthafucka! writeDeckO;
NOTE
Da statement
allDecks = freshly smoked up Deck [NUMDECKS] ;
creates a array, allDecks, of 500 Deck objects, n' you can put dat on yo' toast. Da default initialization fo' these Deck
objects is null. In order ta initialize dem wit actual decks, tha Deck constructor must
be called fo' each array element. This be  bigged up  wit tha fo' loop of tha ManyDecks
constructor.
Analyzin Array Algorithms
Example 1
(a) Discuss tha efficiency of tha countNegs method below. What is tha dopest and
worst case configurationz of tha data?
(b) What tha fuck iz tha big-O run time?
//Precondition: arr[O], ... ,arr[arr.length-1] contain integers.
//Postcondition: Number of wack joints up in arr has been returned.
hood static int countNegs(int[] arr)
{
}
int count = 0;
for (int num : arr)
if (num &lt; 0)
count++;
return count;
Solution:
(a) This algorithm sequentially examines each element up in tha array. In tha best
case, there be no wack elements, n' count++ is never executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. In the
worst case, all tha elements is negative, n' count++ is executed up in each pass
of tha fo' loop.
(b) Da run time is O( n), since each element up in tha list is examined.
Example 2
Da code fragment below bangs a value, num, tha fuck into its erect posizzle up in a sorted
array of integers.
(a) Discuss tha efficiency of tha algorithm.
(b) What tha fuck iz tha big-O run time of tha algorithm?
(c) What tha fuck iz tha loop invariant of tha while loop?
295
ABONLY
ABONLY
ABONLY
296 Chapta 6 Arrays n' Array Lists
IIPrecondition: arr[0], ... ,arr[n-1] contain integers sorted in
II increasin order n' shit. n &lt; arr.length.
IIPostcondition: num has been banged up in its erect position.
{
}
Ilfind insertion point
int i = 0;
while (i &lt; n &amp;&amp; num &gt; arr[i])
i++;
Ilif necessary, move elements arr[i] ... arr[n-1] up 1 slot
for (int j = n; j &gt;= i + 1; j--)
arr[j] = arr[j-1];
Ilinsert num up in i-th slot n' update n
arr[i] = num;
n++;
Solution:
(a) In tha dopest case, n~ is pimped outa than all tha elements up in tha array: Because it gets
inserted all up in tha end of tha list, no elements must be moved ta create a slot fo' dat shit.
Da most shitty case has num less than all tha elements up in tha array. In dis case, num
must be banged up in tha straight-up original gangsta slot, arr [0] , n' every last muthafuckin element up in tha array must
be moved up one posizzle ta create a slot.
This algorithm illustrates a gangbangin' finger-lickin' disadvantage of arrays: Insertion n' deletion
of a element up in a ordered list is inefficient, since, up in da most thugged-out shitty case, it may
involve movin all tha elements up in tha list.
(b) Insertion or deletion of a single element up in a ordered list is O(n). Note that
if n elements must be banged (or deleted) wit dis algorithm, tha algorithm
becomes O(n2).
(c) Da loop invariant fo' tha while loop is
num &gt; arr[O], num &gt; arr[l], ... , num &gt; arr[i-1], where 0 SiS n
Loop invariants fo' array algorithms can be sickly illustrated wit a gangbangin' finger-lickin' diagram
showin a snapshot of what tha fuck is happening. Each rectangle represents a portion
of array arr. Shiiit, dis aint no joke. Da labels on top of tha rectangle is array indexes fo' elements
at tha beginnin n' end of each portion. I aint talkin' bout chicken n' gravy biatch yo. Here is tha diagram dat illustrates
this loop invariant:
o i-1 i n-1
! num &gt; all elements up in here , still ta be examined
~---.----.-- - -... -.. -- .. ----.--.- ---.T --- ~
~ .. _ .. __ ._._ ... _ ... . _ ... .. __ 1. ..... _ ._------
...... __ .. ____ ma_.~.MMMu~~mM .......... ____ ................ _
ARRAY LISTS
This section gotz nuff tha material dat Level A hustlas need ta know. Level AB
students should also peep Chapta 11 fo' a gangbangin' fulla rap of ArrayList n' tha other
container classes.
Array Lists
Da ArrayList Class
Da ArrayList class is part of java. util, one of Javaz standard packages fo' realz. An
ArrayList serves up a alternatizzle way of storin a list of objects n' has tha following
advantages over a array:
 An ArrayList shrinks n' grows as needed up in a program, whereas a array has
a fixed length dat is set when tha array is pimped.
 In a ArrayList list, tha last slot be always list.sizeO-l, whereas up in a partially
filled array, you, tha programmer, must keep track of tha last slot currently
10 use.
 For a ArrayList, you can do insertion or deletion wit just a single statement.
Any shiftin of elements is handled automatically. In a array, however, insertion
or deletion requires you ta write tha code dat shifts tha elements.
Generics
In Java 5.0, tha ArrayList class is generic, which means dat it has a type parameter.
Here is part of tha class header fo' ArrayList:
hood class ArrayList<e> ...
Da type parameta E acts as a placeholda fo' any nonprimitizzle type. Da type must
be defined whenever a ArrayList is used up in a program. Da main scam behind dis is
that you express yo' intent dat tha list is ghon be restricted ta a particular data type fo' realz. At
compile time, tha types is checked n' tha compila keeps track of tha element type,
eliminatin tha need fo' castin when you access objects up in tha list fo' realz. All dis provides
built-in type safety fo' yo' programs. Boy it's gettin hot, yes indeed it is. Note dat arrays up in Java aint gots dis generic
feature.
Da Methodz of ArrayList
Yo ass should know tha followin methods:
, ArrayList 0 I
Constructs a empty list.
lint sizeO I
Returns tha number of elements currently up in tha list.
'boolean add(E obj) I
Appendz obj ta tha end of tha list fo' realz. Always returns true.
'E get(int index) I
Returns tha element all up in tha specified index up in tha list.
Do not use type
parametas with
arrays.
297
298 Chapta 6 Arrays n' Array Lists
IE set(int index, E element) I
Replaces tha item at a specified index up in tha list wit tha specified element. Returns
the element dat was previously at index.
I void add(int index, E element) I
Inserts element all up in tha specified index up in tha list. If tha insertion aint all up in tha end of
the list, shifts tha element currently at dat posizzle n' all elements followin it one
unit ta tha right (i.e., addz 1 ta they indexes) fo' realz. Adjusts tha size of tha list.
IE remove(int index) I
Removes n' returns tha element all up in tha specified index up in tha list. Right back up in yo muthafuckin ass. Shifts all elements
followin dat element one unit ta tha left (i.e., subtracts 1 from they indexes) fo' realz. Adjusts
the size of tha list.
NOTE
Each method above dat has a index parameter-add, get, remove, n' set-throws
an IndexOutOfBoundsException if index is outta range. For get, remove, n' set, .
index is outta range if
index &lt; 0 I I index &gt;= size()
For add, however, it is OK ta add a element all up in tha end of tha list. Therefore, index is
out of range if
index &lt; 0 I I index&gt; size()
Auto-Boxin n' -Unboxing
Recall dat a ArrayList must contain objects, not primitizzle types like double and
into Numbers must therefore be boxed-placed up in wrapper classes like Integer and
Double-before insertion tha fuck into a ArrayList.
Auto-boxin is tha automatic wrappin of primitizzle types up in they wrapper classes.
To retrieve tha numerical value of a Integer (or Double) stored up in a ArrayList,
the intValueO (or doubleValueO) method must be invoked.
Auto-unboxin is tha automatic conversion of a wrapper class ta its corresponding
primitizzle type. Be aware dat if a program tries ta auto-unbox null, tha method will
throw a NullPointerException.
Note dat while auto-boxin n' -unboxin cut down on code clutter, these operations
must still be performed behind tha scenes, leadin ta decreased run-time efficiency.
It be much mo' efficient ta assign n' access primitizzle types up in a array than
an ArrayList. Yo ass should therefore consider rockin a array fo' a program dat manipulates
sequencez of numbers n' do not need ta use objects.
NOTE
Auto-boxin n' -unboxin be a freshly smoked up feature up in Java 5.0 n' aint gonna be tested on the
AP exam. Well shiiiit, it is OK, however, ta use dis convenient feature up in code dat you write in
the free-response thangs.
Two-Dimensionizzle Arrays
Usin ArrayList
Example 1
//Smoke a ArrayList containin 0 1 4 9.
ArrayList<integer> list = freshly smoked up ArrayList<integer>();
for (int i = 0; i &lt; 4; i++)
list.add(i * i); //example of auto-boxing
//i*i wrapped up in a Integer before insertion
Integer intOb = list.get(2); //assigns Integer wit value 4 ta intOb.
//Leaves list unchanged.
int n = list.get(3); //example of auto-unboxing
//Integer is retrieved n' converted ta int
//n gotz nuff 9
Integer x = list.set(3, 5); //list is 0 145
x = list.remove(2);
//x gotz nuff Integer wit value 9
//list is 0 1 5
list.add(l, 7);
list.add(2, 8);
//x gotz nuff Integer wit value 4
//list is 0 7 1 5
//list is 0 7 8 1 5
Example 2
//Traversin a ArrayList of Integer.
//Print tha elementz of list, one per line.
for (Integer i : list)
System.out.println(i);
Example 3
/* Precondition: ArrayList list gotz nuff Integer joints
* sorted up in increasin order.
* Postcondition: value banged up in its erect posizzle up in list. */
hood static void insert(ArrayList<integer> list, Integer value)
{
}
NOTE
int index = 0;
//find insertion point
while (index &lt; list.size() &amp;&amp;
value.compareTo(list.get(index)) &gt; 0)
index++;
//insert value
list. add (index , value);
Suppose value is larger than all tha elements up in list. Then tha bang method will
throw a IndexOutOfBoundsException if tha straight-up original gangsta part of tha test is omitted, namely
index &lt; list.size().
4S r k. we
TWO-DIMENSIONAL ARRAYS
 ..,,1 1fJ9'
A two-dimensionizzle array (matrix) is often tha data structure of chizzle fo' objects like
board games, tablez of joints, theata seats, n' mazes.
Look all up in tha followin 3 x 4 matrix:
299
ABONLY
300
, ""  t,~ .'}.' -..:.r'f  r.
, ,
~  ~ ... ,  A
Chapta 6 Arrays n' Array Lists
2 6 8 7
1 540
9 3 2 8
If mat is tha matrix variable, tha row subscripts go from 0 ta 2 n' tha column subscripts
go from 0 ta 3. Da element mat [1] [2] is 4, whereas mat [0] [2] n' mat [2] [3]
are both 8 fo' realz. As wit one-dimensionizzle arrays, if tha subscripts 'are outta range an
ArraylndexOutOfBoundsExceptionisthrown.
Declarations
Each of tha followin declares a two-dimensionizzle array:
int[] [] table; //table can reference a 2-D array of integers
//table is currently a null reference
doubler] [] matrix = freshly smoked up double [3] [4]; //matrix references a 3 x 4
//array of real numbers.
//Each element has value 0.0
String[][] strs = freshly smoked up String[2] [5]; //strs references a 2 x 5
//array of Strin objects.
/ /Each element is null .
An initializer list can be used ta specify a two-dimensionizzle array:
int[][] mat = { {3, 4, 5}, //row 0
{S, 7, 8} }; //row 1
This defines a 2 x 3 rectangular array (i.e., one up in which each row has tha same ol' dirty number
of elements).
Da initializer list be a list of lists up in which each inside list represents a row of the
matrix. Right back up in yo muthafuckin ass. Since a matrix is implemented as a array of rows (where each row be a onedimensional
array of elements), tha quantitizzle mat . length represents tha number of
rows. For any given row k, tha quantitizzle mat [k] . length represents tha number of
elements up in dat row, namely tha number of columns. a ava allows a variable number
of elements up in each row. Right back up in yo muthafuckin ass. Since these "jagged arrays" is not part of tha AP Java subset,
you can assume dat mat [k] . length is tha same ol' dirty fo' all rows k of tha matrix, i.e., that
the matrix is rectangular.)
Processin a Two-Dimensionizzle Array
Example 1
Find tha sum of all elements up in a matrix mat.
//Precondition: mat is initialized wit integer joints.
int sum = 0;
for (int r = 0; r &lt; mat.length; r++)
NOTE
for (int c = 0; c &lt; mat[r] . length; c++)
sum += mat[r] [c];
1. mat [r] [c] represents tha rth row n' tha cth column.
2. Rows is numbered from 0 ta mat .length-l, n' columns is numbered from
o ta mat [r] .1ength-1 fo' realz. Any index dat is outside these boundz will generate an
ArraylndexOutOfBoundsException.
3. Right back up in yo muthafuckin ass. Since elements is not bein replaced, nested for-each loops can be used instead:
Two-Dimensionizzle Arrays
for (int[] row: mat) Ilfor each row array up in mat
for (int element: row) Ilfor each element up in dis row
sum += element;
4. Da AP Java subset do not include nested for-each loops fo' two-dimensional
arrays. Yo ass can, however, use dis construct up in free-response thangs where
applicable-use it fo' accessin each element yo, but not fo' replacin or removing
elements.
Example 2
Add 10 ta each element up in row 2 of matrix mat.
for (int c = 0; c &lt; mat[2].length; c++)
mat [2] [c] += 10;
NOTE
1. In tha fo' loop, you can use c &lt; mat [k] . length, where a ::s k &lt; mat . length,
since each row has tha same ol' dirty number of elements.
2. Yo ass cannot bust a gangbangin' for-each loop here cuz elements is bein replaced.
Example 3
Da major n' minor diagonalz of a square matrix is shown below:
Major diagonal Minor diagonal
Yo ass can process tha diagonals as bigs up:
int[] [] mat = freshly smoked up int[SIZE] [SIZE]; Pt IISIZE be a cold-ass lil constant int value
for (int i = 0; i &lt; SIZE; i++)
Process mat [i] [i] ; Ilmaj or diagonal
OR
Process mat[i] [SIZE - i - 1]; Ilminor diagonal
Two-Dimensionizzle Array as Parameter
Example 1
Here be a method dat counts tha number of wack joints up in a matrix.
IIPrecondition: mat is initialized wit integers.
IIPostcondition: Returns count of wack joints up in mat.
hood static int countNegs (int[] [] mat)
{
}
int count = 0;
for (int[] row: mat)
for (int element : row)
if (element &lt; 0)
count++;
return count;
301
302 Chapta 6 Arrays n' Array Lists
A method up in tha same class can invoke dis method wit a statement such as
int negs = countNegs(mat)j
Example 2
Readin elements tha fuck into a matrix:
IIPrecondition: Number of rows n' columns known.
IIReturns matrix containin rows x cols integers
II read from tha keyboard. Y'all KNOW dat shit, muthafucka! '
hood static int[] [] getMatrix(int rows, int cols)
{
}
int[] [] mat = freshly smoked up int[rows] [cols]j Ilinitialize slots
System.out.println("Enta matrix, one row per line:")j
System.out.println()j
Ilread user input n' fill slots
for (int r = OJ r &lt; rOWSj r++)
for (int c = OJ c &lt; colsj c++)
mat[r] [c] = IO.readlnt()j Ilread user input
return matj
To call dis method:
Ilprompt fo' number of rows
int rows = IO.readlnt()j
and columns
int cols = IO.readlnt()j
int[] [] mat = getMatrix(rows,
Ilread user input
Ilread user input
cols)j
Chapta Summary
awuz L Ii,... -- FT
Manipulation of one-dimensionizzle arrays n' array lists should be second nature to
you by now, nahmeean, biatch? Know tha Java subset methodz fo' tha ArrayList<e> class. Yo ass must
also know when these methodz throw a IndexOutOfBoundsException n' when an
ArraylndexOutOfBoundsException can occur.
Be shizzle you KNOW dat a gangbangin' for-each loop can only be used fo' traversal if you
wish ta access each element up in a list without replacin or removin any elements.
Level AB hustlas only should be able ta manipulate n' traverse two-dimensional
arrays.
Multiple-Choice Thangs on Arrays n' Array Lists
MULTIPLE-CHOICE QUESTIONS ON ARRAYS AND
ARRAY LISTS
1. Which of tha followin erectly initializes a array arr ta contain four elements
each wit value o?
I int[] arr = {O, 0, 0, O};
II int[] arr = freshly smoked up int[4];
III int[] arr = freshly smoked up int[4];
for (int i = 0; i &lt; arr.length; i++)
arr[i] = 0;
(A) I only
(B) Pt III only
(C) I n' Pt III only
(D) Pt II n' Pt III only
(E) I, Pt II, n' Pt III
2. Da followin program segment is intended ta find tha index of tha straight-up original gangsta negative
integer up in arr [0] ... arr [N-l] , where arr be a array of N integers.
int i = 0;
while (arr[i] &gt;= 0)
{
i++;
}
location = i;
This segment will work as intended
(A) always.
(B) never.
(C) . whenever arr gotz nuff at least one wack integer.
(D) whenever arr gotz nuff at least one nonnegatizzle integer.
(E) whenever arr gotz nuff no wack integers.
3. Refer ta tha followin code segment. Yo ass may assume dat arr be a array of int
values.
int sum = arr[O] , i = 0;
while (i &lt; arr.length)
{
i++;
sum += arr [i) ;
}
Which of tha followin is ghon be tha result of executin tha segment?
(A) Sum of arr [0], arr [1], ... , arr [arr . length-i) is ghon be stored up in sum.
(B) Sum of arr [1], arr [2], ... , arr [arr . length-i) is ghon be stored up in sum.
(C) Sum of arr [0], arr [1], ... , arr [arr . length] is ghon be stored up in sum.
(D) An infinite loop will occur.
(E) A run-time error will occur.
303
304 Chapta 6 Arrays n' Array Lists
4. Da followin code fragment is intended ta find tha smallest value in
arr [0] ... arr [n-1].
//Precondition: arr[O] ... arr[n-1] initialized wit integers.
/ / arr be a array. arr . length = n.
//Postcondition: min = smallest value up in arr[O] ... arr[n-1].
int min = arr[O];
int i = 1;
while (i &lt; n)
{
}
i++;
if (arr[i]&lt; min)
min = arr[i];
This code is incorrect. For tha segment ta work as intended, which of tha following
modifications could be made?
I Chizzle tha line
int i = 1;
to
int i = 0;
Make no other chizzles.
II Chizzle tha body of tha while loop to
{
}
if (arr[i] &lt; min)
min = arr [i] ;
i++;
Make no other chizzles.
m Chizzle tha test fo' tha while loop as bigs up:
while (i &lt;= n)
Make no other chizzles.
(A) I only
(B) Pt II only
(C) monly
(D) I n' Pt II only
(E) I, Pt II, n' m
Multiple-Choice Thangs on Arrays n' Array Lists
Thangs 5 n' 6 refer ta tha followin code segment. Yo ass may assume dat array
arr1 gotz nuff elements arr1 [0] , arr1 [1], ... , arr1 [N-1] , where N = arr1.length.
int count = 0;
for (int i = 0; i &lt; N; i++)
if (arri[i) != 0)
{
}
arri[count] = arri[i);
count++;
int[) arr2 = freshly smoked up int[count];
for (int i = 0; i &lt; count; i++)
arr2[i] = arri[i];
5. If array arri initially gotz nuff tha elements 0, 6, 0, 4, 0, 0, 2 up in dis order, what
will arr2 contain afta execution of tha code segment?
(A) 6,4,2
(B) 0, 0, 0, 0, 6, 4, 2
(C) 6,4,2,4,0,0,2
OJ) 0,6,0,4,0,0,2
(E) 6,4,2,0,0,0,0
6. Da algorithm has run time
(A) 0(N2)
(B) O(N)
(C) 0(1)
OJ) O(logN)
(E) O(NlogN)
7. Consider dis program segment:
for (int i = 2; i &lt;=" k; i++)
if (arr[i) &lt; someValue)
System.out.print("SMALL");
What tha fuck iz tha maximum number of times dat SMALL can be printed?
(A) 0
(B) 1
(C) k - 1
OJ) k - 2
(E) k
305
ABONLY
306 Chapta 6 Arrays n' Array Lists
8. What tha fuck iz ghon be output from tha followin code segment, assumin it is up in tha same
class as tha doSomethang method?
int[] arr = {1, 2, 3, 4};
doSomething(arr);
System.out.print(arr[1] + Pt II Pt II);
System.out.print(arr[3]).;
hood void doSomething(int[] list)
{
}
int[] b = list;
for (int i = 0; i &lt; b.length; i++)
b[i] = i;
(A) 0 0
(B) 2 4
(C) 1 3
(D) 0 2
(E) 0 3
9. Consider freestylin a program dat readz tha linez of any text file tha fuck into a sequential
list of lines. Which of tha followin be a phat reason ta implement tha list with
an ArrayList of Strin objects rather than a array of Strin objects?
(A) Da git n' set methodz of ArrayList is mo' convenient than tha []
notation fo' arrays.
(B) Da size method of ArrayList serves up instant access ta tha length of the
list.
(C) An ArrayList can contain objectz of any type, which leadz ta pimped outa generality.
(D) If any particular text file is unexpectedly long, tha ArrayList will automatically
be resized. Y'all KNOW dat shit, muthafucka! Da array, by contrast, may go outta bounds.
(E) Da Strin methodz is easier ta use wit a ArrayList than wit a array.
10. Consider freestylin a program dat produces statistics fo' long listz of numerical
data. Which of tha followin is tha dopest reason ta implement each list wit a array
of int (or double), rather thin a ArrayList of Integer (or Double) objects?
(A) An array of primitizzle number types is mo' efficient ta manipulate than an
ArrayList of wrapper objects dat contain numbers.
(B) Insertion of freshly smoked up elements tha fuck into a list is easier ta code fo' a array than for
an ArrayList.
(C) Removal of elements from a list is easier ta code fo' a array than fo' an
ArrayList.
(D) Accessin individual elements up in tha middle of a list is easier fo' a array
than fo' a ArrayList.
(E) Accessin all tha elements is mo' efficient up in a array than up in a ArrayList.
Multiple-Choice Thangs on Arrays n' Array Lists
Refer ta tha followin classes fo' Thangs 11-14.
hood class Address
{
}
private Strin myName;
private Strin myStreet;
private Strin myCity;
private Strin myState;
private Strin myZip;
//constructors
//accessors
hood Strin getName()
{ return myName; }
hood Strin getStreet()
{ return myStreet; }
hood Strin getCity()
{ return myCity; }
hood Strin getState()
{ return myState; }
hood Strin getZip()
{ return myZip; }
hood class Student
{
}
private int idNum;
private double gpa;
private Address myAddress;
//constructors
//accessors
hood Address getAddress()
{ return myAddress; }
hood int getldNum()
{ return idNum; }
hood double getGpa()
{ return gpa; }
307
308 Chapta 6 Arrays n' Array Lists
11 fo' realz. A client method has dis declaration, followed by code ta initialize tha list:
Address [] list = freshly smoked up Address [100] j
Here be a cold-ass lil code segment ta generate a list of names only.
for (Address a : list)
I * line of code * I
Which be a cold-ass lil erect 1* line of code */?
(A) System.out.println(Address[i] .getName(»j
(B) System.out.println(list[i].getName(»j
(C) System.out.println(a[i].getName(»j
0) System.out.println(a.getName(»j
(E) System.out.println(list.getName(»j
12. Da followin code segment is ta print up a list of addresses:
for (Address addr : list)
{
1* mo' code *1
}
Which be a cold-ass lil erect replacement fo' 1* mo' code */?
I System.out.println(list[i] .getName(»j
System.out.println(list[i] .getStreet(»j
System. out. print (list [i] . getCi ty 0 + ", ") j
System. out. print (list [i] . getState 0 + Pt II ") j
System.out.println(list[i] .getZip(»j
IT System.out.println(addr.getName(»j
System.out.println(addr.getStreet(»j
System. out.print (addr. Shiiit, dis aint no joke. getCit yO + ", Pt II) j
System. out. print (addr . getState 0 + Pt II ") j
System.out.println(addr.getZip(»j
III System.out.println(addr)j
(A) I only
(B) IT only
(C) Pt III only
0) I n' IT only.
(E) I, IT, n' Pt III
Multiple-Choice Thangs on Arrays n' Array Lists
13 fo' realz. A client method has dis declaration:
Student[) allStudents = freshly smoked up Student[NUM_STUDS)j //NUM_STUDS is
//an int constant
Here be a cold-ass lil code segment ta generate a list of Student names only. (Yo ass may assume
that a11Students has been initialized.)
for (Student hustla : aIIStudents)
/ * code ta print list of names * /
Which be a cold-ass lil erect replacement fo' /* code ta print list of names */?
(A) System.out.println(allStudents.getName())j
(B) System.out.println(student.getName())j
(C) System.out.println(student.getAddress().getName())j
0) System.out.println(allStudents.getAddress().getName())j
(E) System. out. print In (student [i) . getAddress 0: getName 0) j
309
310 Chapta 6 Arrays n' Array Lists
14 yo. Here be a method dat locates tha Student wit tha highest idNum:
//Precondition: Array stuArr of Student is initialized.
//Postcondition: Student wit highest idNum has been returned.
hood static Student locate(Student[] stuArr)
{
/ * method body * /
}
Which of tha followin could replace /* method body */ so dat tha method
works as intended?
I int max = stuArr[O].getldNum();
for (Student hustla : stuArr)
if (student.getldNum() &gt; max)
{
max = hustla.getldNum();
return hustla;
}
return stuArr[O];
II Student highestSoFar = stuArr[O];
int max = stuArr[O] .getldNum();
for (Student hustla : stuArr)
if(student.getldNum() &gt; max)
{
}
max = hustla.getldNum();
highestSoFar = hustla;
return highestSoFar;
III int maxPos = 0;
for(int i D 1; i &lt; stuArr.length; i++)
if(stuArr[i].getldNum() &gt; stuArr[maxPos].getldNum())
maxPos = i;
return stuArr[maxPos];
(A) I only
(B) IT only
(C) Pt III only
(0) I n' Pt III only
(E) IT n' Pt III only
Multiple-Choice Thangs on Arrays n' Array Lists
Thangs 15-17 refer ta tha Ticket n' Transaction classes below.
hood class Ticket
{
}
private Strin myRow;
private int mySeat;
private double myPrice;
//constructor
hood Ticket(Strin row, int seat, double price)
{
}
myRow = row;
mySeat = seat;
myPrice = price;
//accessors getRow(), getSeat(), n' getPrice()
hood class Transaction
{
}
private int myNumTickets;
private Ticket[] tickList;
//constructor
hood Transaction(int numTicks)
{
}
myNumTickets = numTicks;
tickList = freshly smoked up Ticket[numTicks];
Strin row;
int seat;
double price;
for (int i = 0; i &lt; numTicks; i++)
{
&lt; read user input fo' row, seat, n' price &gt;
/* mo' code */
}
//Returns total amount paid fo' dis transaction.
hood double totalPaid()
{
}
double total = 0.0;
/ * code ta calculate amount * /
return total;
311
312 Chapta 6 Arrays n' Array Lists
15. Which of tha followin erectly replaces 1* mo' code *1 up in tha Transaction
constructor ta initialize tha tickList array?
(1\) tickList[i) = freshly smoked up Ticket (getRow(), getSeat(), getPrice(»i
(B) tickList[i) = freshly smoked up Ticket(row, seat,price)i
(C) tickList[i) = freshly smoked up tickList(getRow(), getSeat(), getPrice(»i
0) tickList[i) = freshly smoked up tickList(row, seat, price)i
(E) tickList[i) = freshly smoked up tickList(numTicks)i
16. Which represents erect 1* code ta calculate amount *1 up in tha totalPaid method?
(1\) fo' (Ticket t : tickList)
total += t.myPricei
(B) fo' (Ticket t : tickList)
total += tickList.getPrice()i
(C) fo' (Ticket t : tickList)
total += t.getPrice()i
0) Transaction Ti
for (Ticket t : T)
total += t.getPrice()i
(E) Transaction Ti
for (Ticket t : T)
total += t.myPricei
17. Right back up in yo muthafuckin ass. Suppose it is necessary ta keep a list of all ticket transactions. 1\ suitable declaration
would be
(1\) Transaction[) listOfSalez = freshly smoked up Transaction[NUMSALES)i
(B) Transaction[) listOfSalez = freshly smoked up Ticket[NUMSALES)i
(C) Ticket[) listOfSalez = freshly smoked up Transaction[NUMSALES)i
0) Ticket[) listOfSalez = freshly smoked up Ticket[NUMSALES)i
(E) Transaction[) Ticket = freshly smoked up listOfSales[NUMSALES);
Multiple-Choice Thangs on Arrays n' Array Lists
18. Refer ta method match below:
IIPrecondition: v[O] .. v[N-l] n' w[O] .. w[M-l] initialized with
II integers. v[O] &lt; v[1] &lt; .. &lt; v[N-1] and
II w[O] &lt; w[1] &lt; .. &lt; w[M-1].
IIPostcondition: Returns legit if there be a integer k dat occurs
II up in both arrays, otherwise returns false.
hood static boolean match(int[] v, int[] w, int N, int M)
{
}
int vlndex = 0, wlndex = OJ
while (vlndex &lt; N &amp;&amp; wlndex &lt; M)
{
}
if (v[vlndex] == w[wlndex])
return true;
else if (v[vlndex] &lt; w[wlndex])
vlndex++;
else
wlndex++;
return false;
Assumin dat tha method has not been exited, which assertion is legit all up in tha end
of every last muthafuckin execution of tha while loop?
(A) v [0] .. v [vlndex-1] n' w [0] .. w [wlndex-1] contain no common value,
vlndex ~ Nand wlndex ~ M.
(B) v [0] .. v [vlndex] n' w [0] .. w [wlndex] contain no common value,
vlndex ~ Nand wlndex ~ M.
(C) v [0] .. v [vlndex-1] n' w [0] .. w [wlndex-1] contain no common value,
vlndex ~ N-1 n' wlndex ~ M-1.
(0) v [0] .. v [vlndex] n' w [0] .. w [wlndex] contain no common value,
vlndex ~ N-1 n' wlndex ~ M-1.
(E) v [0] .. v [N-1] n' w [0] .. w [M-1] contain no common value,
vlndex ~ Nand wlndex ~ M.
313
314
19. Consider dis class:
hood class Book
{
private Strin myTitle;
private Strin myAuthor;
Chapta 6 Arrays n' Array Lists
private boolean myCheckoutStatus;
}
//constructor
hood Book(Strin title, Strin author)
{
}
myTitle = title;
myLyricist = author;
myCheckoutStatus = false;
//Change checkout status.
hood void chizzleStatus()
{ myCheckoutStatus = !myCheckoutStatus; }
//other methodz not shown ...
A client program has dis declaration:
Book[] bookList = freshly smoked up Book[SOME_NUMBER];
Suppose bookList is initialized so dat each Book up in tha list has a title, lyricist, and
checkout status. Da followin piece of code is written, whose intent is ta chizzle
the checkout statuz of each book up in bookList.
for (Book b : bookList)
b.changeStatus();
Which is legit bout dis code?
(A) Da bookList array will remain unchanged afta execution.
(B) Each book up in tha bookList array gonna git its checkout status chizzled, as
intended.
(C) A NullPointerException may occur.
(D) A run-time error will occur cuz it aint possible ta modify objects
usin tha for-each loop.
(E) A logic error will occur cuz it aint possible ta modify objects up in an
array without accessin tha indexez of tha objects.
Multiple-Choice Thangs on Arrays n' Array Lists
Consider dis class fo' Thangs 20 n' 21:
hood class BingoCard
{
}
private int[] myCardj
1* Default constructor: Creates BingoCard with
* 20 random digits up in tha range 1 - 90; *1
hood BingoCard()
{ 1* implementation not shown *1 }
1* Display BingoCard. Y'all KNOW dat shit, muthafucka! *1
hood void display()
{ 1* implementation not shown *1 }
A program dat simulates a funky-ass bingo game declares a array of BingoCard. Y'all KNOW dat shit, muthafucka! Da array
has NUMPLAYERS elements, where each element represents tha card of a gangbangin' finger-lickin' different playa.
Here be a cold-ass lil code segment dat creates all tha bingo cardz up in tha game:
1* declare array of BingoCard *1
1* construct each BingoCard *1
20. Which of tha followin be a cold-ass lil erect replacement for
I * declare array of BingoCard * I?
(A) int [] BingoCard = freshly smoked up BingoCard[NUMPLAYERS] j
(B) BingoCard[] playas = freshly smoked up int[NUMPLAYERS]j
(C) BingoCard[] playas = freshly smoked up BingoCard[20]j
0) BingoCard[] playas = freshly smoked up BingoCard[NUMPLAYERS]j
(E) int[] playas = freshly smoked up BingoCard[NUMPLAYERS]j
21 fo' realz. Assumin dat playas has been declared as a array of BingoCard, which of the
followin be a cold-ass lil erect replacement for
I * construct each BingoCard *1
I fo' (BingoCard card : playas)
card = freshly smoked up BingoCard()j
II fo' (BingoCard card : playas)
players[card] = freshly smoked up BingoCard()j
III fo' (int i = OJ i &lt; playas.length; i++)
players[i] = freshly smoked up BingoCard()j
(A) I only
(B) Pt II only
(C) Pt III only
0) I n' Pt III only
(E) I, Pt II, n' Pt III
315
316 Chapta 6 Arrays n' Array Lists
22. Which declaration will cause a error?
I ArrayList<string> stringList = freshly smoked up ArrayList<string>();
II ArrayList<int> intList = freshly smoked up ArrayList<int>();
III ArrayList<comparable> compList = freshly smoked up ArrayList<comparable>();
(A) I only
(B) Pt II only
(C) Pt III only
(D) I n' Pt III only
(E) Pt II n' Pt III only
23. Consider these declarations:
ArrayList<string> stringList = freshly smoked up ArrayList<string>();
Strin ch = Pt II ";
Integer intOb = freshly smoked up Integer(5);
Which statement will cause a error?
(A) strList.add(ch);
(B) strList.add(new String("handy andy"));
(C) strList.add(intOb.toString());
(D) strList.add(ch + 8);
(E) strList.add(intOb + 8);
24. Let list be a ArrayList<integer> containin these elements:
25760 1
Which of tha followin statements would not cause a error ta occur, biatch? Assume
that each statement applies ta tha given list, independent of tha other statements.
(A) Object ob = list. git (6) ;
(B) Integer intOb = list.add(3.4);
(C) list.add(6, 9);
(D) Object x = list.remove(6);
(E) Object y = list.set(6, 8);
Multiple-Choice Thangs on Arrays n' Array Lists
25. Refer ta method bang below:
1* Precondition: ArrayList list gotz nuff Comparable joints
* sorted up in decreasin order.
* Postcondition: Element banged up in its erect position
* up in list. *1
hood void insert(ArrayList<comparable> list,
Comparable element)
{
}
int index = 0;
while (element.compareTo(list.get(index» &lt; 0)
index++;
list.add(index, element);
Assumin dat tha type of element is compatible wit tha objects up in tha list,
which be a legit statement bout tha bang method?
(A) It works as intended fo' all jointz of element.
(B) It fails fo' all jointz of element.
(C) It fails if element is pimped outa than tha straight-up original gangsta item up in list n' works up in all other
cases.
(0) It fails if element is smalla than tha last item up in list n' works up in all other
cases.
(E) It fails if element is either pimped outa than tha straight-up original gangsta item or smalla than tha last
item up in list n' works up in all other cases.
26. Consider tha followin code segment, applied ta list, a ArrayList of Integer
values.
int len = list.size();
for (int i = 0; i &lt; len; i++)
{
list.add(i + 1, freshly smoked up Integer(i»;
Object x = list.set(i, freshly smoked up Integer(i + 2»;
}
Iflist is initially 6 1 8, what tha fuck will it be followin execution of tha code segment?
(A) 2 3 4 2 1 8
(B) 2 3 4 6 2 2 0 1 8
(C) 2 3 4 0 1 2
(0) 2 3 4 6 1 8
(E) 2 3 3 2
317
318 Chapta 6 Arrays n' Array Lists
Thangs 27 n' 28 is based on tha Coin n' Purse classes given below:
1* A simple coin class *1
hood class Coin
{
}
private double myValuej
private Strin myNamej
Ilconstructor
hood Coin(double value, Strin name)
{
}
myValue = value;
myName = name j
IIReturn tha value n' name of dis coin.
hood double getValue()
{ return myValuej }
hood Strin getName()
{ return myNamej }
IIDefine equals method fo' Coin objects.
hood boolean equals(Object obj)
{ 1* implementation not shown *1 }
IIOther methodz not shown.
/* A purse holdz a cold-ass lil collection of coins */
hood class Purse
{
}
private ArrayList<coin> coinsj
/Iconstructor
I/Creates a empty purse.
hood PurseO
{ coins = freshly smoked up ArrayList<coin>()j }
IIAddz aCoin ta tha purse.
hood void add(Coin aCoin)
{ coins.add(aCoin)j }
IIReturns total value of coins up in purse.
hood double getTotal()
{ 1* implementation not shown */}
Multiple-Choice Thangs on Arrays n' Array Lists
27 yo. Here is tha getTotal method from tha Purse class:
//Returns total value of coins up in purse.
hood double getTotal()
{
}
double total = 0;
/* mo' code */
return total;
Which of tha followin be a cold-ass lil erect replacement fo' /* mo' code */?
(A) fo' (Coin c : coins)
{
}
c = coins.get(i);
total += c.getValue();
(B) fo' (Coin c : coins)
{
}
Coin value = c.getValue();
total += value;
(C) fo' (Coin c : coins)
{
}
Coin c = coins.get(i);
total += c.getValue();
0) fo' (Coin c : coins)
{
total += coins.getValue();
}
(E) fo' (Coin c : coins)
{
total += c.getValue();
}
319
320
ABONLY
Chapta 6 Arrays n' Array Lists
28 fo' realz. A boolean method find be added ta tha Purse class:
1* Returns legit if tha purse has a cold-ass lil coin dat matches aCoin,
* false otherwise. *1
hood boolean find(Coin aCoin)
{
}
for (Coin c : coins)
{
1* code ta find match *1
}
return false;
Which be a cold-ass lil erect replacement fo' 1* code ta find match */?
I if (c.equals(aCoin))
return true;
II if «c.getName()).equals(aCoin.getName()))
return true;
m if «c.getValue()).equals(aCoin.getValue()))
return true;
(A) I only
(B) Pt II only
(C) monly
(D) I n' Pt II only
(E) I, Pt II, n' m
29. Which of tha followin initializes a 8 x 10 matrix wit integer joints dat are
slick squares, biatch? (0 be a slick square.)
I int[] [] mat = freshly smoked up int[8] [10];
II int [] [] mat = freshly smoked up int [8] [10] ;
for (int r = 0; r &lt; mat.length; r++)
for (int c = 0; c &lt; mat[r].length; c++)
mat[r] [c] = r * r;
mint [] [] mat = freshly smoked up int [8] [10] ;
for (int c = 0; c &lt; mat[r] . length; c++)
for (int r = 0; r &lt; mat.length; r++)
mat[r] [c] = c * c;
(A) I only
(B) Pt II only
(C) monly
(D) I n' Pt II only
(E) I, Pt II, n' m
Multiple-Choice Thangs on Arrays n' Array Lists 321
30. Consider tha followin method dat will alta tha matrix mat: AD (coBtinued) ,
//Precondition: mat is initialized.
hood static void matStuff(int[] [] mat, int row)
{
int numCols = mat [0] . length;
for (int col = 0; col &lt; numCols; col++)
mat [row] [col] = row;
}
Suppose mat is originally
1 4 9 0
2 7 8 6
5 1 4 3
Afta tha method call matStuff (mat, 2), matrix mat will be
(A) 1 4 9 0
2 7 8 6
2 2 2 2
(B) 1 4 9 0
2 2 2 2
5 1 4 3
(C) 2 2 2 2
2 2 2 2
2 2 2 2
(0) 1 4 2 0
2 7 2 6
5 1 2 3
(E) 1 2 9 0
2 2 8 6
5 2 4 3
322 Chapta 6 Arrays n' Array Lists
31 fo' realz. Assume dat a square matrix mat is defined by
int[] [] mat = freshly smoked up int[SIZE] [SIZE];
//SIZE be a integer constant &gt;= 2
What do tha followin code segment do?
for (int i = 0; i &lt; SIZE - 1; i++)
for (int j = 0; j &lt; SIZE - i - 1; j++)
swap (mat , i, j, SIZE - j - 1, SIZE - i - 1);
Yo ass may assume tha existence of dis swap method:
//Interchange mat [a] [b] n' mat[c] [d].
hood void swap(int[] [] mat, int a, int b, int c, int d)
(A) Reflects mat all up in its major diagonal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. For example,
2 6 2 4
--+
4 3 6 3
(B) Reflects mat all up in its minor diagonal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. For example,
2 6 3 6
--+
4 3 4 2
(C) Reflects mat all up in a horizontal line of symmetry. For example,
2 6 4 3
--+
4 3 2 6
(D) Reflects mat all up in a vertical line of symmetry. For example,
2 6 6 2
--+
4 3 3 4
(E) Leaves mat unchanged.
Multiple-Choice Thangs on Arrays n' Array Lists
32 fo' realz. A square matrix is declared as
int[] [] mat = freshly smoked up int[SIZE] [SIZE];
where SIZE be a appropriate integer constant. Consider tha followin method:
hood void mystery(int[] [] mat, int value, int top, int left,
int bottom, int right)
{
}
for (int i = left; i &lt;= right; i++)
{
}
mat [top] [i] = value;
mat [bottom] [i] = value;
for (int i = top + 1; i &lt;= bottom - 1; i++)
{
}
mat[i] [left] = value;
mat[i] [right] = value;
Assumin dat there be no out-of-range errors, which dopest raps bout what
method mystery do?
(A) Places value up in cornerz of tha rectangle wit corners (top, left) and
(bottom, right).
(B) Places value up in tha diagonalz of tha square wit corners (top, left) and
(bottom, right).
(C) Places value up in each element of tha rectangle wit corners (top, left) and
(bottom, right).
(0) Places value up in each element of tha border ofthe rectangle wit corners
(top, left) n' (bottom, right).
(E) Places value up in tha topmost n' bottommost rowz of tha rectangle with
corners (top, left) n' (bottom, right).
323
324 Chapta 6 Arrays n' Array Lists
33. This question refers ta tha followin method:
hood static boolean isThere(String[] [] mat, int row, int col,
Strin symbol)
{
}
boolean yes;
int i, count = 0; -
for (i = 0; i &lt; SIZE; i++)
if (mat[i] [col] .equals(symbol))
count++;
yes = (count == SIZE);
count = 0;
for (i = 0; i &lt; SIZE; i++)
if (mat [row] [i] .equals(symbol))
count++; ~.. ...
return (yes I I count == SIZE);
Now consider dis code segment:
hood final int SIZE = 8;
String[] [] mat = freshly smoked up String[SIZE] [SIZE];
Which of tha followin conditions on a matrix mat of tha type declared up in the
code segment will by itself guarantee that
isThere(mat, 2, 2, "$")
will have tha value legit when evaluated?
I Da element up in row 2 n' column 2 is "$"
II All elements up in both diagonals is "$"
III All elements up in column 2 is "$"
(A) I only
(B) Pt III only
(C) I n' Pt II only
(D) I n' Pt III only
(E) Pt II n' Pt III only
Multiple-Choice Thangs on Arrays n' Array Lists
Thangs 34-37 use tha nested for-each loop fo' two-dimensionizzle arrays. This will
not be tested on tha AP exam.
34. Da method chizzleNegs below should replace every last muthafuckin occurrence of a negative
integer up in its matrix parameta wit o.
//Precondition: mat is initialized wit integers.
//Postcondition: All wack joints up in mat replaced wit O.
hood static void chizzleNegs(int[] [] mat)
{
/* code */
}
Which is erect replacement fo' /* code */?
I fo' (int r = 0; r &lt; mat.length; r++)
for (int c = 0; c &lt; mat[r] . length; c++)
if (mat [r] [c] &lt; 0)
mat[r] [c] = 0;
II fo' (int c = 0; c &lt; mat [0] . length; c++)
for (int r = 0; r &lt; mat.length; r++)
if (mat[r] [c] &lt; 0)
mat [r] [c] = 0;
ITI fo' (int[] row: mat)
for (int element : row)
if (element &lt; 0)
element = 0;
(A) I only
(B) IT only
(C) monly
(D) I n' IT only
(E) I, IT, n' m
325
AD (continued)
326 Chapta 6 Arrays n' Array Lists
35. This question is b~ed on tha Point class below:
hood class Point
{
}
private int Xj
private int Yj
//constructor
hood Point (int x, int y)
{
}
this.x = Xj
this.y = Yj
//accessors
hood int getx()
{ return Xj }
hood int gety()
{ return Yj }
//Set x n' y ta new_x n' new_yo
hood void setPoint(int new_x, int new_y)
{
}
x = new_xj
y = new_Yj
//Return Point up in Strin form.
hood Strin toString()
{
return "(" + x +
}
II , n + y + Pt II)II j
//other methodz not shown
Da method chizzleNegs below takes a matrix of Point objects as parameta and
replaces every last muthafuckin Point dat has as least one wack coordinizzle wit tha Point
(0,0). .
/* Precondition: pOintMat is initialized wit Point objects.
* Postcondition: Every point wit at least one negative
* coordinizzle has been chizzled ta have both
* coordinates equal ta zero. */
hood static void chizzleNegs (Point [] [] pointMat)
{
}
Multiple-Choice Thangs on Arrays n' Array Lists
Which be a cold-ass lil erect replacement fo' 1* code */?
I fo' (int r = 0; r &lt; pointMat.length; r++)
for (int c = 0; c &lt; pointMat[r].length; c++)
if (pointMat[r] [c] .getx() &lt; 0
I I pointMat[r] [c] .gety() &lt; 0)
pointMat[r] [c] .setPoint(O, 0);
II fo' (int c = 0; c &lt; pOintMat[O] . length; c++)
for (int r = 0; r &lt; pointMat.length; r++)
if (pointMat[r] [c] .getx() &lt; 0
I I pointMat[r] [c] .gety() &lt; 0)
pointMat[r] [c].setPoint(O, 0);
III fo' (Point[] row: pointMat)
for (Point p : row)
(A) I only
(B) Pt II only
(C) Pt III only
if (p.getx() &lt; 0 I I p.gety() &lt; 0)
p.setPoint(O, 0);
(0) I n' Pt II only
(E) I, ll, n' Pt III
327
AD (continJled)
328 Chapta 6 Arrays n' Array Lists
36 fo' realz. A simple Tic-Tac-Toe board be a 3 x 3 array filled wit either X's, O's, or blanks.
Here be a cold-ass lil class fo' a game of Tic-Tac-Toe:
hood class TicTacToe
{
}
private String[] [] board;
private static final int ROWS = 3;
private static final int COLS = 3;
Ilconstructor. Shiiit, dis aint no joke. constructs empty board
hood TicTacToe()
{
}
board = freshly smoked up String[ROWS] [COLS];
for (int r = 0; r &lt; ROWS; r++)
for (int c = 0; c &lt; COLS; c++)
board[r] [c] "";
1* Precondition: square on Tic-Tac-Toe board is empty
* Postcondition: symbol placed up in dat square *1
hood void makeMove(int r, int c, Strin symbol)
{
board[r][c] = symbol;
}
1* Creates a strang representation of tha board, e.g.
* 10
* Ixx 1
* 1 01
* Postcondition: returns tha strang representation *1
hood Strin toString()
{
}
Strin s = "";
<more code="">
return s;
Ilempty string
Which segment represents a cold-ass lil erect replacement fo' &lt; mo' code &gt; fo' tha toString
method?
(A) fo' (int r = 0; r &lt; ROWS; r++)
{
for (int c = 0; c &lt; COLS; c++)
{
s = s + "111;
S = S + board[r] [c];
s = s + "I\n";
}
}
Multiple-Choice Thangs on Arrays n' Array Lists 329
(B) fo' (int r = 0; r &lt; ROWS; r++)
{
s = s + "I";
for (int c = 0; c &lt; COLS; c++)
{
s = s + board[r] [c];
s = s + "I\n";
}
}
(C) fo' (int r = 0; r &lt; ROWS; r++)
{
s = s + "I";
for (int c = 0; c &lt; COLS; c++)
s = s + board[r] [c];
}
s = s + "I\n";
(D) fo' (int r = 0; r &lt; ROWS; r++)
s = s + "I";
for (int c = 0; c &lt; COLS; c++)
{
s = s + board[r] [c];
s = s + "I\n";
}
(E) fo' (int r = 0; r &lt; ROWS; r++)
{
s = s + "I";
for (int c = 0; c &lt; COLS; c++)
s = S + board[r] [c];
s=s+"I\n";
}
330 Chapta 6 Arrays n' Array Lists
37 fo' realz. A two-dimensionizzle array of double, rainfall, is ghon be used ta represent tha everyday
rainfall fo' a given year. Shiiit, dis aint no joke. In dis scheme, rainfall [month] [day] represents the
amount of drizzle on tha given dizzle n' month. For example,
rainfall [1] [15] is tha amount of drizzle on Jan. I aint talkin' bout chicken n' gravy biatch. 15
rainfall [12] [25] is tha amount of drizzle on Dec. 25
Da array can be declared as bigs up:
double[] [] rainfall = freshly smoked up double [13] [32];
This creates 13 rows indexed from 0 ta 12 n' 32 columns indexed from 0 ta 31,
all initialized ta O. o. Row 0 n' column 0 is ghon be ignored. Y'all KNOW dat shit, muthafucka! Column 31 up in row 4
will be ignored, since April 31 aint a valid day. It make me wanna hollar playa! In muthafuckin years dat is not leap years,
columns 29, 30, n' 31 up in row 2 is ghon be ignored since Feb. 29, 30, n' 31 is not
valid days.
Consider tha method averageRainfall below:
/* Precondition: rainfall is initialized wit joints
* representin amountz of drizzle on all valid
* days. Invalid minutes is initialized ta 0.0.
* Feb 29 aint a valid day.
* Postcondition:. Returns average rainfall fo' tha year. Shiiit, dis aint no joke. */
hood double averageRainfall(double rainfall[] [])
{
}
double total = 0.0;
/* mo' code */
Which of tha followin be a cold-ass lil erect replacement fo' /* mo' code */ so dat the
postcondizzle fo' tha method is satisfied?
I fo' (int month = 1; month &lt; rainfall. length; month++)
for (int dizzle = 1; dizzle &lt; rainfall [month] . length; day++)
total += rainfall [month] [day];
return total / (13 * 32);
II fo' (int month = 1; month &lt; rainfall.length; month++)
for (int dizzle = 1; dizzle &lt; rainfall [month] . length; day++)
total += rainfall [month] [day] ;
return total / 365;
ITI fo' (double[] month: rainfall)
for (double rainAmt : month)
total += rainAmt;
return total / 365;
(A) None
(B) I only
(C) IT only
(D) ill only
(E) IT n' ill only
Multiple-Choice Thangs on Arrays n' Array Lists
38. Da followin code segment reverses tha elementz of arr [first] ... arr [last].
int k = first, j = last;
while (k &lt; j)
{
}
swap(arr, k, j);
k++;
j--;
//interchanges arr[k] n' arr[j]
Which of tha followin diagrams represents tha loop invariant fo' tha while loop?
(Each rectangle represents a segment of array arr. Shiiit, dis aint no joke. Da labels above tha rectangles
represent tha indexez of array elements all up in tha beginnin n' end of each segment.)
first ~~:t"_1 _____________ ~=.1_j
; original gangsta elements
last
(A)
swapped swapped
first k k+1 j-1 j last
(B)
original gangsta elements i swapped original gangsta elements
). --
first k-1 k j j+1 last
(C)
swapped original gangsta elements swapped
first k-1 k j j+1 last
(D) I original gangsta elements swapped original gangsta elements
first k-1 k j-1 j
(E)
swapped original gangsta elements swapped
39. Da followin algorithm sets min equal ta tha smallest value in
arr [0] ... arr [n-1]:
min = arr[O];
i = 1;
while (i &lt; n)
{
}
if (arr[i] &lt; min)
min = arr[i];
i++;
Da loop invariant fo' tha while loop is
(A) min is smallest value up in arr [0] ... arr[i] , 1
(B) min is smallest value up in arr [0] ... arr[i-1],
(C) min is smallest value up in arr [0] ... arr [i] , 1
(D) min is smallest value up in arr [0] ... arr[i-1],
(E) min is smallest value up in arr [0] ... arr[i-1],
:::: i :::: n
1 :::: i :::: n-1
:::: i :::: n-1
1 &lt; i ::::n
1 :::: i ::::n
last
331
AB (continued)
332 "Chapta 6 Arrays n' Array Lists
ANSWER KEY
I.E 14. E 27. E
2. C 15. B 28. D
3. E 16. C 29. D
4. B 17 fo' realz. A 30 fo' realz. A
5 fo' realz. A 18 fo' realz. A 31. B
6. B 19. B 32. D
7. C 20. D 33. B
8. C 21. C 34. D
9. D 22. B 35. E
10 fo' realz. A 23. E 36. E
11. D 24. C 37. E
12. B 25. D 38. C
13. C 26 fo' realz. A 39. E
ANSWERS EXPLAINED
1. (E) Segment I be a initializer list which is equivalent to
int[] arr = freshly smoked up int[4];
arr[O] - 0;
arr[l] = 0;
arr[2] = 0;
arr[3] = 0;
Segment Pt II creates four slots fo' integers, which by default is initialized ta o. The
for loop up in segment ill is therefore unnecessary. Well shiiiit, it is not, however, incorrect.
2. (C) If arr gotz nuff no wack integers, tha value of i will eventually exceed N-i,
and arr [i] will cause a ArraylndexOutOfBoundsException ta be thrown.
3. (E) Da intent is ta sum elements arr [0], arr [i], ... , arr [arr .length-i].
Notice, however, dat when i has tha value arr .length-i, it is incremented to
arr . length up in tha loop, so tha statement sum += arr [i] uses arr [arr . length] ,
which is outta range.
4. (B) There is two problems wit tha segment as given:
1. arr [i] aint tested.
2. When i has a value of n-i, incrementin i will lead ta a out-of-range
errorfor tha if(arr [i] &lt; min) test.
Modification Pt II erects both these errors. Da chizzle suggested up in ill erects
neither of these errors. Da chizzle up in I erects (1) but not (2).
5. (A) Da code segment has tha effect of removin all occurrencez of 0 from array
arr1. Then tha nonzero elements ~re transferred ta array arr2.
Answers Explained
6. (B) Da algorithm is linear. Shiiit, dis aint no joke. Well shiiiit, it passes once all up in tha array, bustin a single
assignment if a nonzero element is found.
7. (C) If arr [i] &lt; someValue fo' all i from 2 ta k, SMALL is ghon be printed on each
iteration of tha fo' loop. Right back up in yo muthafuckin ass. Since there be k - 1 iterations, tha maximum number
of times dat SMALL can be printed is k - 1.
8. (C) Array arr is chizzled by doSomethang yo. Here is tha memory slots:
Just before doSomethang is called:
Just before exitin doSomething:
arr D---+lo1112131
[3::
Just afta doSomethang is called,
but before tha fo' loop is executed:
Just afta exitin doSomething:
arr D---+ 1 0 11 I 2 I 3.1
9. (0) Arrays iz of fixed length n' do not shrink or grow if tha size of tha data
set varies fo' realz. An ArrayList automatically resizes tha list. Chizzle A is false: Da []
notation is compact n' easy as fuck  ta use. Chizzle B aint a valid reason cuz an
array arr also serves up instant access ta its length wit tha quantitizzle arr . length.
Choice C is invalid cuz a array can also contain objects fo' realz. Also, generalitizzle is
beside tha point up in tha given program: Da list must hold Strin objects, n' you can put dat on yo' toast. Chizzle
E is false: Whether a Strin object be arr [i) or list. git (i), tha Strin methods
are equally easy as fuck  ta invoke.
10. (A) In order fo' numerical elements ta be added ta a ArrayList, each element
must be wrapped up in a wrapper class before insertion tha fuck into tha list. Then, ta retrieve
a numerical value from tha ArrayList, tha element must be unboxed using
the intValue or doubleValue methods. Even though these operations can be
taken care of wit auto-boxin n' -un boxing, there be efficiency costs, n' you can put dat on yo' toast. In an
array, you simply use tha [J notation fo' assignment (as up in arr [i] = num) or retrieval
(value = arr [i]). Note dat chizzlez Band C is false statements: Both
insertion n' deletion fo' a array involve freestylin code ta shift elements fo' realz. An
ArrayList automatically takes care of dis all up in its add n' remove methods.
Choice D be a skanky reason fo' choosin a array. While tha git n' set methods
of ArrayList might be slightly mo' awkward than rockin tha [J notation, both
mechanizzlez work pretty doggystyle. Chizzle E is false: Efficiency of access is roughly
the same.
11. (0) For each Address object a up in list, access tha name of tha object with
a.getNameO.
333
ABONLY
334 Chapta 6 Arrays n' Array Lists
12. (B) Since tha Address class aint gots a toStrin method, each data field must
explicitly be printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Right back up in yo muthafuckin ass. Segment Pt III would work if there was a toStrin method
for tha class (but there aint, so it don't!). Right back up in yo muthafuckin ass. Segment I fails cuz of incorrect
use of tha for-each loop: Da array index should not be accessed.
13. (C) Each Student name must be accessed all up in tha Address class accessor
getName (). Da expression hustla. getAddress () accesses tha entire address of
that hustla. Da myName field is then accessed rockin tha git Name 0 accessor of
the Address class.
14. (E) Both erect solutions is careful not ta lose tha hustla whoz ass has the
highest idNum so far. Shiiit, dis aint no joke. Right back up in yo muthafuckin ass. Segment Pt II do it by storin a reference ta tha hustla,
highestSoFar. Shiiit, dis aint no joke. Right back up in yo muthafuckin ass. Segment Pt III do it by storin tha array index of dat hustla.
Code segment I is incorrect cuz it returns tha straight-up original gangsta hustla whose idNum is
greata than max, not necessarily tha hustla wit tha highest idNum. up in tha list.
15. (B) For each i, tickList [i] be a freshly smoked up Ticket object dat must be constructed
usin tha Ticket constructor. Shiiit, dis aint no joke. Therefore eliminizzle chizzlez C, D, n' E. Chizzle
A is wack cuz getRow 0, getSeat 0, n' getPri ce 0 is accessors fo' joints
that already exist fo' some Ticket object. Note also tha absence of tha dot
member construct.
16. (C) To access tha price fo' each Ticket up in tha tickList array, tha getPrice 0 accessor
in tha Ticket class must be used, since myPrice is private ta dat class. This
eliminates chizzlez A n' E. Chizzle B uses tha array name incorrectly. Chizzles
D n' E incorrectly declare a Transaction object. (Da method applies ta an
existin Transaction object.)
17. (A) An array of type Transaction is required. Y'all KNOW dat shit, muthafucka! This eliminates chizzlez C n' D.
Additionally, chizzlez Band D incorrectly use type Ticket on tha right-hand side.
Choice E puts tha identifier listOfSalez up in tha wack place.
18. (A) Notice dat either vlndex or wlndex is incremented all up in tha end of tha loop.
This means that, when tha loop is exited, tha current jointz of v [vlndex] and
w[wlndex] aint been compared. Y'all KNOW dat shit, muthafucka! Therefore, you can only cook up a assertion
for joints v [0] .. v [vlndex-l] n' w [0] .. w [wlndex-l] fo' realz. Also, notice dat if there
is no common value up in tha arrays, tha exitin condizzle fo' tha while loop will
be dat tha end of one of tha arrays has been reached, namely vlndex equals N or
wlndex equals M.
19. (B) Objects up in a array can be chizzled up in a gangbangin' for-each loop by rockin mutator methods
of tha objects' class. Da chizzleStatus method, a mutator up in tha Book class,
will work as intended up in tha given code. Chizzle C would be legit if it was not
given dat each Book up in bookList was initialized. Y'all KNOW dat shit, muthafucka! If any given b had a value of
null, then a NullPointerException would be thrown.
20. (D) Da declaration must start wit tha type of value up in tha array, namely
BingoCard. Y'all KNOW dat shit, muthafucka! This eliminates chizzlez A n' E. Eliminizzle chizzle B; Da type on
the right of tha assignment should be BingoCard. Y'all KNOW dat shit, muthafucka! Chizzle C is wack cuz the
number of slots up in tha array should be NUMPLAYERS, not 20.
21. (C) Segment Pt III is tha only segment dat works, since tha for-each loop cannot
be used ta replace elements up in a array fo' realz. Afta tha declaration
BingoCard[] playas = freshly smoked up BingoCard[NUMPLAYERS] ;
each element up in tha playas array is null. Da intent up in tha given code is to
Answers Explained
replace each null reference wit a newly constructed BingoCard.
22. (B) Da type parameta up in a generic ArrayList must be a cold-ass lil class type, not a primitive.
23. (E) All elements added ta strList must be of type String. Each chizzle satisfies
this except chizzle E. Note dat up in chizzle D, since ch be a String, tha expression ch
+ 8 becomes a Strin (just one of tha operandz need ta be a Strin ta convert
the whole expression ta a String). In chizzle E, neither intOb nor 8 be a String.
24. (C) Da effect of chizzle C is "to adjust tha size of tha list ta 7 n' ta add the
Integer 9 ta tha last slot (i.e., tha slot wit index 6). Chizzlez A, D, n' E will
all cause a IndexOutOfBoundsException cuz there is no slot wit index 6:
the last slot has index 5. Chizzle B will cause a cold-ass lil compile-time error, since it is
attemptin ta add a element of type Double ta a list of type Integer.
25. (0) H element is smalla than tha last item up in tha list, it is ghon be compared with
every item up in tha list. Eventually index is ghon be incremented ta a value dat is out
of bounds. To stay tha fuck away from dis error, tha test up in tha while loop should be
while(index &lt; list.size() t&amp;
element.compareTo(list.get(index)) &lt; 0)
Notice dat if element is pimped outa than or equal ta at least one item up in list, tha test
as given up in tha problem will eventually be false, preventin a out-of-range error.
26. (A) Recall dat add (index , obj) shifts all elements, startin at index, one unit
to tha right, then bangs obj at posizzle index. Da set (index, obj) method
replaces tha element up in posizzle index wit obj. Right back up in yo muthafuckin ass. So here is tha state of list after
each chizzle:
i = 0
i = 1
i = 2
6 0 1 8
2 0 1 8
20118
2 3 1 1 8
2 3 1 2 1 8
2 3 4 2 1 8
27. (E) Da value of each Coin c up in coins must be accessed wit c.getValueO. This
eliminates chizzle D. Eliminizzle chizzlez A n' B: Da loop accesses each Coin
in tha coins ArrayList, which means dat there should not be any statements
attemptin ta git tha next Coin. I aint talkin' bout chicken n' gravy biatch. Chizzle B would be erect if tha straight-up original gangsta statement
in tha loop body were
double value = c.getValue();
28. (0) Da equals method is defined fo' objects only. Right back up in yo muthafuckin ass. Since getValue returns a
double, tha quantitizzles c.getValueO n' aCoin.getValueO must be compared
either rockin ==, or as busted lyrics bout up in tha box on p. 122 (better).
29. (0) Segment n is tha straightforward solution. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Segment I is erect cuz it
initializes all slotz of tha matrix ta 0, a slick square. (By default, all arrays of
int or double is initialized ta 0.) Segment TIl fails cuz r is undefined up in the
condizzle c &lt; mat [r] . length. In order ta do a cold-ass lil column-by-column traversal, you
need ta git tha number of columns up in each row. Da outa fo' loop could be
for (int c = 0; c &lt; mat [0] . length; c++)
335
ABONLY
336
AD (continued)
Chapta 6 Arrays n' Array Lists
Now segment ill works. Note dat since tha array is rectangular, you can use any
index k up in tha conditionizzle c &lt; mat [k] . length, provided dat k satisfies 0 ~ k &lt;
mat. length.
30. (A) matStuff processes tha row selected by tha row parameter, 2 up in tha method
call. Da row value, 2, overwrites each element up in row 2. Don't make tha mistake
of selectin chizzle B-the row labels is 0, 1,2.
31. (B) Hand execute dis fo' a 2 x 2 matrix. i goes from ° ta 0, j goes from ° ta 0, so
the only interchange is swap mat [0] [0] wit mat [1] [1], which suggests chizzle
B. Peep wit a 3 x 3 matrix:
i 0 j 0 swap mat [0] [0] wit mat [2] [2]
j 1 swap mat [0] [1] wit mat [1] [2]
i 1 j 0 swap mat [1] [0] wit mat [2] [1]
Da elements ta be interchanged is shown paired up in tha followin figure. The
result is ghon be a reflection all up in tha minor diagonal.
32. (D) Da first fo' loop places value up in tha top n' bottom rowz of tha defined
rectangle. Da second fo' loop fills up in tha remainin border elements on the
sides. Note dat tha top + 1 n' bottom - 1 initializer n' terminatin conditions
avoid fillin up in tha corner elements twice.
33. (B) For tha method call isThere(mat, 2, 2, "$"), tha code counts how tha fuck many
times "$" appears up in row 2 n' how tha fuck nuff times up in column 2. Da method returns
true only if count == SIZE fo' either tha row or column pass (i.e., the
whole of row 2 or tha whole of column 2 gotz nuff tha symbol "$"). This eliminates
choices I n' Pt II.
34. (D) Segment I be a row.by-row traversal; segment Pt II be a cold-ass lil column-by-column traversal.
Each achieves tha erect postcondition. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Segment ill traverses tha matrix but
does not alta it fo' realz. All dat is chizzled is tha local variable element. Yo ass cannot use
this kind of loop ta replace elements up in a array.
35. (E) This is similar ta tha previous question yo, but up in dis case segment ill be also
correct. This is cuz instead of replacin a matrix element, yo ass is modifying
it rockin a mutator method.
36. (E) There is three thangs dat must be done up in each row:
 Add a openin boundary line:
s = s + "I";
 Add tha symbol up in each square:
for (int c = 0; c &lt; COLS; c++)
s = s + boardEr] [c];
 Add a cold-ass lil closin boundary line n' git all up in tha next line:
Answers Explained
s = s + "I\n";
All of these statements must therefore be enclosed up in tha outa fo' loop, dat is,
for (int r = ... )
37. (E) Since there be 365 valid minutes up in a year, tha divisor up in calculatin tha average
must be 365. Well shiiiit, it may step tha fuck up dat segments Pt II n' ill is incorrect cuz they
include rainfall fo' invalid minutes up in total. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Right back up in yo muthafuckin ass. Since these joints is initialized ta 0.0,
however, includin dem up in tha total won't affect tha final result.
38. (C) Since k n' j is chizzled all up in tha end of tha loop, tha invariant is:
arr [first] ... arr [k-l] done been swapped wit elements arr [last]
down ta arr [j+1J.
Da middle part of tha array has not been processed, n' these elements is still
in they original gangsta positions.
39. (E) i is incremented all up in tha end of tha loop, which means dat on exitin the
loop arr [i) has not yet been examined. Y'all KNOW dat shit, muthafucka! This eliminates chizzlez A n' C. The
loop invariant must be legit on tha final exit from tha loop, at which time i = n.
This eliminates chizzle B. Chizzle D is wack cuz i is initialized ta 1. Thus,
1 &lt; i ...
337
AB (continued)
RecursiDn CHAPTER 7
338
 Recursive methods
recursion n. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See recursion.
-Eric S. Raymond, Da New Hackerz Doggtionary {1991}
Chapta Goals
 Recursive helper methods
 Recursion up in two-dimensional
grids
 Analysiz of recursive algorithms
RECURSIVE METHODS
A recursive method be a method dat calls itself. For example, here be a program that
calls a recursive method stackWords.
hood class WordPlay
{
hood static void stackWords()
{
}
Strin word = IO.readString();
if (word.equals("."»
System.out.println();
else
stackLyrics 0 ;
System.out.println(word);
hood static void main(Strin args[])
{
//read user input
System.out.println("Enta list of lyrics, one per line. Pt II);
System. out. println ("Final word should be a period (.) Pt II) ;
stackLyrics 0 ;
}
}
Here is tha output if you enter
hold
my
hand
General Form of Simple Recursive Methods
Yo ass get
hand
my
hold
Da program readz up in a list of lyrics terminated wit a period, n' prints tha list in
reverse order, startin wit tha period. Y'all KNOW dat shit, muthafucka! How tha fuck do dis happen?
Each time tha recursive call ta stackLyrics 0 is made, execution goes back ta the
start of a freshly smoked up method call. Da computa must remember ta complete all tha pending
calls ta tha method. Y'all KNOW dat shit, muthafucka! Well shiiiit, it do dis by stackin tha statements dat must still be executed
as bigs up: Da last time stackLyrics () is called, tha word "hold" is read n' tested for
bein a period. Y'all KNOW dat shit, muthafucka! No itz not, so stackLyrics 0 is called again. I aint talkin' bout chicken n' gravy biatch. Da statement ta output
"hold" (which has not yet been executed) goes on a stack, n' execution goes ta the
start of tha method. Y'all KNOW dat shit, muthafucka! Da word "my" is read. Y'all KNOW dat shit, muthafucka! Fuck dat shit, it aint a period, so tha command to
output "my" goes on tha stack fo' realz. And so on. I aint talkin' bout chicken n' gravy biatch. Da stack looks suttin' like dis before
the recursive call up in which tha period is read:
System. up .println("hand");
System.out.println("my");
System.out.println("hold");
Imagine dat these statements is stacked like plates. In tha final stackLyrics 0 call,
word has tha value ".". Yes, it aint nuthin but a period, so tha stackLyrics 0 line is skipped, the
period is printed on tha screen, n' tha method call terminates. Da computa now
completes each of tha previous method calls up in turn by "popping" tha statements off
the top of tha stack. Well shiiiit, it prints "hand", then "my", then "hold", n' execution of method
stackLyrics 0 is complete.1
NOTE
1. Each time stackLyrics 0 is called, a freshly smoked up local variable word is pimped.
2. Da last time tha method straight-up terminates, tha program returns ta complete
da most thugged-out recently invoked previous call. Thatz why tha lyrics git reversed in
this example.
GENERAL FORM OF SIMPLE RECURSIVE METHODS
Every recursive method has two distinct parts:
 A base case or termination condizzle dat causes tha method ta end.
 A nonbase case whose actions move tha algorithm toward tha base case n' termination.
1 Actually, tha computa stacks tha pendin statements up in a recursive method call mo' efficiently than
the way busted lyrics about. Y'all KNOW dat shit, muthafucka! But conceptually dis is how tha fuck it is done.
339
340 Chapta 7 Recursion
Here is tha framework fo' a simple recursive method dat has no specific return
type.
hood void recursiveMeth( ... )
{
}
if (base case)
&lt; Perform some action&gt;
else
{
&lt; Perform some other action&gt;
recursiveMeth( .... ); //recursive method call
}
Da base case typically occurs fo' tha simplest case of tha problem, like fuckin when an
integer has a value of 0 or 1. Other examplez of base cases is when some key is found,
or a end-of-file is reached. Y'all KNOW dat shit, muthafucka! A recursive algorithm can have mo' than one base case.
In tha else or nonbase case of tha framework shown, tha code fragment &lt; Perform
some other action&gt; n' tha method call recursi veMeth can sometimes be interchanged
without alterin tha net effect of tha algorithm. Be careful though, cuz what tha fuck do
change is tha order of executin statements, n' you can put dat on yo' toast. This can sometimes be disastrous. (See the
eraseBlob example all up in tha end of dis chapter, or tha tree traversals n' recursive tree
algorithms up in Chapta 10.)
Example 1
hood void drawLine(int n)
{
}
if (n == 0)
else
{
}
System.out.println("Thatz all, folks muthafucka! Pt II);
for (int i = 1; i &lt;= n; i++)
System.out.print("*");
System.out.println();
drawLine(n - 1);
Da method call drawLine (3) produces dis output:
***
**
*
Thatz all, folks!
NOTE
1 fo' realz. A method dat has no pendin statements followin tha recursive call be an
example of tail recursion. I aint talkin' bout chicken n' gravy biatch. Method drawLine is such a cold-ass lil case yo, but stackLyrics is
not.
2. Da base case up in tha drawLine example is n == o. Notice dat each subsequent
call, drawLine(n - 1), make progress toward termination of tha method. Y'all KNOW dat shit, muthafucka! If
your method has no base case, or if you never reach tha base case, you will
Freestylin Recursive Methods
create infinite recursion. I aint talkin' bout chicken n' gravy biatch. This be a cold-ass lil catastrophic error dat will cause yo' computer
eventually ta run outta memory n' hit you wit heart-stoppin lyrics
like java . lang . Right back up in yo muthafuckin ass. StackOverflowError
Example 2
IIIllustrates infinite recursion.
hood void catastrophe(int n)
{
}
System.out.println(n);
catastrophe (n) ;
Try hustlin tha case catastrophe (1) if you have fuckin shitloadz of time ta waste!
WRITING RECURSIVE METHODS
To come up wit a recursive algorithm, you gotta be able ta frame a process reo
cursively (i.e., up in termz of a simpla case of itself). This is different from framin it
iteratively, which repeats a process until a gangbangin' final condizzle is kicked it wit fo' realz. A phat game for
writin recursive methodz is ta first state tha algorithm recursively up in lyrics.
Example 1
Write a method dat returns n! (n factorial).
nl defined iteratively nl defined recursively
o!= 1
l!=1
2! = (2)(1)
3! = (3)(2)(1)
Da general recursive definizzle fo' n! is
{
1 n'- .- n(n-l}!
o!= 1
l! = (1)(0!)
2! = (2)(l!)
3! = (3)(2!)
n=O
n&gt;O
Da definizzle seems ta be circular until you realize dat if O! is defined, all higher factorials
are defined. Y'all KNOW dat shit, muthafucka! Code fo' tha recursive method bigs up directly from tha recursive
definition:
1* Compute n! recursively.
* Precondition: n &gt;= O.
* Postcondition: returns n! *1
hood static int factorial(int n)
{
}
if (n == 0)
return 1;
else
I/base case
return n * factorial(n - 1);
341
A recursive method
must gotz a funky-ass base case.
342 Chapta 7 Recursion
Example 2
Write a recursive method revDigs dat outputs its integer parameta wit tha digits
reversed~ For example,
revDigs(147) outputs 741
revDigs(4) outputs 4
First, describe tha process recursively: Output tha rightmost digit. Then; if there are
still digits left up in tha remainin number n/10, reverse its digits, n' you can put dat on yo' toast. Repeat dis until n/10
is o yo. Here is tha method:
1* Precondition: n &gt;= O.
* Postcondition: Outputs n wit digits reversed. Y'all KNOW dat shit, muthafucka! *1
hood static void revDigs(int n)
{
}
System.out.print(n % 10);
if (n I 10 != 0)
revDigs(n I 10);
Ilrightmost digit
Ilbase case
ANALYSIS OF RECURSIVE METHODS
Recall tha Fibonacci sequence 1, 1,2,3,5,8, 13, .... Da nth Fibonacci number equals
the sum of tha previous two numbers if n ~ 3. Recursively,
Fib(n)={l, n=1,2
Fib(n-l)+Fib(n-2), n~3
Here is tha method:
1* Precondition: n &gt;= 1.
* Postcondition: Returns tha nth Fibonacci number n' shit. *1
hood static int fib(int n)
{
}
if (n == 1 I I n == 2)
return 1;
else
return fib(n - 1) + fib(n - 2);
Notice dat there be two recursive calls up in tha last line of tha method. Y'all KNOW dat shit, muthafucka! So ta find Fib(5),
for example, takes eight recursive calls ta fib!
Fib(5)
/'" "- Fib(4) Fib(3)
/ " / " Fib(3) Fib(2) Fib(2) Fib(l)
/ " Fib(2) Fib(l)
Recursive He/per Methods
In general, each call ta fib make two mo' calls, which is tha tipoff fo' a exponential
algorithm (i.e., tha run time is O(2n)). This is much slower than tha O(n) run time of
the correspondin iteratizzle algorithm (see Chapta 5, preamble ta Question 14).
Yo ass may ask: Since every last muthafuckin recursive algorithm can be freestyled iteratively, when
should one use recursion, biatch? Bear up in mind dat recursive algorithms can incur extra run
time n' memory. Their major plus is elegizzle n' simplicitizzle of code.
General Rulez fo' Recursion
1 fo' realz. Avoid recursion fo' algorithms dat involve big-ass local
arrays-too nuff recursive calls can cause memory overflow.
2. Use recursion when it hella simplifies code.
3 fo' realz. Avoid recursion fo' simple iteratizzle methodz like factorial,
Fibonacci, n' tha linear search on tha next page.
4. Recursion is especially useful for
 Branchin processes like traversin trees or directones.
 Divide-and-conquer algorithms like mergesort and
quicksort.
SORTING ALGORITHMS THAT USE RECURSION
Mergesort n' quicksort is discussed up in Chapta 12.
RECURSIVE HELPER METHODS
A common technique up in designin recursive algorithms is ta git a hood nonrecursive
driver method dat calls a private recursive helper method ta carry up tha task.
Da main reasons fo' bustin dis are
 To chizzle tha value of a object reference. Recall dat up in Java if such a object is
passed as a parameta up in tha method, it won't be chizzled. Y'all KNOW dat shit, muthafucka! A helper must be used
that returns tha object reference (see Recursion That Altas tha Tree Structure on
p.444).
 To hide tha implementation detailz of tha recursion from tha user.
 To enhizzle tha efficiency of tha program.
343
ABONLY
344 Chapta 7 Recursion
Example 1
Consider tha simple example of recursively findin tha sum of tha straight-up original gangsta n positive
integers.
//Returns 1 + 2 + 3 + ... + n.
hood static int sum(int n)
{
}
if (n == 1)
return 1;
else
return n + sum(n - 1);
Notice dat you git infinite recursion if n :::: o. Right back up in yo muthafuckin ass. Suppose you wanna include a test
for n &gt; 0 before you execute tha algorithm. Placin dis test up in tha recursive method
is inefficient cuz if n is initially positive, it will remain positizzle up in subsequent
recursive calls. Yo ass can stay tha fuck away from dis problem by rockin a thugged-out driver method called git Sum,
which do tha test on n just once. Da recursive method sum becomes a private helper
method.
hood class FindSum
{
}
NOTE
/* Private recursive helper method.
* Findz 1 + 2 + 3 + ... + n.
* Precondition: n &gt; O. */
private static int sum(int n)
{
}
if (n == 1)
return 1;
else
return n + sum(n - 1);
/* Driver method */
hood static int getSum(int n)
{
}
if (n &gt; 0)
return sum(n);
else
{
}
throw new IllegalArgumentException
("Error: n must be positive");
This be a trivial method used ta illustrate a private recursive helper method. Y'all KNOW dat shit, muthafucka! In practice,
you would never use recursion ta find a simple sum!
Example 2
Consider a recursive solution ta tha problem of bustin a sequential search fo' a key
in a array of elements dat is Comparable. U tha key is found, tha method returns
true, otherwise it returns false.
Recursive He/per Methods
Da solution can be stated recursively as bigs up:
 If tha key is up in a[O], then tha key is found.
 If not, recursively search tha array startin at a [1] .
 If yo ass is past tha end of tha array, then tha key wasn't found.
Here be a straightforward (but inefficient) implementation:
hood class Searcher
{
}
/* Recursively search array a gangbangin' fo' key.
* Postcondition: If a[k] equals key fo' 0 &lt;= k &lt; a.length
* returns true, otherwise returns false. */
hood boolean search(Comparable[] a, Comparable key)
{
}
if (a. length == 0) //base case. key not found
return false;
else if (a[O] .compareTo(key) == 0) //base case
else
{
}
return true; / /key found
Comparable[] shorta = freshly smoked up Comparable[a.length-1];
for (int i = 0; i &lt; shorter.length; i++)
shorter[i] = a[i+1];
return search(shorter, key);
hood static void main(String[] args)
{
}
String[] list = {"Mary", "Joe", "Lee", "Jake"};
Searcher s = freshly smoked up Searcher();
System.out.println("Enta key: Mary, Joe, Lee or Jake.");
Strin key = IO.readString(); //read user input
boolean result = s.search(list, key);
if (!result)
System.out.println(key + " was not found.");
else
System.out.println(key + " was found.");
Notice how tha fuck horribly inefficient tha search method is: For each recursive call, a new
array shorta has ta be pimped hommie! It be much betta ta bust a parameter, startIndex, to
keep track of where yo ass is up in tha array. Replace tha search method above wit the
followin one, which calls tha private helper method recurSearch: .
/* Driver method. Y'all KNOW dat shit, muthafucka! Searches array a gangbangin' fo' key.
* Precondition: a cold-ass lil gotz nuff at least one element.
* Postcondition: If a[k] equals key fo' 0 &lt;= k &lt; a.length
* returns true, otherwise returns false. */
hood boolean search(Comparable[] a, Comparable key)
{
return recurSearch(a, 0, key);
}
345
346
Use a recursive helper
method ta hide
private codin details
from a cold-ass lil client.
ABONLY
Chapta 7 Recursion
/* Recursively search array a gangbangin' fo' key, startin at startIndex.
* Precondition: a cold-ass lil gotz nuff at least one element and
* 0 &lt;= startIndex &lt;= a.length.
* Postcondition: If ark] equals key fo' 0 &lt;= k &lt; a.length
* returns true, otherwise returns false. */
private boolean recurSearch(Comparable[] a, int start Index ,
Comparable key)
{
}
if(startIndex == a.length) //base case. key not found
return false;
else if (a [startIndex] .compareTo(key) == 0) //base case
return true; //key found
else
return recurSearch(a, start Index+ 1 , key);
NOTE
1. Usin tha parameta startIndex avoidz havin ta create a freshly smoked up array object for
each recursive call. Makin startIndex a parameta of a helper method hides
implementation details from tha user.
2. Right back up in yo muthafuckin ass. Since Strin implements Comparable, it is OK ta use a array of String. It
would also done been OK ta test wit a array of Integer or Double, since
they too implement Comparable.
3. Da helper method is private cuz it is called only by search within the
Searcher class.
4. It aint nuthin but easy as fuck  ta modify tha search method ta return tha index up in tha array where
the key is found: Make tha return type int n' return startIndex if tha key is
found, -1 (say) if it aint.
RECURSION IN TWO-DIMENSIONAL GRIDS
A certain type of problem crops up occasionally on tha AP exam: rockin recursion to
traverse a two-dimensionizzle array. Da problem comes up in nuff muthafuckin different guises. For
example,
1 fo' realz. A game board from which you must remove pieces.
2 fo' realz. A maze wit walls n' 'paths from which you must try ta escape.
3. White" containers" enclosed by black "walls" tha fuck into which you must "pour paint."
In each case, yo big-ass booty is ghon be given a startin posizzle (row, col) n' instructions on
what ta do. Da recursive solution typically involves these steps:
Peep dat tha startin posizzle aint outta range:
If (startin posizzle satisfies some requirement)
Perform some action ta solve problem
RecursiveCall{row+ 1, col)
RecursiveCall{row - 1, col)
RecursiveCall{row, col + 1)
RecursiveCall(row, col- 1)
Recursion up in Two-Dimensionizzle Grids
Example
On tha right be a image represented as a square grid
of black n' white cells. Two cells up in a image is part
of tha same "blob" if each is black n' there be a sequence
of moves from one cell ta tha other, where each move is
either horizontal or vertical ta a adjacent black cell. For
example, tha diagram represents a image dat gotz nuff
two blobs, one of dem consistin of a single cell.
Assumin tha followin Image class declaration, you
are ta write tha body of tha eraseBlob method, rockin a
recursive algorithm.
hood class Image
{
}
private final int BLACK = 1;
private final int WHITE = 0;
private int[] [] image; Ilsquare grid
private int size; Ilnumber of rows n' columns
hood Image() Pt II constructor
{ 1* implementation not shown *1 }
hood void display() Ildisplays Image
{ 1* implementation not shown *1 }
1* Precondition: Image is defined wit either BLACK or WHITE
cells.
* Postcondition: If 0 &lt;= row &lt; size, 0 &lt;= col &lt; size,
* n' image [row] [col] is BLACK, set all cells
* up in tha same blob ta WHITE. Otherwise image
* is unchanged. Y'all KNOW dat shit, muthafucka! *1
hood void eraseBlob(int row, int col)
1* yo' code goes here *1
Solution:
hood void eraseBlob(int row, int col)
{
}
NOTE
if (row &gt;= 0 &amp;&amp; row &lt; size &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; size)
if (image [row] [col] == BLACK)
{
}
image [row] [col] = WHITE;
eraseBlob(row - 1, col);
eraseBlob(row + 1, col);
eraseBlob(row, col - 1);
eraseBlob(row, col + 1);
1. Da orderin of tha four recursive calls is irrelevant.
347
AB (continued)
348 Chapta 7 Recursion
2. Da test
if (image [row] [col] == BLACK)
can be included as tha last piece of tha test up in tha straight-up original gangsta line:
if (row &gt;= 0 &amp;&amp; .. ,
If row or col is outta range, tha test will short-circuit, gittin tha fuck aaway from tha dreaded
ArrayIndexOutOfBoundsException.
3. If you put tha statement
image [row] [col] = WHITE;
afta tha four recursive calls, you git infinite recursion if yo' blob has more
than one cell. This is cuz, when you visit a adjacent cell, one of its recursive
calls visits tha original gangsta cell. If dis cell is still BLACK, yet mo' recursive calls
are generated, ad infinitum.
A final thought: Recursive algorithms can be tricky. Try ta state tha solution recursively
in lyrics before you launch tha fuck into code. Oh, n' don't forget tha base case!
Chapta Summary
On tha AP exam yo big-ass booty is ghon be sposed ta fuckin calculate tha thangs up in dis biatch of recursive method
calls. Recursion becomes second nature when you practice a shitload of examples. For
the mo' hard as fuck thangs, use box diagrams ta untangle tha statements, n' you can put dat on yo' toast. Peep the
format fo' recursion up in a two-dimensionizzle array-these thangs occasionally come
up on tha AP exam.
All hustlas should KNOW dat recursive algorithms can be straight-up inefficient.
Level AB hustlas should be able ta recognize which of these algorithms is exponential,
that is, O(2n).
Multiple-Choice Thangs on Recursion
MULTIPLE-CHOICE QUESTIONS ON RECURSION
1. Which of tha followin statements bout recursion is true?
I Every recursive algorithm can be freestyled iteratively.
II Tail recursion be always used up in "divide-and-conquer" algorithms.
m In a recursive definition, a object is defined up in termz of a simpla case of
itself.
(A) I only
(B) monly
(C) I n' Pt II only
(D) I n' m only
(E) Pt II n' m only
2. Which of tha following, when used as tha /* body */ of method sum, will enable
that method ta compute 1 + 2 + ... + n erectly fo' any n &gt; O?
hood int sum(int n)
//Precondition: n &gt; O.
//Postcondition: 1 + 2 + ... + n has been returned.
{
/* body */
}
I return n + sum(n - 1);
II if (n == 1)
return 1;
else
return n + sum(n - 1);
m if (n == 1)
return 1;
else
return sum(n) + sum(n - 1);
(A) I only
(B) Pt II only
(C) monly
(D) I n' Pt II only
(E) I, Pt II, n' m
349
350 Chapta 7 Recursion
3. Refer ta tha method stringRecur:
hood void stringRecur(Strin s)
{
}
if (s.length() &lt; 15)
System.out.println(s);
stringRecur(s + "*");
When will method stringRecur terminizzle without error?
(A) Only when tha length of tha input strang is less than 15
(B) Only when tha length of tha input strang is pimped outa than or equal ta 15
(C) Only when a empty strang is input
(D) For all strang inputs
(E) For no strang inputs
4. Refer ta method strRecur:
hood void strRecur(Strin s)
{
}
if (s.lengthO &lt; 15)
{
}
System.out.println(s);
strRecur(s + "*");
When will method strRecur terminizzle without error?
(A) Only when tha length of tha input strang is less than 15
(B) Only when tha length of tha input strang is pimped outa than or equal ta 15
(C) Only when a empty strang is input
(D) For all strang inputs
(E) For no strang inputs
Thangs 5 and' 6 refer ta method result:
hood int result(int n)
{
}
if (n == 1)
return 2;
else
return 2 * result(n - 1);
5. What value do result (5) return?
(A) 64
(B) 32
(C) 16
(D) 8
(E) 2
Multiple-Choice Thangs on Recursion
6. If n &gt; 0, how tha fuck nuff times will result be called ta evaluate result (n) (including
the initial call)?
(A) 2
(B) 2n
(C) n
(D) 2n
(E) n2
7. Refer ta method mystery:
hood int mystery(int n, int a, int d)
{
}
if (n == 1)
return a;
else
return d + mystery(n - 1, a, d);
What value is returned by tha call mystery (3, 2, 6)?
(A) 20
(B) 14
(C) 10
(D) 8
(E) 2
8. Refer ta method f:
hood int feint k, int n)
{
}
if (n == k)
return k;
else
if (n &gt; k)
return f(k, n - k);
else
return f(k - n, n);
What value is returned by tha call f (6, 8)?
(A) 8
(B) 4
(C) 3
(D) 2
(E) 1
351
352
9. What do method recur do?
//Precondition: x be a array of n integers.
hood int recur(int[] x, int n)
{
}
int t;
.if (n == 1)
return x [0] ;
else
{
}
t = recur(x, n - 1);
if (x[n:-l] &gt; t)
return x [n-l] ;
else
return t;
Chapta 7 Recursion
(A) It findz tha phattest value up in x n' leaves x unchanged.
(B) It findz tha smallest value up in x n' leaves x unchanged.
(C) It sorts x up in ascendin order n' returns tha phattest value up in x.
(D) It sorts x up in descendin order n' returns tha phattest value up in x.
(E) It returns x [0] or x [n-l], whichever is larger.
10. Which dopest raps bout what tha fuck tha printStrin method below do?
hood void printString(Strin s)
{
}
if (s.length() &gt; 0)
{
printString(s.substring(l»;
System. out.print(s. substrin (0 , 1»;
}
(A) It prints strang s.
(B) It prints strang s up in reverse order.
(C) It prints only tha straight-up original gangsta characta of strang s.
(D) It prints only tha straight-up original gangsta two charactaz of strang s.
(E) It prints only tha last characta of strang s.
Multiple-Choice Thangs on Recursion
11. Refer ta tha method power:
//Precondition: expo be any integer, base aint zero.
//Postcondition: base raised ta expo juice returned.
hood double power(double base, int expo)
{
}
if (expo == 0)
return 1;
else if (expo &gt; 0)
return base * power(base, expo - 1);
else
return /* code */;
Which /* code */ erectly completes method power?
(Recall dat a-n = l/an , a -:f. 0; fo' example, 2-3 = 1/23 = 1/8.)
(A) (1 / base) * power(base, expo + 1)
(B) (1 / base) * power(base, expo - 1)
(C) base * power(base, expo + 1)
0)) base * power(base, expo - 1)
(E) (1 / base) * power(base, expo)
12. Consider tha followin method:
hood void doSomething(int n)
{
}
if (n &gt; 0)
{
}
doSomething(n - 1);
System.out.print(n);
doSomething(n - 1);
What would be output followin tha call doSomethang (3)?
(A) 3211211
(B) 1121213
(C) 1213121
0) 1211213
(E) 1123211
353
354 Chapta 7 Recursion
13 fo' realz. A user entas nuff muthafuckin positizzle integers all up in tha keyboard n' terminates tha list with
a sentinel (-999) fo' realz. A writeEven method readz dem integers n' outputs tha even
integers only, up in tha reverse order dat they is read. Y'all KNOW dat shit, muthafucka! Thus, if tha user enters
3 5 14 6 1 8 -999
the output fo' tha wri teEven method will be
8 6 14
Here is tha method:
1* Assume user entas at least one positizzle integer,
* n' terminates tha list wit -999.
* Postcondition: All even integers up in tha list are
* output up in reverse order n' shit. *1
hood static void writeEven()
{
}
int num = IO.readlnt();
if (num != -999)
{
1* code *1
}
Ilread user input
Which 1* code *1 satisfies tha postcondizzle of method writeEven?
I if (num % 2 == 0)
System.out.print(num + Pt II Pt II);
writeEvenO;
II if (num % 2 == 0)
wri teEven 0 ;
System.out.print(num + Pt II Pt II);
III wri teEven 0 ;
if (num % 2 == 0)
System.out.print(num + Pt II Pt II);
(A) I only
(B) Pt II only
(C) Pt III only
(D) I n' Pt II only
(E) I, Pt II, n' Pt III
Multiple-Choice Thangs on Recursion
Thangs 14-16 refer ta method t:
//Precondition: n &gt;= 1.
hood int t(int n)
{
}
if (n == 1 I I n == 2)
return 2 * n;
else
return t(n - 1) - t(n - 2);
14. What tha fuck iz ghon be returned by t (5)?
(A) 4
(B) 2
(C) 0
(D) -2
(E) -4
15. For tha method call t (6), how tha fuck nuff calls ta t is ghon be made, includin tha originalcall?
(A) 6
(B) 7
(C) 11
(D) 15
(E) 25
16. Da run time of method t is
(A) O(n)
(B) O(n2)
(C) O(2n)
(D) O(n3)
(E) O(logn)
355
ABONLY
356 Chapta 7 Recursion
17. This question refers ta methodz fl n' f2 dat is up in tha same class:
hood int fl(int a, int b)
{ .
}
if (a == b)
return b;
else
return a + f2(a - 1, b);
hood int f2(int p, int q)
{
}
if (p &lt; q)
return p + q;
else
return p + fl(p - 2, q);
What value is ghon be returned by a cold-ass lil call ta f 1 (5, 3)?
(A) 5
(B) 6
(C) 7
(D) 12
(E) 15
18. Consider method foo:
hood int foo(int x)
{
}
if (x == 1 I I x == 3)
return x;
else
return x * foo(x - 1);
Assumin no possibilitizzle of integer overflow, what tha fuck is ghon be tha value of z after
execution of tha followin statement?
int z = foo(foo(3) + foo(4»;
(A) (15!)/(2!)
(B) 3!+4!
(C) (7!)!
(D) (3! + 4!)!
(E) 15
Multiple-Choice Thangs on Recursion
Thangs 19 n' 20 refer ta tha IntFormatta class below.
hood class IntFormatter
{
}
//Write 3 digits adjacent ta each other.
hood static void writeThreeDigits(int n)
{
}
System.out.print(n / 100);
System.out.print«n / 10) % 10);
System.out.print(n % 10);
//Insert commas up in n, every last muthafuckin 3 digits startin all up in tha right.
//Precondition: n &gt;= O.
hood static void writeWithCommas(int n)
{
}
if (n &lt; 1000)
System.out.print(n);
else
{
}
writeThreeDigits(n % 1000);
System.out.print(",");
writeWithCommas(n / 1000);
19. Da method writeWithCommas is supposed ta print its nonnegatizzle int argument
with commas properly banged (every three digits, startin all up in tha right).
For example, tha integer 27048621 should be printed as 27,048,621. Method
writeWi thCommas do not always work as intended, however n' shiznit fo' realz. Assumin no
integer overflow, which ot'the followin integer arguments aint gonna be printed
correctly?
(A) 896
(B) 251462251
(C) 365051
(D) 278278
(E) 4
20. Which chizzle up in tha code of tha given methodz will cause method
wri teWi thCommas ta work as intended?
(A) Interchange tha lines System. up . print (n / 100) and
System. out. print (n % 10) up in method wri teThreeDigi ts.
(B) Interchange tha lines writeThreeDigits(n % 1000) and
writeWithCommas(n / 1000) up in method writeWithCommas.
(C) Chizzle tha test up in writeWithCommas ta if (n &gt; 1000).
(D) In tha method wri teWi thCommas, chizzle tha line
writeThreeDigits(n % 1000) towriteThreeDigits(n / 1000).
(E) In tha method wri teWi thCommas, chizzle tha recursive call
writeWithCommas(n / 1000) towriteWithCommas(n % 1000).
357
358 Chapta 7 Recursion
21. Consider trianglez dat is formed by stackin squares, each wit area 1.
1 3 6 10
Da area of each such triangle be a triangular number n' shit. Note dat tha area of the
nth such triangle equals tha area of tha (n - 1 )th triangle plUs tha area of tha new
base.
Here is two different implementationz of a Triangle class dat serves up a
recursive method ta find tha area of these Triangle objects, given they base.
(Da differences between tha two implementations is up in bold face.)
Implementation I
hood class Triangle
{
}
private int basej
Ilconstructor
hood Triangle(int b)
{ base = bj }
hood int getArea()
{
}
if (base  1)
return 1;
Triangle smalla 
De. Triangle(base - 1);
return base +
smaller.setirea();
Implementation Pt II
hood class Triangle
{
}
private int basej
Ilconstructor
hood Triangle(int b)
{ base = b; }
hood int getArea()
{ return area(base); }
private iDt area(iDt b)
{
}
if (b  1)
return 1;
return b + area(b - 1);
Which of tha followin be a legit statement?
(A) When getArea is invoked up in a cold-ass lil client program, neither Implementation I nor
Implementation Pt II'ma work erectly.
(B) Implementations I n' Pt II is equally efficient up in speed n' memory usage.
(C) Implementation I is mo' run-time efficient than Implementation Pt II.
(0) Implementation I is mo' efficient up in memory usage than Implementation
II.
(E) Implementation Pt II has pimped outa run-time efficiency n' memory usage efficiency
than Implementation I.
Answers Explained 359
ANSWER KEY
1.D 8. D 15. D
2. B 9 fo' realz. A 16. C
3. E 10. B 17. E
4. D 11 fo' realz. A 18 fo' realz. A
5. B 12. C 19. C
6. C 13. C 20. B
7. B 14. E 21. E
It .. Pi' Pt II:IEmI
ANSWERS EXPLAINED
1. (D) Tail recursion is when tha recursive call of a method is made as tha last
executable step of tha method. Y'all KNOW dat shit, muthafucka! Divide-and-conquer algorithms like dem used in
mergesort or quicksort have recursive calls before tha last step. Thus, statement
IT is false.
2. (8) Code segment I is wack cuz there is no base case. Code segment
1lI is wack cuz, besides anythang else, sum (n) prevents tha method from
terminating-the base case n == 1 aint gonna be reached.
3. (E) When stringRecur is invoked, it calls itself irrespectizzle of tha length of s.
Since there is no action dat leadz ta termination, tha method aint gonna terminate
until tha computa runs outta memory (run-time error).
4. (D) Da base case is s.lengthO ~ 15. Right back up in yo muthafuckin ass. Since s gets longer on each method call,
the method will eventually terminate. If tha original gangsta length of s is ~ 15, the
method will terminizzle without output on tha straight-up original gangsta call.
5. (8) Lettin R denote tha method result, our crazy asses have
R(5) = 2 * R( 4)
= 2 * (2 * (R(3»)
= ...
= 2 * (2 * (2 * (2 *R(l»»
=25
=32
6. (C) For result (n) there is ghon be (n - 1) recursive calls before result (1), tha base
case, is reached. Y'all KNOW dat shit, muthafucka! Addin tha initial call gives a total of n method calls.
7. (8) This method returns tha nth term of a arithmetic sequence wit first term
a n' common difference d. Y'all KNOW dat shit, muthafucka! Lettin M denote method mystery, our crazy asses have
M(3,2,6) = 6+M(2,2,6)
= 6+ (6+M(l,2,6» (base case)
=6+6+2
= 14
360 Chapta 7 Recursion
8. (0) Here is tha recursive calls dat is made, up in order: [(6,8) - [(6,2) -
[(4,2) - [(2,2), base case. Thus, 2 is returned.
9. (A) H there is only one element up in x, then recur returns dat element yo. Having
the recursive call all up in tha beginnin of tha else part of tha algorithm causes tha if
part fo' each method call ta be stacked until t eventually gets assigned ta x [0] .
Da pendin if statements is then executed, n' t is compared ta each element
in x. Da phattest value up in x is returned.
10. (B) Since tha recursive call is made directly followin tha base case, the
System. out. print. .. statements is stacked up yo. H printStrin (" cat") is
called, here is tha sequence of recursive calls n' pendin statements on tha stack:
printString(lat") - print "C"
printString(lt") - print "a"
printString(lIlI) - print "t"
print "t"
print "a"
Iprint "c"
Execution stack
When printString(IIII), tha base case, is called, tha print statements is then
popped off tha stack up in reverse order, which means dat tha charactaz of the
strin is ghon be printed up in reverse order.
11. (A) Da required code is fo' a wack expo. For example, power(2. -3) should
return 2-3 = 1/8. Notice that
In general:
r 3=} (r2)
r 2 =} (2-1)
rl =} (20)
2n = }(2n+1) whenever n &lt; a
This is equivalent ta (1 / base) * power(base. expo + 1).
12. (C) Each box up in tha diagram below represents a recursive call ta doSomething.
Da numbers ta tha right of tha boxes show tha order of execution of tha statements.
Let D denote doSomething.
D(3)
D(2) 1
print 3 @
D(2) 12
D(2) D(2)
D(I) 2 D(I) 13
print 2 ® print 2 ® D(I) 7 D(1) 18
D(1) "D(I) D(I) D(I)
D(O) 3 D(O) 8 D(O) 14 D(O) 19
print 1 0 print 1 ® print 1 ® print 1 ® D(O) 5 D(O) 10 D(O) 16 D(O) 21
Answers Explained
Da numbers up in each box refer ta dat method call only. D(O) is tha base case, so
the statement immediately followin it is executed next. When all statements up in a
given box (method call) done been executed, backtrack along tha arrow ta find the
statement dat gets executed next. Da circled numbers represent tha statements
that produce output. Peepin dem up in order, statements 4, 6, 9, 11, 15, 17, and
20 produce tha output up in chizzle C.
13. (C) Since even numbers is printed before tha recursive call up in segment I, they
will be printed up in tha order up in which they is read from tha keyboard. Y'all KNOW dat shit, muthafucka! Contrast
this wit tha erect chizzle, segment Ill, up in which tha recursive call is made before
the test fo' evenness. These tests is ghon be stacked until tha last number is read.
Recall dat tha pendin statements is removed from tha stack up in reverse order
(most recent recursive call first), which leadz ta even numbers bein printed in
reverse order n' shit. Right back up in yo muthafuckin ass. Segment IT is wack cuz all numbers entered is ghon be printed,
irrespectizzle of whether they is even or not. Note dat segment IT would work if
the input list contained only even numbers.
14. (E) Da method generates a sequence. Da first two terms, t(l) n' t(2), is 2
and 4. Each subsequent term is generated by subtractin tha previous two terms.
This is tha sequence: 2,4,2, -2, -4, -2,2,4, .... Thus, t(5) = -4 fo' realz. Alternatively,
t(5) = t(4) - t(3)
= [t(3) - t(2)] - t(3)
= -t(2)
=-4
15. (0) 15. Count them! (Note dat you stop at t(2) since itz a funky-ass base case.)
t(6)
t(5)~ ------t(4)
,/' ~ /"
t(4) t(3) t(3) t(2)
/ " / " / " t(3) t(2) t(2) t{l) t(2) t(l)
/ " t(2) t(l)
16. (C) A simple way of seein dis is dat each call make two mo' calls. This is tha I AB ONLY
. signature of a O(2n) process.
17. (E) This be a example of mutual recursion, where two methodz call each other.
!t(5,3) = 5+ /i(4,3)
=5+(4+ !t(2,3»
=5+(4+(2+ /i(1,3)))
=5+(4+(2+4»
= 15
Note dat /i(1,3) be a funky-ass base case.
361
362 Chapta 7 Recursion
18. (A) foo(3) = 3 (This be a funky-ass base case) fo' realz. Also, foo(4) = 4 x foo(3) = 12. Right back up in yo muthafuckin ass. So you need
to find foo(foo(3) + foo( 4» = foo(15).
foo(15) = 15 x foo(14)
= 15 x (14 x foo(13»
= 15 x 14 x .. . x 4 x foo(3)
= 15 x 14 x ... x 4 x 3
= (15)!/(2!)
19. (C) Suppose dat n = 365051. Da method call writeWithCommas(365051) will
write 051 n' then execute tha call writeWithCommas(365). This be a funky-ass base case,
so 365 is ghon be freestyled out, resultin up in 051 ,365 fo' realz. A number like 278278 (two sets
of three identical digits) is ghon be freestyled up erectly, as will a "symmetrical"
number like 251462251 fo' realz. Also, any n &lt; 1000 be a funky-ass base case n' tha number will
be freestyled up erectly as is.
20. (B) Da cause of tha problem is dat tha numbers is bein freestyled up wit the
setz of three digits up in tha wack order n' shit. Da problem is fixed by interchanging
writeThreeDigits(n % 1000) n' writeWithCommas(n / 1000). For example,
here is tha order of execution fo' writeWithCommas(365051).
writeWithCommas(365) -+ Base case. Writes 365
System. up .print(", Pt II); -+ 365,
writeThreeDigits(051) -+ 365,051 which is erect
21. (E) Both getArea methodz should work erectly up in a cold-ass lil client program. Implementation
I, however, is less efficient since it constructs a freshly smoked up Triangle object
with each recursive call. This slows down tha run time n' uses mo' memory
than Implementation Pt II, which accesses only tha current Triangle object.
LEVEL AB ONLY
Linked Lists CHAPTER B
________I I!IIIiI_ __H Pt II;;u:!2If&gt;!!!I_~;;:~-:~~R_:~~. ~ ________________
But it straight-up don't matta whom you put upon tha list.
For they'd none of'em be missed-they'd none of'em be missed!
-Gilbert n' Sullivan, Da Mikado
 Linear linked lists
 Da ListNode class
 Circular linked lists
Chapta Goals
 Doubly linked lists
 Run time of linked list vs. array
algorithms
.... __ ........ __ ~ .. ~~_~~.~R~~Z=~ ._. ._ _ .........._
LINKED LIST
One way of implementin a list object up in Java be as a array fo' realz. An alternatizzle implementation
is as a linked list. Unlike a array, tha elementz of a linked list is not necessarily
in contiguous memory slots, n' you can put dat on yo' toast. Instead, each element stores tha address of tha next item
in tha list. We say dat it gotz nuff a link or pointa ta tha next item. In Java a linked
list item straight-up stores a reference ta tha next object up in tha list. Da last element of
the list has a null reference up in its pointa field ta signify tha end of tha list.
A linked list be a thugged-out dynamic data structure, growin n' shrinkin durin run time.
Memory slots is allocated as tha need arises. Right back up in yo muthafuckin ass. Slots no longer needed is automatically
recycled up in Java. Contrast dis wit a funky-ass built-in Java array, whose size is fixed at
construction time.
Implementin a linked list up in Java is part of tha AB course n' is busted lyrics bout up in this
chapter n' shit. Yo ass also need ta KNOW how tha fuck ta use tha class java. util . LinkedList<e>,
which is discussed wit tha other "container" classes up in Chapta 11.
LINEAR LINKED LISTS
LW .UR: .... "..ZUZ .W =
Featurez of a Linked List
Da term "linked list" is often used ta mean a linear linked list. Picture a linked list as
a collection of memory slots called nodes, each of which has a thugged-out data field n' a pointer
field.
Consider a linked list
for a program in
which tha number of
list elements is
initially unknown.
363
364 Chapta 8 Linked Lists
firstNode
D - L...-I ---II~I ---+--1 L...-----' ~I ---+-- L...-I ---IVlL-..l
Da arrows correspond ta reference joints up in Java. Da pointa field up in tha last item is
the null reference. Da variable firstNode be a reference ta tha straight-up original gangsta element up in tha list.
A linked list can be implemented up in Java rockin a ListNode class fo' each node n' a
LinkedList class fo' tha whole list.
Da ListNode Class
A ListNode class similar ta tha followin is ghon be provided on tha AP exam. 1
1* Linked list node *1
hood class ListNode
{
}
private Object valuej
private ListNode nextj
hood ListNode(Object initValue, ListNode initNext)
{
}
value = initValuej
next = initNextj
hood Object getValue()
{ return valuej }
hood ListNode getNext()
{ return nextj }
hood void setValue(Object theNewValue)
{ value = theNewValuej }
hood void setNext(ListNode theNewNext)
{ next = theNewNextj }
THE INSTANCE VARIABLES
I private Object value I
Any Object can be placed up in a ListNode. Primitizzle types like int or double will first
be auto-boxed. Y'all KNOW dat shit, muthafucka! See Example 1 on tha next page.
I private ListNode next I
Da ListNode class is holla'd ta be self-referential, since it has a instizzle variable next
that refers ta itself. Right back up in yo muthafuckin ass. Self-referential objects can be linked together ta form objects like
lists, trees, stacks, n' so on. I aint talkin' bout chicken n' gravy biatch. Thus, tha variable next is called a link or pointer.
1 Based on tha College Boardz AP Computa Science AB: Implementation Classes fo' Linked Lists and
Tree Nodes.
Linear Linked Lists
THE METHODS
hood ListNode(Object initValue, ListNode initNext)
Da ListNode constructor, wit initValue n' initNext parameters, allows a single
statement ta assign tha value n' next fieldz ta a ListNode.
Example 1
Da followin statement uses tha constructor ta create a single ListNode containing
the value 8.
ListNode p = freshly smoked up ListNode(new Integer(S), null); liS wrapped to
Ilcreate a Integer object
p
D 8V1
Alternatively,
ListNode p = freshly smoked up ListNode(S, null); 118 auto-boxed ta create an
IIInteger object. Not tested on tha AP exam.
I hood Object getValue() I
This be a accessor method dat returns tha value of tha current ListNode. Right back up in yo muthafuckin ass. Since the
type is Object, a cold-ass lil cast ta Integer, Double, or String, n' so on is ghon be needed, unless
you plan ta assign it ta a variable of type Object.
I hood ListNode getNext() I
This be a accessor method dat returns next, tha pointa value of tha current ListNode.
hood void setValue(Object theNewValue)
This be a mutator method dat allows tha value of tha current ListNode ta be chizzled
to theNewValue.
hood void setNext(ListNode theNewNext)
This be a mutator method dat allows tha next field of tha current ListNode ta be
changed ta theNewNext.
Example 2
Consider dis linked list of ListNode objects, where firstNode, lastNode, and
current is all of type ListNode.
current
firstNode ~ lastNode
D -I 2
1 1 .1 6
1 I .1 9 kj~ D
365
366 Chapta 8 Linked Lists
Integer first = (Integer) firstNode.getValue(); //first has value 2
ListNode p = current.getNext(); //p refers ta ListNode containin 9
int last = «Integer) current.getNext().getValue(».intValue();
//last has value 9
NOTE
An alternatizzle fo' tha last line up in Example 2 is
int last = (Integer) current.getNext().getValue();
//Uses auto-unboxin ta create a into
//Not tested on tha AP exam.
Now consider tha statements
current.setNext(null);
lastNode = current;
These two statements result up in dis setup:
current
fir.t.... ~
o ~ L.....-2I ----110......:..-..+1..- -.1 ~~ 1 6 VJ. lastNode
EJ]
Yo ass may wonder what tha fuck happened ta tha node containin 9. Java has automatic garbage
collection dat recyclez any memory slot dat is no longer up in use (i.e., there be no
references ta tha object up in dat slot).
To chizzle tha value up in tha straight-up original gangsta node ta 5:
firstNode.setValue(new Integer(5»;
Alternatively,
firstNode.setValue(5); //auto-boxing
Example 3
Consider a linked list of ListNode objects.
firstNode
C3  L.....-I ---I1~1~ . L.....-I ----II~I~ . . .. L.....----II-----I+.. -'1 ~.I~DI~:::~
Here be a cold-ass lil code segment dat traverses tha list n' outputs tha contents ta tha screen,
one element per line.
ListNode p = firstNode;
while (p !- null)
{
}
System.out.println(p.getValue(»;
p = p.getNext();
Linear Linked Lists
NOTE
Da quantitizzle p.getValueO do not need ta be cast ta tha actual object type if the
object up in tha linked list has a toStrin method. Y'all KNOW dat shit, muthafucka! Java will polymorphically select the
correct toStrin method n' print tha value accordingly.
A Linear Linked List Class
Yo ass is sposed ta fuckin know how tha fuck ta implement linked lists, n' you can put dat on yo' toast. Da LinearLinkedList
class shown below implements a singly linked list of nodes, up in which shit iz of type
Object, n' tha references iz of type ListNode fo' realz. A reference ta tha straight-up original gangsta node of the
list be a instizzle variable.
Methodz provided up in tha class will allow
 A test fo' a empty list.
 Elements ta be added or removed from either end of tha list.
 Printin a list object by providin a toStrin method.
 List traversal by a cold-ass lil client, via a getFirstNode method.
I*Linear linked list class *1
import java.util.NoSuchElementException;
hood class LinearLinkedList
{ .
private ListNode firstNode;
IIConstruct a empty list.
hood LinearLinkedList()
{ firstNode = null; }
IIReturn legit if list is empty, false otherwise.
hood boolean isEmpty()
{ return firstNode == null; }
IIAccesses tha straight-up original gangsta node; needed ta traverse tha list.
hood ListNode getFirstNode()
{ return firstNode; }
IIChanges first node of list.
hood void setFirstNode(ListNode node)
{ firstNode = nodej }
II Insert object 0 at front of list.
hood void addFirst(Object 0)
{
if (isEmptyO)
firstNode = freshly smoked up ListNode(o, null);
else
firstNode = freshly smoked up ListNode(o, firstNode)j
}
II Insert object 0 at end of list.
hood void addLast(Object 0)
{
if (isEmptyO)
367
368
else
{
}
}
Chapta 8 Linked Lists
firstNode = freshly smoked up ListNode(o, null);
ListNode current = firstNode;
while (current.getNext() != null)
current = current.getNext();
current.setNext(new ListNode(o, null»;
//Remove n' return first element.
hood Object removeFirst()
{
}
if (isEmptyO)
throw new NoSuchElementException(
"Can't remove from empty list");
Object item = firstNode.getValue();
firstNode = firstNode.getNext();
return item;
//Remove n' return last element.
hood Object removeLast()
{
}
if (isEmptyO)
throw new NoSuchElementException(
"Can't remove from empty list");
ListNode current = firstNode;
ListNode follow = null;
while (current.getNext() != null) flat least 2 nodes
{
follow = current;
current = current.getNext();
}
if (follow == null)
firstNode = null;
else
follow.setNext(null);
return current.getValue();
//list had just 1 node
//Return LinearLinkedList as String.
hood Strin toString()
{
if (isEmptyO)
return "empty.";
else
{
Strin s = "";
ListNode current = firstNode;
while (current != null)
{
}
s = s + current.getValueO + " ";
current = current.getNext();
return s;
Linear Linked Lists
}
}
}
NOTE
1. Yo ass need ta know how tha fuck ta throw a NoSuchElementException. I aint talkin' bout chicken n' gravy biatch. This error occurs
when there be a a attempt ta access a nonexistent element up in a list. (See also the
next 0 method of tha Iterator intercourse on p. 475.) In tha LinearLinkedList
class, tha exception is thrown if a attempt is made ta remove a element from
an empty list. To throw tha exception, you need ta include tha statement
import java.util.NoSuchElementException;
in tha file wit tha class whose methodz will throw tha exception. I aint talkin' bout chicken n' gravy biatch. In tha relevant
methods, tha statement
if (isEmptyO)
throw new NoSuchElementException();
will cause tha program ta terminizzle if tha list is empty fo' realz. Additionally, you can
provide yo' own error message when tha exception is thrown:
if (isEmptyO)
throw new NoSuchElementException(
"Can't remove from empty list");
2. Da class shown aint a generic class (i.e., has no type parameter). Yo ass do not
need ta know how tha fuck ta implement generic classes fo' tha AP exam.
3. Da Java Collections library serves up a cold-ass lil class java. util.LinkedList<e>. Right back up in yo muthafuckin ass. So
you may wonder why you need ta know how tha fuck ta implement such a cold-ass lil class. The
answer is dat you could tailor yo' own class ta fit any application, by providing
additionizzle methods.
Here be a program dat tests tha LinearLinkedList methods:
/* Tests LinearLinkedList class. */
hood class LinkedListTest .
{
//Return linear linked list of strings.
hood static LinearLinkedList getList()
{
}
final Strin SENTINEL = "-999";
LinearLinkedList list = freshly smoked up LinearLinkedList();
System.out.print("Enta list of lyrics. Pt II);
System.out.println("Terminizzle wit Pt II + SENTINEL);
Strin word = IO.readWord(); //read user input
while (!(word.equals(SENTINEL)))
{
list.addLast(word);
word = IO.readWord(); //read user input
}
return list;
369
370
}
Chapta 8 Linked Lists
//Search fo' key up in LinearLinkedList list.
//Return legit if found, false otherwise.
hood static boolean search(LinearLinkedList list, Object key)
{
}
ListNode current = list.getFirstNode();
while (current != null)
{
}
if. (current.getValue().equals(key»
return true;
current = current.getNext();
return false;
hood static void main(String[] args)
{
}
//TESTING getList AND toString
LinearLinkedList list = getList();
System.out.print("List is: Pt II);
System.out.println(list);
//TESTING removeFirst AND removeLast
Strin first = (String) list.removeFirst();
System.out.println("First element was: Pt II + first);
Strin last = (String) list.removeLast();
System.out.println("Last element was: Pt II + last);
System.out.print("List is: Pt II);
System.out.println(list);
//TESTING search
System.out.print("Enta key word fo' search: Pt II);
Strin key = IO.readWord(); //read user input
if (search (list , key»
System.out.println(key + Pt II is up in tha list. Pt II);
else
System.out.println(key + Pt II aint up in tha list. Pt II);
Here is some sample output.
Enta list of lyrics. Terminizzle wit -999
the pussaaaaay sat on tha mat -999
List is: tha pussaaaaay sat on tha mat
First element was: the
Last element was: mat
List is: pussaaaaay sat on the
Enta key word fo' search: on
on is up in tha list.
NOTE
Da method getFirstNode up in tha LinearLinkedList class be a cold-ass lil crucial method ta gain
access ta tha list fo' traversal outside tha class. .
Circular Linked Lists
.7
CIRCULAR LINKED LISTS
A linear linked list allows easy as fuck  access ta tha straight-up original gangsta node but requires traversal of the
whole list ta reach tha final node fo' realz. A lil' small-ass chizzle converts a linear linked list tha fuck into a
circular linked list, which allows easy as fuck  access ta both tha straight-up original gangsta n' last nodes. Let the
pointa field of tha last node point ta tha straight-up original gangsta node, instead of bein null.
~ I -1-1 ---..... 1.....--1 ~I j -I :=g, ,.sEt
--------------------------
Implementin a Circular Linked List
A circular linked list can be implemented rockin a ListNode class fo' each node and
a CircularLinkedList class fo' tha whole list. Da ListNode class is tha same ol' dirty class
used fo' linear linked lists, n' you can put dat on yo' toast. Da CircularLinkedList class has tha same ol' dirty methodz as the
LinearLinkedList class yo, but most of tha implementation code is different if you use
the instizzle variable
private ListNode lastNode;
to replace
private ListNode firstNode;
Also, instead of a getFirstNode accessor, tha CircularLinkedList class would provide
a getLastNode method.
Havin a reference ta lastNode allows easy as fuck  access ta both tha straight-up original gangsta n' last elements
of tha list. Insertion n' deletion operations at both endz of tha list can
be done up in 0(1) (constant) time. Da data up in tha straight-up original gangsta node can be accessed with
lastNode.getNext().getValue().
Note dat up in traversin a cold-ass lil circular linked list, there be a no longer a null reference in
the last node. Da lastNode reference must therefore be used as a stoplight fo' list
traversal.
Example 1
Here is code fo' tha addLast method of a CircularLinkedList class.
//Insert object 0 at end of list.
hood void addLast(Object 0)
{
}
if (isEmptyO)
{
}
else
{
}
lastNode = freshly smoked up ListNode(o. null);
lastNode.setNext(lastNode);
ListNode p = freshly smoked up ListNode(o. lastNode.getNext());
lastNode.setNext(p);
last Node = p;
371
Consider a cold-ass lil circular
linked list when
frequent access ta the
first n' last elements
is required.
372 Chapta 8 Linked Lists
NOTE
1. Yo ass may be thinkin dat addin a node ta a empty list can be accomplished with
the single statement
lastNode = freshly smoked up ListNode(o, lastNode);
This, however, won't work. Right back up in yo muthafuckin ass. Since tha current value of lastNode is null, the
right-hand side, which is evaluated first, will create a node dat has a null reference
in its next field.
2. Da else part of tha addLast method can also be freestyled as bigs up:
lastNode.setNext(new ListNode(o, lastNode.getNext(»);
lastNode = lastNode.getNext();
Example 2
Here is code fo' tha toStrin method of tha CircularLinkedList class.
//Return contentz of circular linked list as a string.
hood Strin toString()
{
}
NOTE
if (isEmptyO)
return "empty";
elae
{
}
Strin a = "";
LiatNode current = lastNode.getNext();
while (current != lastNode)
{
}
s = a + current. getValue 0 + " ";
current = current.getNext();
a = a + current.getValue();
return a;
Da while loop stops when current refers ta tha last node:
current
~ lastl ... cl-: I ~I~, ---I. -.........~..1 I.1 !b D
-----------------------
If you omit tha final a = s + current. getValue 0 statement, tha returned strang a
will not have tha data from tha last node.
Doubly Linked Lists
. &lt;1" _:      : '. ' - . '   ,,',1
DOUBLY LINKED LISTS
!\i-' ;r. Shiiit, dis aint no joke. ~~ -.'  .... 
Why Doubly Linked Lists?
Singly linked linear n' circular lists have nuff muthafuckin disadvantages:
1. Traversal is up in just one erection.
2. To access previous nodes, you must git all up in one end of tha list n' start again.
3. Given a reference ta a node, you cannot easily delete dat node. There is no
direct access ta tha previous pointa field.
A data structure dat overcomes these disadvantages be a thugged-out doubly linked list, where
each node has three fields: a thugged-out data field, a reference ta tha next node, n' a reference to
the previous node. Da price paid fo' tha capabilitizzle of movin up in either direction of
the list is tha extra memory required fo' one mo' instizzle variable up in a thugged-out doubly linked
list node.
Picture a thugged-out doubly linked list as bigs up:
firstNode last Node cp cp
V1 I FI.=-t.-I ILlIJI-~-t.1 LI ~V1
Here be a cold-ass lil circular doubly linked list:
firstNode g 1 1---t..llI -----L..JII . '1 1 ~
If tha pointa fieldz is next n' prev, notice dat f irstNode . prev refers ta tha last
(rightmost) node up in tha list. This means dat you can dispense wit a lastNode variable:
firstNode serves up 0(1) access ta both tha straight-up original gangsta n' last nodez of tha list.
Header n' Traila Nodes
Header n' traila nodes is nodes all up in tha front n' back of a linked list dat do not
contain elementz of tha list. Think of dem as dummy nodes wit no joints.
Da effect of havin header n' traila nodes is dat you stay tha fuck away from some special-case
testin fo' tha straight-up original gangsta n' last nodes: Insertion n' deletion be always done up in tha "middle"
of tha list.
Here be a empty doubly linked list wit header n' traila nodes:
373
Consider a thugged-out doubly
linked list fo' an
application that
requires forward and
backward traversal.
374 Chapta 8 Linked Lists
headerNode trailerNode T T
Implementin Doubly Linked Lists
As wit linear n' circular linked lists, tha implementation can be  bigged up  wit two
classes, one fo' tha node n' one fo' tha list.
THE DoublyListNode CLASS
Da DoublyListNode class is straight-up similar ta tha ListNode class. Well shiiiit, it requires a additional
pointa field, prev, n' additionizzle methodz fo' accessin n' settin joints n' links
for tha previous node.
1* Doubly linked list node *1
hood class DoublyListNode
{
}
private Object value;
private DoublyListNode next;
private DoublyListNode prey;
hood DoublyListNode(DoublyListNode initPrev. Object initValue.
{
}
DoublyListNode initNext)
prey = initPrev;
value = initValue;
next - initNextj
hood DoublyListNode getPrev()
{ return prey; }
hood void setPrev(DoublyListNode theNevPrev)
{ prey = theNewPrev; }
hood Object getValue()
{ return value; }
hood void setValue(Object theNewValue)
{ value = theNewValue; }
hood DoublyListNode getNext()
{ return next; }
hood void setNext(DoublyListNode theNewNext)
{ next = theNewNext; }
A DoublyLinkedList CLASS
There is nuff muthafuckin design chizzlez fo' implementin doubly linked lists-linear, circular,
with or without header and/or traila n' shit. Da class below is fo' a linear doubly linked
Doubly Linked Lists
list wit header n' traila nodes yo. Havin a header n' traila eliminates nuff of the
special end-of-list cases fo' insertion n' deletion.
1* Doubly linked list class wit header n' traila *1
import java.util.NoSuchElementException;
hood class DoublyLinkedList
{
private DoublyListNode headerNode;
private DoublyListNode trailerNode;
IIConstruct a empty list.
hood DoublyLinkedList()
{
}
headerNode = freshly smoked up DoublyListNode(null, null, null);
trailerNode = freshly smoked up DoublyListNode(headerNode, null, null);
headerNode.setNext(trailerNode);
IIReturn legit if list is empty, false otherwise.
hood boolean isEmpty()
{
return headerNode.getNext() == trailerNode;
Ilor return trailerNode.getPrev() == headerNode;
}
IIReturn first node up in a nonempty list.
hood DoublyListNode getFirstNode()
{ return headerNode.getNext(); }
IIReturn last node up in a nonempty list.
hood DoublyListNode getLastNode()
{ return trailerNode.getPrev(); }
II Insert object 0 at end of list.
hood void addLast(Object 0)
{
}
DoublyListNode p = freshly smoked up DoublyListNode(trailerNode.getPrev(),
0, trailerNode);
trailerNode.getPrev().setNext(p);
trailerNode.setPrev(p);
IIInsert object 0 at front of list.
hood void addFirst(Object 0)
{ 1* implementation code similar ta addLast *1 }
IIRemove n' return first element.
hood Object removeFirst()
{
if (isEmptyO)
throw new NoSuchElementException
("Can't remove from empty list");
DoublyListNode p = headerNode.getNext();
Object item = p.getValue();
375
376
}
}
headerNode.setNext(p.getNext(»;
p.getNext().setPrev(headerNode);
return item;
//Remove n' return last element.
hood Object removeLast()
Chapta 8 Linked Lists
{ /* implementation code similar ta removeFirst */ }
//Add item ta tha left of node.
//Precondition: node refers ta a element up in a nonempty list.
hood void addLeft(Object item, DoublyListNode node)
{
}
DoublyListNode p = freshly smoked up DoublyListNode(node.getPrev(),
item, node);
node.setPrev(p)j
p.getPrev().setNext(p);
//Add item ta tha right of node.
//Precondition: node refers ta a element up in a nonempty list.
hood void addRight(Object item, DoublyListNode node)
{ /*implementation code similar ta addLeft */ }
//Remove element referred ta by node from list.
//Precondition: node points ta element up in list.
hood void remove(DoublyListNode node)
{
}
node.getPrev().setNext(node.getNext(»j
node.getNext().setPrev(node.getPrev(»j
//Return DoublyLinkedList as String.
hood Strin toString()
{
}
if (isEmptyO)
return "empty.";
else
{
Strin s = "";
DoublyListNode p = headerNode.getNext()j
while (p != trailerNode)
{
s = s + p.getValueO + " ";
p = p.getNext();
, }
return s;
}
NOTE
1 yo. Herez a illustration of tha addLeft method. Y'all KNOW dat shit, muthafucka! Start wit a nonempty doubly .
linked list, wit node pointin ta one of tha items. Boy it's gettin hot, yes indeed it is. Because of tha header and
traila nodes, I;1ode aint gonna be at either end of tha list:
Doubly Linked Lists
node
Ef
1...1
Each statement of tha method is illustrated below:
DoublyListNode p = freshly smoked up DoublyListNode(node.getPrev(), item, node);
node
Ef
II
node.setPrev(p);
node
Ef
p.getPrev().setNext(p);
node cr
2 yo. Herez a illustration of remove fo' realz. Again, node points ta some element up in the
"middle" of tha list. This is tha element dat is ghon be removed.
node
Ef
377
378 Chapta 8 Linked Lists
Here is picturez of what tha fuck happens ta tha pointers:
node.getPrev().setNext(node.getNext(»;
node 9 l
I ]
node.getNext().setPrev(node.getPrev(»;
node
1 1 ,1 1""'-0(- tl ..L9I ----LJ-It -I --+-01 1 l I-t-I- -+--
t I
Note dat as soon as tha method is exited, there is ghon be no references ta the
deleted element, n' its memory slot is ghon be recycled.
Example.
Here be a piece of code up in a cold-ass lil client method dat tests addRight:
DoublyLinkedList dLL = getList(); //readz number strings tha fuck into dLL
DoublyListNode current = dLL.getFirstNode();
while (current != dLL.getLastNode() &amp;&amp;
(! «String) current . getValue 0 ) . equals ("6") ))
current = current.getNext();
dLL. addRight ("66" , current);
System.out.print("List is: Pt II);
System.out.println(dLL);
If tha list entered is 2 4 6 8, tha output is
List is: 2 4 6 66 8
If tha list entered is 5 10 15, tha output is
List is: 5 10 15 66
NOTE
Because of tha symmetry of a thugged-out doubly linked list, similar thangs up in dis biatch can be  bigged up  by
initializin current wit dLL . getLastNode () , n' then travelin "left" with
current = current.getPrev();
Run Time of Linked List vs fo' realz. Array Algorithms
RUN TIME OF LINKED LIST VS fo' realz. ARRAY ALGORITHMS
In each case, assume n elements up in a singly linked linear linked list (ILL) n' also up in an
array dat has sufficient slots fo' tha operations busted lyrics bout below. Yo ass may also assume
that tha linked list implementation has a reference ta tha straight-up original gangsta node only.
Algorithm
Add or remove element
at end
Add or remove element
at front
Linear search fo' key
Insert element In
correct posizzle in
sorted list
(a) Find insertion point
_(b) Illsert elel11~nt .
Delete all occurrences
of value from list
LLL Array Comment
O(n)
0(1)
O(n)
O(n)
0(1)
O(n)
0(1)
For LLL, must traverse whole
list. For array, simple assignment:
a[n+l] = element.
---- For-array, must. move each- element.
up one slot ta create empty slot in
O(n) a[O]. For LLL, simple pointa ad-
_.. . __ ._~ .. justment. . _. .. . ____ ._
In most shitty case, need ta search entire
O(n) LLL or array.
-_ .. ,,_ ... --_.--_ .. --- - - ... -
Insertion up in LLL requires just
pointa adjustments, n' you can put dat on yo' toast. For array,
011 ) binary search ta find insertion; but
vog n then may gotta move n elements
O(n) ta create a slot.
O(n)
For LLL, find value, adjust pointers,
find value, adjust pointers, etc. For
array, 0(n2) if all elements moved
each time you find value. O(n) algorithm
in Chapta 6, Question 5.
Chapta Summary
Know tha difference between each type of linked list. Yo ass could be axed ta produce
code dat manipulates or traverses each type. Know how tha fuck ta use tha ListNode class and
how ta write linked list classez of yo' own.
Yo ass should also be able ta say shit bout tha typez of applications fo' which each kind of
list is suitable as a thugged-out data structure.
Know tha big-O run times fo' tha various operations on linked lists n' be able to
compare these wit similar operations up in arrays.
379
380 Chapta 8 Linked Lists
MULTIPLE-CHOICE QUESTIONS ON LINKED LISTS
Assume dat all thangs on linear n' circular linked lists use tha ListNode class
provided on tha AP exam (see p. 364).
1. Da followin segment is supposed ta search fo' n' remove from a linear linked
list all nodes whose data fieldz is equal ta val, a previously defined value fo' realz. Assume
that firstNode be accessible n' references tha straight-up original gangsta node up in tha list, n' that
the list is nonempty.
ListNode current = firstNode;
while (current != null)
{
}
if (current.getValue().equals(val»
{
}
else
ListNode q = current.getNext();
current.setNext(q.getNext(»;
current = current.getNext();
Which is legit bout dis code segment?
(A) It works fo' all tha nodez of tha linked list.
(B) It fails fo' only tha straight-up original gangsta node of tha list.
(C) It fails fo' only tha last node of tha list.
(0) It fails fo' tha straight-up original gangsta n' last nodez of tha list but works fo' all others.
(E) It fails fo' all nodez of tha list.
Multiple-Choice Thangs on Linked Lists
2 fo' realz. A circular linked list (CLL) is implemented wit a CircularLinkedList class that
has a private instizzle variable lastNode:
ListNode lastNodej Ilrefers ta last node of CLL
Da CircularLinkedList class has a toStrin method dat converts tha contents
of a cold-ass lil circular linked list ta a strang up in tha erect order n' shit. Consider a wri teList
method up in tha CircularLinkedList class:
1* Writes elementz of CLL ta screen.
* Assumes contentz of CLL gotz a toStrin method.
* Precondition: List aint empty.
* lastNode refers ta last node up in list.
* Postcondition: All elements printed ta screen. I aint talkin' bout chicken n' gravy biatch. *1
hood void writeList()
{ I * implementation code * I }
Which of tha followin could replace 1* implementation code *1 so that
wri teList works as intended?
I System.out.println(this)j
IT ListNode current = lastNode.getNext()j
while (current != lastNode)
{
System.out.println(current.getValueO + Pt II ") j
current = current.getNext()j
}
System.out.println(current.getValue())j
ITI fo' (ListNode current = lastNode.getNext()j
current != lastNodej current = current.getNext())
System.out.println(current.getValueO + Pt II Pt II) j
(A) I only
(B) IT only
(C) monly
(D) I n' IT only
(E) I, IT, n' m
381
382 Chapta 8 Linked Lists
3. Consider a LinearLinkedList class dat has a instizzle variable firstNode of
type ListNode n' a accessor method getFirstNode dat returns a reference to
the first element up in tha list. Consider a cold-ass lil client method findKey:
1* Search fo' key up in LinearLinkedList a.
* Return legit if found, false otherwise. *1
hood static boolean findKey(LinearLinkedList a, Object key)
{
}
ListNode current = a.getFirstNode()j
while (current != null &amp;&amp; !current.getValue().equals(key»
current = current.getNext()j
return current != nullj
Which is legit bout method findKey?
(A) findKey works as intended only if key is up in tha list.
(B) f indKey works as intended only if tha list is nonempty.
(C) findKey works as intended only if key aint up in tha last node of tha list.
(D) findKey do not work under any circumstances.
(E) findKey always works as intended.
4. Consider a bang method up in a LinearLinkedList class:
1* Precondition: current refers ta a node up in a nonempty linked
* list sorted up in increasin order.
* Postcondition: element banged directly followin node to
* which current points, n' you can put dat on yo' toast. *1
hood void insert(ListNode current, Object element)
{
}
What tha fuck iz tha run time of 1* code *1, assumin da most thugged-out efficient algorithm?
(A) 0(1)
(B) O(n)
(C) 0(n2)
(D) O(logn)
(E) O(nlogn)
Multiple-Choice Thangs on Linked Lists
5 fo' realz. A circular linked list has a reference firstNode dat points ta tha straight-up original gangsta element
in tha list n' is null if tha list is empty. Da followin segment is intended to
count tha number of nodes up in tha list:
int count = 0;
ListNode p = firstNode.getNext();
while (p != firstNode)
{
count++;
P = p.getNext();
}
Which statement is true?
(A) Da segment works as intended up in all cases.
(B) Da segment fails up in all cases.
(C) Da segment works as intended whenever tha list is nonempty.
(0) Da segment works as intended when tha list has just one element.
(E) Da segment works as intended only when tha list is empty.
6. Consider tha followin method fo' removin a value from a linear linked list:
IIPrecondition: p points ta a node up in a nonempty
II linear linked list.
IIPostcondition: Da value dat p points ta has been removed
I I from tha list.
hood void remove(ListNode p)
{
}
ListNode q = p.getNext();
p.setValue(q.getValue(»;
p.setNext(q.getNext(»;
In which of tha followin cases will tha remove method fail ta work as intended?
I p points ta any node up in tha list other than tha straight-up original gangsta or last node.
II p points ta tha last node up in tha list.
m p points ta tha straight-up original gangsta node, n' there is mo' than one node up in tha list.
(A) Ionly
(B) Pt II only
(C) I n' Pt II only
(0) I n' m only
(E) I, Pt II, n' m
7. Right back up in yo muthafuckin ass. Suppose dat tha precondizzle of method remove up in Question 6 is chizzled so that
the method always works as intended. Y'all KNOW dat shit, muthafucka! What tha fuck iz tha run time of tha algorithm?
(A) O(n)
(B) O(Ji)
(C) 0(1)
(0) 0(n2)
(E) O(logn)
383
384 Chapta 8 Linked Lists
8. Right back up in yo muthafuckin ass. Suppose dat listl n' list2 refer ta tha straight-up original gangsta nodez of two linear linked lists,
and dat q points ta some node up in tha straight-up original gangsta list. Da first piece of tha straight-up original gangsta list,
namely all tha nodes up ta n' includin tha one pointed ta by q, is ta be removed
and attached ta tha front of list2, maintainin tha order of tha nodes. Mter
removal, listl should point ta tha remainin nodez of its original gangsta list, n' list2
should point ta tha augmented list. If neither q nor listl is originally null, then
this task is erectly performed by which of tha followin program segments?
Assume dat P n' q is both erectly declared ta be of type ListNode.
I q.setNext(list2)i
list2 = listl i
listl = q.getNext()i
n while (listl != q.getNext(»
{
}
P = listli
listl = listl.getNext()i
p.setNext(list2)i
list2 = Pi
listl = Pi
III p = q.getNext()i
q.setNext(list2)i
list2 = listl i
listl = Pi
(A) None
(B) Pt III only
(C) I n' Pt III only
(D) n n' Pt III only
(E) I, n, n' Pt III
Multiple-Choice Thangs on Linked Lists
9. Refer ta method search:
1* Returns reference ta first occurrence of key up in list.
* Returns null if key not up in list.
* Precondition: node points ta first node up in list. *1
hood static ListNode search(ListNode node, Object key)
{
}
Which of tha followin replacements fo' 1* code *1 will result up in method search
workin as intended?
I if (node.getValue().equals(key»
return node;
else
return search(node.getNext(), key);
II ListNode current = node;
while (current != null)
{
}
if(current.getValue().equals(key»
return current;
current = current.getNext().
return null;
III ListNode current = node;
while (current != null &amp;&amp; !current.getValue().equals(key»
current = current.getNext();
return current;
(A) I only
(B) Pt II only
(C) Pt III only
(D) Pt II n' Pt III only
(E) I n' Pt II only
385
386 Chapta 8 Linked Lists
Thangs 10 n' 11 refer ta circular linked lists n' a cold-ass lil concat method busted lyrics bout below.
Circular linked lists is implemented wit a CircularLinkedList class dat has a private
instizzle variable lastNode of type ListNode. Da class gotz nuff, among others,
the followin methods:
hood boolean isEmpty() Ilreturns legit if list is empty
hood ListNode getLastNode() I/returns lastNode
hood void setLastNode(ListNode node) I/sets lastNode ta node
Consider two CircularLinkedList objects listl n' list2. For example,
lastNode lastNode T T
-----~ listl list2
A method concat appendz list2 ta listl n' thangs up in dis biatch up in a augmented list1. The
method call concat (listl, list2) should produce
lastNode
listl
H list 1 is initially empty n' list2 be as shown, concat (list 1, list2) should produce
lastNode T
listl
H list2 is initially empty n' listl be as shown, concat(listl, list2) should produce
lastNode T
list 1
Multiple-Choice Thangs on Linked Lists
Here is tha concat method:
/* Precondition: listl n' list2 is CircularLinkedList objects.
* Postcondition: list2 has been appended ta listl. */
hood static void concat(CircularLinkedList listl,
CircularLinkedList list2)
{
}
ListNode Ll = listl.getLastNode();
ListNode L2 = list2.getLastNode();
if (listl.isEmpty())
{
/* code */
}
else if (!list2.isEmpty())
{
/* mo' code */
}
10. Which replacement fo' /* code */ achieves tha required postcondizzle when
listl is empty?
I listl = list2;
II Ll = L2;
III listl.setLastNode(L2);
(A) I only
(B) Pt II only
(C) Pt III only
(D) I arid Pt III only
(E) Pt II n' Pt III only
11. Which could replace /* mo' code */ so dat tha postcondizzle of concat is satisfied?
Yo ass may assume tha existence of tha followin swap method:
//Interchange ListNode fieldz of ListNodes pi n' p2.
hood static void swap(ListNode pi, ListNode p2)
I Ll.setNext(L2.getNext());
L2.setNext(Ll.getNext());
listl.setLastNode(L2);
II ListNode p = Ll.getNext();
Ll.setNext(L2.getNext());
L2.setNext(p);
listl.setLastNode(L2);
III swap(listl.getLastNode(), list2.getLastNode());
listl.setLastNode(list2.getLastNode());
(A) I only
(B) Pt II only
(C) Pt III only
(D) Pt II n' Pt III only
(E) I n' Pt II only
387
388 Chapta 8 Linked Lists
For Thangs 12-16 assume dat linear linked lists is implemented wit a cold-ass lil class
LinearLinkedList as shown.
hood class LinearLinkedList
{
}
private ListNode firstNode;
//constructor n' other methods
hood ListNode getFirstNode()
{ return firstNode; }
//Change firstNode ta node.
hood void setFirstNode(ListNode node)
{ firstNode = node; }
//Insert Object 0 at front of list.
hood void addFirst(Object 0)
{ /* implementation not shown */ }
Multiple-Choice Thangs on Linked Lists
12. This question refers ta a cold-ass lil client method mystery:
hood static void mystery(LinearLinkedList list)
{
}
ListNode hold = list.getFirstNode();
list.setFirstNode(null);
while (hold != null)
{
}
ListNode grab = hold;
hold = hold.getNext();
grab.setNext(list.getFirstNode(»;
list.setFirstNode(grab);
Assume a initial list
firstNode
~I 2 If--.I 4 If---.I 6 1 f---.I 8 1I1
Afta tha method call mystery (list), what tha fuck will tha list look like?
(A) firstNode
~I 4 If---.I 2 If---.I 8
1 f---.I 6 V1
(B) firstNode
~I 2 Lf---.I 4 If---.I 6 Ij--.I 8 V1
(C) firstNode
~I 8 11rl 4 F'rl 6 Irl 2 Pt III
(0) firstNode G-+I 2 Va--.l 6 I'rl 4 Irl 8 V1
(E) firstNode
~I 8 1'1 ' I 6 I rl 4 I'rl 2 1I1
389
390 Chapta 8 Linked Lists
13 fo' realz. A client method minimum returns a ListNode dat gotz nuff tha smallest value up in a
linear linked list:
1* Precondition: list be a nonempty linear linked list of
* Comparable objects.
* Postcondition: Reference moonwalked back ta ListNode with
* smallest value. *1
hood ListNode minimum(LinearLinkedList list)
{
}
ListNode minSoFar = list.getFirstNode();
ListNode p = minSoFar.getNext();
while (p != null)
{
}
if «(Comparable) p.getValue(».compareTo
(minSoFar.getValue(» &lt; 0)
minSoFar = p;
p = p.getNext();
return minSoFar;
Suppose minimum (list) is called fo' tha followin list:
firstNode 9
2 I I ~I -6 I I ~I 1 I I ~ I 4 lL1
Which of tha followin do not satisfy tha loop invariant fo' tha while loop?
firstNode minSoFar
9 9
(A) I 2 I I ~ I -6 I I ~ I 1 I I ~ I 4 V1
~ P
firstNode minSoFar P
(B) 9 9 9
I 2 I I ~I -6 I I ~I 1 I I ~ I 4 V1
Multiple-Choice Thangs on Linked Lists
firstNode minSoFar
(C) 9 9
P
9
2 1 1 _I -6
1 .1
firstNode minSoFar
(D) 1 9 9
2
1 1 -I -6
1 1
P == null
firstNode P
9 9
(E) 1 2
1 1 -I -6
1 1 -I 1 I 1 -I 4 Vl
cb minSoFar
14. Right back up in yo muthafuckin ass. Suppose a method addSecond be added ta tha LinearLinkedList class:
1* Precondition: list gotz nuff at least one element.
* Postcondition: New node containin Object 0 banged at
* second posizzle up in list. *1
hood void addSecond(Object 0)
{ 1* implementation code *1 }
Which of tha followin could replace 1* implementation code *1 so dat method
addSecond works as intended?
(1\) firstNode.getNext(new ListNode(o, firstNode.getNext(»);
(B) firstNode.setNext(o, firstNode.getNext(»;
(C) firstNode.setNext(new ListNode(o, firstNode.getNext(»);'
(D) firstNode.setNext(ListNode(o, firstNode.setNext(»);
(E) firstNode = firstNode.getNext();
firstNode.setNext(ListNode(o, firstNode»;
391
392 Chapta 8 Linked Lists
15. Consider a append method fo' tha LinearLinkedList class:
/* Precondition: list aint null.
* Postcondition: Object 0 added ta tha end of list. */
hood void append(Object 0)
{
}
ListNode current = firstNode;
/* mo' code */
Which erectly replaces /* mo' code */ so dat tha postcondizzle of append is
satisfied?
(A) while (current.getNextO != null)
current = current.getNext();
current.setNext(new ListNode(o. null));
(B) while (current != null)
current = current.getNext();
current.setNext(new ListNode(o. null));
(C) while (current.getNext() != null)
current = current.getNext();
current = freshly smoked up ListNode(o. null);
0) while (current != null)
current = current.getNext();
current = freshly smoked up ListNode(o. null);
(E) while (current.getNext() != null)
current = current.getNext();
current.getNext(new ListNode(o. null));
16. Consider tha followin client method, print.
//Precondition: list is empty.
hood void print(LinearLinkedList list)
{
}
for (int i = 1; i &lt;= 5; i++)
list.addFirst(new Integer(i));
ListNode p = list.getFirstNode();
while (p != null)
{
}
System.out.print(p.getValue());
p = p.getNext();
What tha fuck iz ghon be printed as a result of callin method print?
(A) 12345
(B) 54321
(C) 2345
0) 5
(E) 1
Multiple-Choice Thangs on Linked Lists
Thangs 17-19 refer ta tha DoublyListNode class on p. 374.
17. Consider a thugged-out doubly linked list of Strin joints as shown:
P cp
Da value "fie" is ta be banged between "fee" n' "foe" yo. Here be a cold-ass lil code segment
that achieves this:
DoublyListNode q = freshly smoked up DoublyListNode(p.getPrevO, "fie", p);
1* mo' code *1
Which be a cold-ass lil erect replacement fo' 1* mo' code */?
I p.getPrev().setNext(q);
p.setPrev(q);
II p. setPrev (q) ;
q.getPrev().setNext(q);
III p.setPrev(q);
p.getPrev().setNext(q);
(A) I only
(B) Pt II only
(C) Pt III only
(D) I n' Pt II only
(E) I, Pt II, n' Pt III
393
394 Chapta 8 Linked Lists
18. Right back up in yo muthafuckin ass. Suppose a thugged-out doubly linked list aint gots header or traila nodes. Consider
method remove:
1* Precondition: p points ta a node up in a nonempty
* doubly' linked list.
* Postcondition: Node p has been removed from tha list. *1
hood void remove(DoublyListNode p)
{
}
p.getPrev().setNext(p.getNext(»;
p.getNext().setPrev(p.getPrev(»;
In which of tha followin cases will remove fail ta work as intended?
I p points ta tha straight-up original gangsta node up in tha list.
IT p points ta tha last node up in tha list.
III p points ta a node other than tha straight-up original gangsta or last node up in tha list.
(A) I n' Pt II only
(B) Pt III only
(C) I n' Pt III only
(D) I, IT, n' Pt III
(E) None. Method remove will always work as intended.
19. Consider a thugged-out doubly linked list wit three nodes as shown:
node
D
Which of tha followin code segments converts dis list tha fuck into a thugged-out doubly linked
circular list wit three nodes, biatch? (Assume dat afta execution tha node reference
may point ta any node.)
I q.setNext(node);
q = q.getNext();
node.setPrev(q);
II node.setPrev(p.getNext(»;
p.getNext().setNext(node);
III p.getPrev().setPrev(q);
q.setNext(p.getPrev(»;
(A) I only
(B) Pt II only
(C) Pt III only
(D) IT n' Pt III only
(E) I, Pt II, n' Pt III
Multiple-Choice Thangs on Linked Lists
20 fo' realz. Assume a DoublyLinkedList class implements doubly linked lists, n' you can put dat on yo' toast. Each
DoublyLinkedList gonna git a header n' traila node.
hood class DoublyLinkedList
{
}
private DoublyListNode headerNode;
private DoublyListNode trailerNode;
//constructor
//Creates a empty list.
hood DoublyLinkedList()
{ /* implementation not shown */ }
//Returns first node up in list.
hood DoublyListNode getFirstNode()
{ return headerNode.getNext(); }
//other methodz not shown ...
Suppose tha DoublyLinkedList class gotz nuff a addRight method.
/* Precondition: node refers ta a element up in a nonempty list.
* Postcondition: item added ta tha right of node. */
hood void addRight(Object item, DoublyListNode node)
{
}
DoublyListNode p = freshly smoked up DoublyListNode(node, item,
node.getNext(»;
/ * mo' implementation code * /
Which of tha followin represents /* mo' implementation code */ dat will result
in tha desired postcondition?
I node.setNext(p);
node.getNext().setPrev(p);
IT node.getNext().setPrev(p);
node.setNext(p);
III node.setNext(p);
p.getNext().setPrev(p);
(A) I only
(B) IT only
(C) Pt III only
(D) I n' Pt II only
(E) IT n' Pt III only
395
396 Chapta 8 Linked Lists
21 fo' realz. A list of shit is ta be maintained up in random order n' shit. Operations performed on
the list include
(1) Insertion of freshly smoked up shit all up in tha front of tha list.
(2) Deletion of oldschool shit from tha rear of tha list.
A programmer considaz rockin a linear singly linked list (LLL), a cold-ass lil circular singly
linked list (CLL), or a array ta store tha items. Boy it's gettin hot, yes indeed it is. Which of tha followin erectly
represents tha run-time efficiency of (1) insertion n' (2) deletion fo' dis list?
Yo ass may assume that
 Da array has sufficient slots fo' insertion.
 Linear linked lists is implemented wit a reference ta tha straight-up original gangsta node only.
 Circular linked lists is implemented wit a reference ta tha last node only.
 Da most efficient algorithm possible is used up in each case.
(A) array: (1)0(n) (2) 0(1)
LLL: (1) 0(1) (2) O(n)
CLL: (1) 0(1) (2) O(n)
(B) array: (1)0(n) (2) 0(1)
LLL: (1) 0(1) (2) O(n)
CLL: (1) 0(1) (2) 0(1)
(C) array: (1) 0(1) (2) 0(1)
LLL: (1) 0(1) (2) 0(1)
CLL: (1) 0(1) (2) 0(1)
(D) array: (1) O(n) (2) O(n)
LLL: (1) 0(1) (2) O(n)
CLL: (1) 0(1) (2) O(n)
(E) array: (1) 0(1) (2) O(n)
LLL: (1) O(n) (2) 0(1)
CLL: (I)O(n) (2) 0(1)
Multiple-Choice Thangs on Linked Lists
22. This question refers ta tha remove method below:
hood static ListNode remove(ListNode node, Object val)
{
}
if (node != null)
{
}
else
ListNode restOfList = remove(node.getNext(), val);
if (node.getValue().equals(val»
else
{
}
return restOfList;
node.setNext(restOfList);
return node;
return null;
In a test of tha method, a cold-ass lil client program has dis code segment:
LinearLinkedList list = freshly smoked up LinearLinkedList();
getList(list); //read joints tha fuck into list
readValue(val); //prompt fo' n' read up in val
ListNode p = remove(list.getFirstNode(), val);
list.setFirstNode(p);
What do remove do?
(A) Removes all occurrencez of val up in tha list.
(B) Removes all shit up in tha list dat is not equal ta val.
(C) Removes only tha straight-up original gangsta item up in tha list, if n' only if it equals val.
(D) Removes all shit up in tha list, irrespectizzle of value.
(E) Leaves tha list unchanged.
397
398
ANSWER KEY
1. E
2. D
3. E
4 fo' realz. A
5. B
6. B
7. C
8. B
9. D
10. C
11.D
12. E
13 fo' realz. A
14. C
15 fo' realz. A
16. B
ANSWERS EXPLAINED
Chapta 8 Linked Lists
17. D
18 fo' realz. A
19. D
20. E
21 fo' realz. A
22 fo' realz. A
1. (E) Here is what tha fuck happens if current is pointin ta a node dat must be removed:
current q cp cp
------. ,---I. ....L.--.-+II -1 ----.. I Pt II I .1 I I .1 1,&lt; "~J
I +
~---------- ______ I
Da algorithm attempts ta remove tha node followin tha node dat should be
deleted:
2. (0) Segment I works cuz tha CircularLinkedList class has a toString
method. Y'all KNOW dat shit, muthafucka! Da method will therefore print up tha strang form of tha entire object.
In segment Pt II tha while loop stops when current refers ta tha last node. To print
the data up in tha last node, you need tha additionizzle statement
System.out.println(current.getValue(»;
Da fo' loop up in segment ill is equivalent ta tha while loop up in segment Pt II.
Thus, segment ill would done been erect if afta tha loop it had tha additional
System. out. println ... statement.
3. (E) If current is null, tha test is ghon be short-circuited, n' there is ghon be no dereferencing
of a null pointa up in tha second half of tha test fo' realz. Also, if current is null,
key was not found, n' tha method will return false, which is erect.
4. (A) Da method do not find tha insertion point; it merely attaches a freshly smoked up node.
This be a cold-ass lil constant O( 1) operation.
5. (B) When there be no elements up in tha circular linked list (i.e., firstNode is null),
a NullPointerException is ghon be thrown. I aint talkin' bout chicken n' gravy biatch yo. H there be a just one element up in tha list:
Answers Explained
p
D
Da test will fail immediately, leavin a cold-ass lil count of o. In all other cases, count will
have a value one less than tha actual number of nodes.
6. (B) If p points ta tha last node, q = p. setNext () will give q a value of null. Referring
to q. git Value 0 will then cause a NullPointerException ta be thrown.
7. (C) Provided p don't point ta tha last node up in tha list, dis be a nifty algorithm
that requires no list traversal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Well shiiiit, it is independent of tha number of nodes up in tha list
and is therefore O( 1).
8. (B) In segment I tha statement q. setNext (list2) maroons tha second piece of
the first list: list1 can no longer be reassigned. Y'all KNOW dat shit, muthafucka! Da first statement of segment
ill, p = q.getNext(), is crucial ta stay tha fuck away from losin dat piece of tha straight-up original gangsta list. The
reference assignments up in segment IT make no sense.
9. (0) Segment I is missin a funky-ass base case. Well shiiiit, it would be erect if preceded by
if (node == null)
return null;
else
{ ...
10. (C) Segment I is wack cuz list1 n' list2 is passed by value. Therefore
when tha method is exited, listl gonna git its initial value; dat is, it will be
empty. Right back up in yo muthafuckin ass. Segment IT fails cuz tha setLastNode method must be used ta chizzle
the lastNode of list1 as required: getLastNode be a accessor n' can't be used
for dis purpose.
11. (0) Segment I fails cuz tha straight-up original gangsta line breaks tha connection ta tha straight-up original gangsta node of
list1. Now tha next field of L2 gets connected ta tha straight-up original gangsta node of list2, where
it was ta begin with! Segment IT avoidz dis problem up in its first line by rockin a
temporary reference ta hold tha address of tha straight-up original gangsta node up in list 1. Notice dat the
first three linez of segment IT is exactly tha code ta interchange listl. getNext 0
and list2.getNext() erectly, so segment ill be also erect.
12. (E) This breathless-soundin algorithm reverses pointas up in tha list yo. Here be a
picture of tha loop invariant fo' tha while loop:
firstNode
Ef
L ______~___ _ I
hold
Ef
In lyrics, firstNode points ta tha part of tha list thatz already been reversed,
and hold points ta tha part of tha original gangsta list dat still need ta be taken care of.
13. (A) Da loop invariant fo' tha while loop is dat minSoFar points ta tha sm.,llest
value up ta n' excludin tha node dat p points to. Notice dat p be advanced
right all up in tha end of tha loop Qast statement), so tha node dat p points ta on
exitin tha loop has not yet been examined.
399
400 Chapta 8 Linked Lists
14. (C) Da erect code needz f irstNode. set Next ( ... ) cuz tha next field of
the first node is ghon be altered. Y'all KNOW dat shit, muthafucka! Well shiiiit, it also needz freshly smoked up ListNode ... cuz a freshly smoked up node
is bein pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da expression
new ListNode(o, firstNode.getNext(»;
uses tha constructor of tha ListNode class. Well shiiiit, it is ghon be evaluated first:
Finally firstNode. setNext ( ... ) sets tha next field of firstNode ta point ta the
new node (dashed arrow up in tha figure above).
15. (A) Da test must be
while (current.getNext() != null)
so dat current eventually points ta tha last node. This eliminates chizzlez B and
D. Chizzlez C n' D make tha fuck up of assignin current ta tha freshly smoked up node,
which means dat tha node won't git attached ta tha list. Eliminizzle chizzle E
because setNext, not getNext, must be used ta modify tha next field of tha last
node.
16. (B) Each pass all up in tha fo' loop creates a freshly smoked up node all up in tha front of tha linked
list, resultin in
firstNode cp
5 I+-I 4 1 +-1 3 1 +-1 2 1 +-1 1 V1
Thus, 54321 is ghon be printed.
17. (0) In segment Pt III, herez tha thang afta p. setPrev (q):
p cp
q
p.getPrevO now refers ta node q, which means dat tha node wit "fee" will
not have tha erect next pointa connection.
Answers Explained
18. (A) Cases I n' Pt II both fail cuz a null pointa is bein dereferenced. Y'all KNOW dat shit, muthafucka! For the
first node, p. getPrev () is null. For tha last node, p. getNext () is null.
19. (0) Chizzle I chizzlez tha pointa connections incorrectly, as shown:
p
20. (E) Herez what tha fuck goes wack up in segment I: Afta node. setNext (p), tha expression
node. getNext 0 no longer refers ta tha node ta tha right of node. Well shiiiit, it refers ta the
new node biaaatch! Here is tha fucked up pointa connections followin execution of segment
I:
node cr
21. (A) To bang all up in tha front of a array requires movement of all n elements to
create a slot-thus, O( n). Both tha Pt III n' tha Cll require just pointa adjustments
to bang a node all up in tha front: 0(1). To remove all up in tha rear requires simply
an adjustment on tha number of elements up in tha array, 0(1). To remove from the
rear of a Pt III requires traversal of tha list ta reach tha last node, O(n). Well shiiiit, it would
seem dat a Cll would be O( 1) fo' removin a element from tha rear, since
the external pointa points ta tha last element. Da problem is dat ta remove
the last element requires accessin tha pointa field of tha previous node, which
requires traversal along tha entire list, O(n).
22. (A) Herez a recursive description of tha remove method: If tha list aint empty,
then if tha straight-up original gangsta node gotz nuff val, remove dat node. Now repeat dis procedure
for tha rest of tha list. Da tricky part of tha algorithm lies up in returnin the
correct reference fo' each recursive call.
Suppose tha method is called fo' a linear linked list of three nodes, up in which
only tha second node gotz nuff val:
a
D
label tha references ta tha three nodes a, b, n' c, as shown. I aint talkin' bout chicken n' gravy biatch yo. Herez a recursion
diagram ta execute remove(a. val). In tha diagram, r denotes restOfList. The
401
402 Chapta 8 Linked Lists
circled numbers indicate tha order of execution of tha statements, n' you can put dat on yo' toast. Look at the
statements up in dat order.
remove (a)
r .. remove(b) <d r="" is="" c="" if="" a.value="" val="" (from@)="" return="" else="" ®="" a.setnext(r)="" a.setnext(c)="" a="" remove="" (b)="" 0="" (from="" 0)="" (c)="" b.="" value="" @="" 1---------1="" b="" -="" (null)="" q)="" base="" case.="" null="" c.value="" c.setnext(r)="" c.setnext(null)="" note:="" recursive="" method="" like="" dat="" altas="" linked="" structure="" (list="" or="" tree)="" cannot="" be="" implemented="" by="" passin="" listnode="" parameta="" may="" need="" ta="" changed="" tha="" method.="" y'all="" know="" shit,="" muthafucka!="" this="" cuz="" passed="" and="" will="" always="" emerge="" from="" wit="" its="" unchanged.="" da="" must="" freestyled="" so="" it="" returns="" listnode.="" how="" fuck="" chizzlez="" up="" in="" nodes="" get="" preserved.="" contrast="" search="" of="" question="" 9.="" method,="" list="" never="" chizzled,="" itz="" ok="" git="" whose="" emerges="" call="" level="" ab="" only="" stacks="" n'="" oueues="" stack="" sizes="" should="" dictate="" yo'="" decision.="" -pizzle="" lchiban,="" poker="" website="" chapta="" goals="" ="" stack<e=""> class
 Queues n' tha Queue<e>
interface
STACKS
What Is a Stack?
 Prioritizzle queues n' the
PriorityQueue<e> class
 Run time of stack, queue, and
prioritizzle queue operations
Think of a stack of plates or cafeteria trays. Da last one added ta tha stack is tha first
one removed: last up in first up (LIFO) fo' realz. And you can't remove tha second tray without
takin off tha top one!
A stack be a sequence of shit of tha same type, up in which shit can be added and
removed only at one end yo, but it ain't no stoppin cause I be still poppin'. In theory, there is no limit ta tha number of shit on the
stack.
Changes ta tha stack is controlled by two operations, push n' pop. To push an
item onto tha stack is ta add dat item ta tha top of tha stack. To pop tha stack is to
remove a item from tha top of tha stack. Imagine dat tha top of tha stack floats up
and down as shit is pushed onto or popped off tha stack. Push n' pop is ideally
O( 1) operations.
There is two other useful operations fo' a stack: a isEmpty test, which returns
true or false, n' peek, which inspects tha top element n' reports what tha fuck it is. If you
try ta peek at or pop a empty stack, you git a underflow error.
Da Stack<e> Class
Stacks is implemented wit tha Stack<e> class provided up in Java 5.0. Right back up in yo muthafuckin ass. Stack<e> be a
subclass of Vector<e>, which implements a array dat can grow n' shrink as needed.
CHAPTER 9
Use a stack for
last-in-first-out
applications, like
reviewin tha mo t
recent movez of a
game.
403
404 Chapta 9 Stacks n' Queues
THE Stack<e> CLASS METHODS
Here is tha subset of Stack methodz dat you should know fo' tha AP exam:
I StackO I
Constructor: creates a empty stack.
I boolean isEmpty() I
Returns legit if tha stack is empty, false otherwise. (There be a equivalent method
called empty dat aint gonna be used on tha AP exam.)
IE push(E item) I
Pushes item onto tha top of tha stack. Returns item.
IE popO I
Pops tha top element off tha stack. Returns dis element. Da method throws an
EmptyStackException if a attempt is made ta pop a empty stack.
IE peekO I
Returns tha top element of tha stack but leaves tha stack unchanged. Y'all KNOW dat shit, muthafucka! Think of it as a
method dat takes a peek all up in tha top element n' returns ta tell what tha fuck it saw. If, however,
it peeks n' tha stack is empty, a EmptyStackException is thrown.
Example
(Statements is numbered fo' reference.)
1 Stack<string> s = freshly smoked up Stack<string>(); Ilcreates empty stack
2 s.push("A"); Ilpushes "A" onto s
3 s.push("sunny"); Ilpushes "sunny" onto s
4 s.push("day"); I Ipushes "day" onto s
5 System.out.println( s.popO); Ilremoves "day" from stack
6 Pt II n' prints it
7 System. out. println ( s. pop 0) ; Ilremoves" sunny" from stack
8 Iland prints it
9 Strin str = s . peek 0 ; I I stores "A" up in str
10 I land leaves stack unchanged
11 if (s. isEmptyO)
12 System.out.println("Empty stack");
13 else
14 System.out.println("Stack not empty, " + str + " on top");
15 I loutputs "Stack not empty, A on top"
16 s = freshly smoked up Stack<string>(); Ilemptizzles s
17 if (s. isEmptyO)
18 System. out. println ("Empty stack"); I Ithis is output
19 else
20 System.out.println("Stack not empty, " + s.peekO + " on top");
Here is snapshotz of tha stack s.
Stacks
day
sunny sunny
A A A A
s s s s s s
afta 1 afta 4 afta 5 afta 7 afta 9 afta 16
When ta Use a Stack
Consider rockin a stack fo' any problem dat involves backtrackin Qast up in first out).
Some examplez include retracin steps up in a maze n' keepin track of nested structures,
such as
 Expressions within other expressions.
 Methodz dat call other methods.
 Traversin directories n' subdirectories.
In each case tha stack mechanizzle untanglez tha nested structure.
Example
Write a method validParens ta test if a Java expression has valid parentheses fo' realz. An
expression is valid if tha number of openers (i.e., left parentheses 11(11) equals tha number
of endaz (right parentheses ") "). For example, 3 / (a + (b * 2)) is valid yo, but
(x - (y * (z + 4) is invalid. Y'all KNOW dat shit, muthafucka! Note dat simply checkin if tha number of openers
equals tha number of endaz is insufficient: tha expression)3 + 4( aint valid. Y'all KNOW dat shit, muthafucka! To be
valid, each ender must be preceded by a matchin opener.
Assume dat tha expression be a Strin up in a Expression class. Da validParens
method returns legit if tha parentheses up in tha Expression is valid, false otherwise.
Herez where tha stack comes in. I aint talkin' bout chicken n' gravy biatch. Do a cold-ass lil character-by-characta processing. If any character
substrin be a opener, push it onto tha stack s. If itz a ender n' tha stack is
empty, tha expression is invalid since there is no matchin opener n' shit. If tha stack is not
empty, however, pop tha stack. When tha end of tha expression is reached, tha stack
should be empty if tha expression is valid.
Suppose dat tha expression ta be examined is (3 + 4 * (5 Y. 3) yo. Here is tha state
of tha stack at various stagez of tha processing:
(
(3+4*(
Notice dat tha given expression is valid.
Here is part of a Expression class dat gotz nuff tha validParens method.
405
406
Use a queue for
first-in-first-out
applications, like
. .
servmg hustlas m
a bank line.
Chapta 9 Stacks n' Queues
1* Tests tha validitizzle of a expression *1
hood class Expression
{
private Strin expr;
private final Strin OPENER = "(";
private final Strin ENDER = ")";
Ilconstructor
hood Expression()
{ 1* code ta read expr *1 }
IIReturns legit if parentheses valid , false otherwise .
hood boolean validParens()
{
Stack<string> s = freshly smoked up Stack<string>() ;
for (int i = 0; i &lt; expr . length(); i++)
{
}
Strin ch = expr.substring(i,i + 1);
if (ch .equals(OPENER»
s .push(ch);
else
if (ch.equals(ENDER»
if (s.isEmpty(» Iino matchin opener
return false;
else
s .pop() ; Ilpop matchin opener
return s.isEmpty(); Pt II if false , a fuckin shitload of openers
}
Ilother methodz not shown
}
.. . ., ~-.:.  ~ . : -:;; . . ', . . , ~ .- ! .
QUEUES
_ - ~ ..... , :'" lr'// ~' -~ ::;' :f; ..."'i")I;
What Is a Queue?
Think of a line of well-behaved playas waitin ta board a funky-ass bus. New arrivals git all up in the
back of tha line. Da first one up in line arrived first n' is tha straight-up original gangsta ta board tha bus: first
in first up (FIFO).
A queue be a sequence of shit of tha same type up in which shit is removed at one
end, tha front, n' freshly smoked up shit is added all up in tha other end, tha back. In theory, there is
no limit ta tha number of shit up in a queue.
Changes ta tha queue is controlled by operations add (sometimes called enqueue)
and remove (sometimes called dequeue). To add a item is ta add dat item ta tha back
of tha queue. To remove is ta remove a item from tha front of tha queue. If you try
to remove from or peek at a empty queue you git a underflow error fo' realz. As fo' a stack,
an isEmpty operation tests fo' a empty queue, n' a peek method reports whatz at
the front.
Queues
Da Queue<e> Interface
Da Java Collections Framework gotz nuff a queue intercourse, Queue<e>. This intercourse
is implemented wit tha LinkedList<e> class, which can be used fo' all tha standard
queue operations.
THE QUEUE METHODS
Here is tha AP Java subset of methodz dat you should know:
I boolean isEmpty() I
Returns legit if tha queue is empty, false otherwise.
I boolean add(E item) I
Inserts item all up in tha back of tha queue. Returns legit if item successfully added, false
otherwise.
IE removeO I
Removes a element from tha front of tha queue. Returns dis element. Da method
throws a NoSuchElementException if a attempt is made ta remove from a empty
queue.
IE peekO I
Returns tha front element of tha queue, leavin tha queue unchanged. Y'all KNOW dat shit, muthafucka! Da method
returns null if tha queue is empty. (Note dat dis method be analogous ta peekO
in tha Stack class. Da stack, however, throws a exception fo' peekin at a empty
stack.)
Queue Implementation
On tha AP exam, code like fuckin tha followin is ghon be used:
Queue<string> q = freshly smoked up LinkedList<string>();
//LinkedList implements Queue
Example
(Statements is numbered fo' reference.)
Queue<string> q = freshly smoked up LinkedList<string>(); //q is empty
2 Strin st = "ghijkl";
3 fo' (int i = 0; i &lt; st.length(); i++)
4 q.add(st.substring(i. i + 1»; //add "g". "h". "i".
5 //"j"  "k". "1"
6 System.out.println(q);
7 fo' (int i = 1; i &lt; 3;
//prints [g. h. i. j. k.
8 q.remove();
9 System.out.println(q);
10 q.add("r");
11 System.out.println(q);
12 Strin str = q.peek();
H+)
//remove "g". "h"
//prints [i. j. k. 1]
//prints [i. j. k. 1. r]
//str gotz nuff "i"
1]
407
408 Chapta 9 Stacks n' Queues
Da state of tha queue is shown below. Da labels f n' b underneath each figure
denote tha front n' back of tha queue.
q
Afta 1
q g h I i I j k 1
f b
Afta 4
q I i I j k 1
f b
Afta 8
q I i I j k 1 r
f b
Afta 10
When ta Use a Queue
Think of a queue fo' any problem dat involves processin data up in tha order up in which
it was entered. Y'all KNOW dat shit, muthafucka! Some examplez include
 Goin back ta tha beginnin n' retracin steps.
 Simulatin lines-cars waitin at a cold-ass lil hoopty wash, playas standin up in line at a funky-ass bank,
and so on.
Example
Here be a cold-ass lil code segment dat simulates tha redial feature of a telephone. Each digit
that is entered is treated as a separate element n' placed up in a queue. When it"s time
to redial, tha queue is emptied, n' tha digits is printed up in tha order dat they were
entered.
1* Simulate redial featurez of a phone. *1
final Strin PERIOD = ". ";
Queue<string> q - freshly smoked up LinkedList<string>();
System.out.println("Enta digitz of beeper number" +
II separated by spaces");
System.out.println("Terminizzle wit a space then a period. Y'all KNOW dat shit, muthafucka! Pt II);
Strin digit = IO.readString(); Ilread user input
while (ldigit.equals(PERIOD»
{
q.add(digit);
digit = IO.readString(); Ilread user input
}
System.out.println();
System.out.println("Da number dialed was: Pt II);
while (lq.isEmpty(»
{
System.out.print(q.remove(»;
}
Prioritizzle Queues
__________ ... w_JGa:':_~.M~._t ..
_PR_IO_R_.I._T Y_ Q_U. ..E.. U_E=S _. . ... Pt IIII _ aa~_.~;.rr""!,. ... .I~. : .. " . ; "
What Is a Prioritizzle Queue?
A prioritizzle queue be a cold-ass lil collection of shit of tha same type, each of which gotz nuff a
data field n' a priority. Items is ordered by priority, up in tha sense dat shit wit the
highest prioritizzle is removed first. Da head of a prioritizzle queue is tha least element
with respect ta its ordering. This means dat elements up in a prioritizzle queue must be
Comparable, wit tha smallest element havin tha highest prioritizzle fo' realz. A prioritizzle queue
does not allow insertion of null elements.
Da Priori tyQueue<e> Class
Prioritizzle queues is implemented wit tha PriorityQueue<e> class provided up in Java
5.0. Da Priori tyQueue<e> class is implemented wit a heap (see #5 up in Implementation
of a Prioritizzle Queue, below).
THE Priori tyQueue<e> CLASS METHODS
Here is tha subset of Priori tyQueue class methodz dat you should know.
'prioritYQueue() I
Constructor: Creates a prioritizzle queue wit default initial capacity.
'boolean isEmpty() I
Returns legit if tha prioritizzle queue is empty, false otherwise.
'boolean add(E item) I
Addz item ta tha prioritizzle queue n' returns true. Throws a NullPointerException
if item is null. Throws a ClassCastException if item cannot be compared ta shit in
the prioritizzle queue.
IE removeO I
Removes n' returns tha item all up in tha head of tha prioritizzle queue. This is tha least
element, tha one wit tha highest priority. If a attempt is made ta remove a item
from a empty prioritizzle queue, remove throws a NoSuchElementException.
IE peekO I
Returns yo, but do not remove, tha smallest item up in tha prioritizzle queue. Da method
returns null if tha prioritizzle queue is empty.
Implementation of a Prioritizzle Queue
Yo ass aint sposed ta fuckin be familiar wit tha black box code up in tha PriorityQueue class.
Yo ass should, however, KNOW tha followin general principlez bout implementing
a prioritizzle queue.
409
Use a prioritizzle queue
when removal of
item dependz only
on item priority, not
on order of insertion.
410 Chapta 9 Stacks n' Queues
Da data structure selected fo' a prioritizzle queue should allow for
 Rapid insertion of elements dat arrive up in arbitrary order.
 Rapid retrieval of tha element wit highest priority.
Some possible data structures fo' a prioritizzle queue follow:
1 fo' realz. A linear linked list wit elements up in random order n' shit. Insertion is done at the
front of tha list, O( 1). Deletion requires a linear search fo' tha element with
highest priority, O(n).
2 fo' realz. A linear linked list wit elements sorted by priority, smallest elements up in front.
Deletion means removal of tha straight-up original gangsta node, O( 1). Insertion requires a linear scan
to find tha insertion point, O(n).
3 fo' realz. An array wit elements up in random order n' shit. Insertion is done all up in tha end of the
list, O( 1). Deletion requires a linear search, O( n ).
4 fo' realz. An array wit elements sorted by priority, smallest elements all up in tha end yo, but it ain't no stoppin cause I be still poppin'. Deletion
means removin tha last element up in tha array, O( 1). Insertion requires
findin tha insertion point n' then bustin a slot by movin array elementsO(
n ) irrespectizzle of tha type of search.
5. Da funky-ass data structure fo' a prioritizzle queue: a funky-ass binary heap. (See Chapta 12
for a thugged-out description of a heap n' a array representation of a heap.) For a priority
queue, a minimum heap is used. Y'all KNOW dat shit, muthafucka! Da value up in every last muthafuckin node is less than or equal
to tha value up in each of its lil' thugs. For example,
Da numbers up in tha heap represent tha prioritizzlez of tha elements, n' you can put dat on yo' toast. (Da lower
the number, tha higher tha priority.) Notice dat tha element wit tha highest
prioritizzle is kept up in tha root of tha tree. Deletin a element means removing
the root element, then restorin tha heap ("reheaping"), which is O(log n).
Insertion of a element also requires reheaping, O(log n). To peek all up in tha least
element means ta report tha root value: O( 1).
When ta Use a Prioritizzle Queue
Think of rockin a prioritizzle queue up in any problem where elements enta up in a random
order but is removed accordin ta they priority. For example,
 A database of patients awaitin liver transplants, where tha sickest patients have
the highest priority.
 Schedulin events, n' you can put dat on yo' toast. Events is generated up in random order n' each event has
a time stamp denotin when tha event will occur. Shiiit, dis aint no joke. Da schedula retrieves the
events up in tha order they will occur.
Prioritizzle Queues
Example
Here be a program dat illustrates how tha fuck a prioritizzle queue may be used. Y'all KNOW dat shit, muthafucka! Imagine that
patients awaitin a organ transplant is placed on a list. When a organ becomes
available, tha patient wit tha highest prioritizzle is contacted.
hood class Patient implements Comparable
{
}
private Strin myName;
private int myPriority;
hood Patient(Strin name, int priority)
{
}
myName = name;
myPrioritizzle = priority;
hood int compareTo(Object 0)
{
}
Patient rhs = (Patient) 0;
if (myPrioritizzle &lt; rhs.myPriority)
return -1;
else if (myPrioritizzle &gt; rhs.myPriority)
return 1;
else
return 0;
hood Strin toString()
{
}
Strin s = myName + Pt II wit prioritizzle Pt II + myPriority;
return s;
/* Illustrates prioritizzle queue. */
hood class PriQueueTest
{
}
hood static void main(Strin args[])
{
}
PriorityQueue<patient> pq = freshly smoked up PriorityQueue<patient>();
Patient pi = freshly smoked up Patient("Jizzy Smizzle", 3);
Patient p2 = freshly smoked up Patient("Mary Jones", 1);
Patient p3 = freshly smoked up Patient("Kathy Gibb", 2);
pq.add(p1);
pq.add(p2);
pq.add(p3);
while (!pq.isEmpty(»
{
}
System.out.println("Da next patient fo' liver Pt II +
II transplant is Pt II);
System.out.println(pq.remove(»;
411
412
Da output fo' dis program is
Da next patient fo' liver transplant is
Mary Jones wit prioritizzle 1
Da next patient fo' liver transplant is
Kathy Gibb wit prioritizzle 2
Da next patient fo' liver transplant is
Jizzy Smizzle wit prioritizzle 3
Chapta 9 Stacks n' Queues
RUN TIME OF STACK, QUEUE, AND PRIORITY QUEUE
OPERATIONS
In each case, assume n elements n' tha followin implementations:
 Stack s: a array wit sufficient slots.
 Queue q: a thugged-out doubly linked list (DLL) wit reference at each end.
 Prioritizzle queue pq: a minimum heap.
Algorithm Stack
Insert
element
Remove
element
Peek
(Array)
push(x)
0(1)
popO
0(1)
peekO
0(1)
Queue
(OLL)
add (x)
0(1)
remove 0
0(1)
peekO
0(1)
Priority
Queue
(Min-heap)
add (x)
O(logn)
remove 0
O(logn)
peekO
0(1)
Comment
s: Insert at end of array.
q: Simple pointa adjustment at end
ofLL.
pq: Fix tha heap afta insertion .
.. s.:-Remove at ;;iid of array: .----.q:
Pointa adjustment at front of
LL.
pq: Remove root element of heap.
Fix heap~ .. ....... __ _. ___ ._
s: 0(1) access ta any array element:
top of stack = last element in
array.
q: 0(1) access ta first element in
LL, front of q.
pq: 0(1) access ta root node up in heap,
the least element.
Chapta Summary
Be familiar wit tha differences between stacks, queues, n' prioritizzle queues, and
the typez of applications fo' which each data structure is suitable.
Yo ass must also be able ta use tha standard Java classes Stack<e>, Queue<e>, and
PriorityQueue<e> ta implement stacks, queues, n' prioritizzle queues. Know how tha fuck to
call each method associated wit each data structure. Yo ass must also know tha big-O
run time fo' each of these methods.
Multiple-Choice Thangs on Stacks n' Queues
MULTIPLE-CHOICE QUESTIONS ON STACKS AND
QUEUES
Assume dat stacks is implemented wit tha Stack<e> class (p. 404), n' queues with
the Queue<e> intercourse n' LinkedList<e> class (p. 407).
1 fo' realz. A stack z of strings gotz nuff "Stan", "Nan", "Fran", "Jan", "Dan" up in tha order
given, wit "Stan" on top. What tha fuck iz ghon be output by tha followin code segment?
while (s.peek().length() Y. 2 == 0)
{
}
Strin str = s .. pop 0 ;
System.out.print(s.peek(»;
(A) Stan
(B) Nan
(C) Fran
(D) StanNan
(E) NanFran
2. What tha fuck iz tha output from tha followin code segment?
Stack<string> s = freshly smoked up Stack<string>();
Strin str = "cat";
for (int i = 0; i &lt; str.length(); i++)
s.push(str.substring(i»;
while (!s.isEmpty(»
System.out.print(s.pop(»;
(A) catatt
(B) tac
(C) ttatac
(D) tat cat
(E) cattat
413
414 Chapta 9 Stacks n' Queues
3 fo' realz. Assume these declarations:
Queue<someclass> q = freshly smoked up LinkedList<someclass>();
//LinkedList implements Queue
SomeClass obj;
If q is initialized, which of tha followin code segments will erectly access the
elementz of q n' leave q unchanged, biatch? Yo ass may assume dat tha access method
does not chizzle tha SomeClass objects.
I Queue<someclass> temp = freshly smoked up LinkedList<someclass>();
while (!q.isEmpty(»
{
}
obj = q.remove();
obj .accessO;
temp.add(obj);
q = temp;
II while (!q. isEmptyO)
{
}
obj = q.remove();
obj . access 0 ;
q.add(obj);
III Queue<someclass> temp = q;
while (!temp.isEmpty(»
{
}
obj = temp.remove();
obj . access 0 ;
(A) I only
(B) Pt II only
(C) Pt III only
(0) I n' Pt III only
(E) Pt II n' Pt III only
Multiple-Choice Thangs on Stacks n' Queues
4. Consider tha followin sequence of statements:
Queue<string> q = freshly smoked up LinkedList<string>();
//LinkedList implements Queue
Strin str1 = "ab", str2 = "cd", str3 = "ef";
q.add(str1);
q.add(str2);
q.add(str3);
str1 = str3.substring(O, 1);
str2 = q.remove();
q.add(str1);
q.add(str2);
str2 = str1;
q.add(str2);
while (!q.isEmpty(»
System.out.print(q.remove(»;
What output is ghon be produced?
(A) abcdeefe
(n) abcdefefabef
(C) abcdefeabe
(D) cdefeabe
(E) cdefefabef
5. Right back up in yo muthafuckin ass. Suppose dat a queue q gotz nuff tha Integer joints 1, 2, 3, 4, 5, 6 up in dat order,
with 1 all up in tha front of q. Right back up in yo muthafuckin ass. Suppose dat there be just three operations dat can be
performed rockin only one stack, s.
(i) Remove x from q then print x.
(ii) Remove x from q then push x onto s.
(iii) Pop x from s then print x.
Which of tha followin aint a possible output list rockin just these operations?
(A) 123456
(B) 654321
(C) 234561
(D) 125643
(E) 345612
415
416 Chapta 9 Stacks n' Queues
6. Let intStack be a stack of Integer joints n' opStack be a cold-ass lil characta stack of
arithmetic operators, where each operator be a single-characta Strin fo' realz. A method
doOperationO exists that
(i) Pops two joints from intStack.
(ii) Pops a operator from opStack.
(iii) Performs tha operation.
(iv) Pushes tha result onto intStack.
Assume dat tha Integer joints 5, 8, 3, n' 2 is pushed onto intStack up in that
order (2 pushed last), n' ".", "-", n' "+" is pushed onto opStack up in dat order
("+" pushed last). Da doOperationO m~thod is invoked three times. Da top of
intStack gotz nuff tha result of evaluatin which expression?
(A) «2*3)-8)+5
(B) «2+3)-5)*8
(C) «2+3) - 8) *5
(D) «5*8)-3)+2
(E) «5+8)-3)*2
7. Right back up in yo muthafuckin ass. Suppose dat s n' t is both stackz of type T n' dat x be a variable of type
T fo' realz. Assume dat s initially gotz nuff n elements, where n is large, n' dat t is
initially empty fo' realz. Assume further dat length(s) gives tha number of elements in
s. Which is legit afta execution of tha followin code segment?
int len = length(s) - 2;
for (int i = 1; i &lt;= len; i++)
{
}
x = s.popO;
t.push(x);
len = length(s) - 2;
for (int i = 1; i &lt;= len; i++)
{
}
x = t.popO;
s.push(x);
(A) s is unchanged, n' x equals tha third item from tha bottom of s.
(B) s is unchanged, n' x equals s . peek () .
(C) s gotz nuff two elements, n' x equals s. peek () .
(D) s gotz nuff two elements, n' x equals tha bottom element of s.
(E) s gotz nuff two elements, n' x equals t . peek () .
Multiple-Choice Thangs on Stacks n' Queues
8. Refer ta tha followin program segment:
Queue<integer> q = freshly smoked up LinkedList<integer>();
//LinkedList implements Queue
Integer x;
for (int i = 1; i &lt; 6; i++)
q.add(new Integer(i * i»;
while (!q.isEmpty(»
{
}
if (q.peek().intValue() % 2 == 0)
{
}
else
{
}
System.out.print(q.peekO + Pt II Pt II);
x = q. remove 0 ;
x = q.removeO;
q.add(x)j
Which is ghon be legit afta dis segment is executed?
(A) 4 16 has been printed, n' tha queue gotz nuff 1 9 25, wit 1 all up in tha front
and 25 all up in tha back.
(B) 16 4 has been printed, n' tha queue gotz nuff 1 9 25, wit 1 all up in tha front
and 25 all up in tha back.
(C) 1 4 9 16 25 has been printed, n' tha queue is empty.
(D) 4 16 has been printed, n' tha segment continues ta run without termination.
(E) 4 16 4 16 4 16 ... has been printed, n' tha segment continues ta run
without termination.
417
418 Chapta 9 Stacks n' Queues
9. Consider a stack s n' queue q of integers. What must be legit followin execution
of dis code segment?
q = freshly smoked up LinkedList<integer>();
s = freshly smoked up Stack<integer>();
Integer x;
for (int i = 1; i &lt;= 4; i++)
s.push(new Integer(i»;
for (int i = 1; i &lt;= 4; i++)
{
}
x = s.popO;
if (x.intValue() % 2 == 0)
q.add(x);
else
{
}
x = q.removeO;
s.push(x);
(A) 2 be all up in tha back of q.
(B) s.peekO is 2.
(C) s is empty.
(D) q is empty.
(E) An error has occurred.
Consider tha followin code segment fo' Thangs 10 n' 11.
Stack<string> s = freshly smoked up Stack<string>();
Strin str = "racketeer";
for (int i = 0; i &lt; str.length(); i++)
s.push(str.substring(i, i + 1»;
for (int i = 0; i &lt; str.length(); i++)
{
}
Strin ch = str.substring(i, i + 1);
if (isVowel(ch». / /test if ch be a lowercase vowel,
{
System.out.print(s.pop(»;
}
else
s.push(ch);
10. What output is ghon be produced by tha segment?
(A) aeee
(B) eeea
(C) ctkr
(D) rktc
(E) rkct
Multiple-Choice Thangs on Stacks n' Queues
11. Right back up in yo muthafuckin ass. Suppose tha segment is modified ta omit tha straight-up original gangsta fo' loop, up in which tha lettas of
str is pushed onto stack s fo' realz. Additionally, strang str be assigned ta he a random
strin of lowercase letters. Under which circumstances will tha code cause an
EmptyStackException?
I Whenever str starts wit a cold-ass lil consonant.
II Whenever str starts wit a vowel.
m Whenever tha number of vowels up in str exceedz tha number of consonants.
(A) Ionly
(B) Pt II only
(C) monly
(0) Pt II n' m only
(E) I, Pt II, n' m
12. Methodz add(s) n' multiply(s) do tha followin ta a stack s when invoked:
Da stack is popped twice.
Da two popped shit is added or multiplied accordingly.
Da Integer result is pushed onto tha stack.
What will stack s contain followin execution of tha followin code segment?
int x = 3, Y = 5, Z = 7, w = 9;
s.push(new Integer(x»;
s.push(new Integer(y»;
add(s);
s.push(new Integer(w»;
s.push(new Integer(z»;
multiply(s);
add(s);
(A) Nothing
(B) 31
(C) 71
(0) 78
(E) 128
419
420 Chapta 9 Stacks n' Queues
13 fo' realz. Assume that
 Linked lists is implemented wit tha ListNode class (p. 364).
 Stack s n' queue q is initially empty n' done been declared ta hold objects
of tha same type as tha linked list.
 Objects up in tha linked list gotz a toStrin method.
Refer ta tha followin method, reverse:
1* Precondition: first refers ta tha straight-up original gangsta node of a linear
* linked list.
* Postcondition: List elements printed up in reverse order n' shit. *1
hood void reverse(ListNode first)
{
1* code *1
}
Which 1* code *1 will successfully big up tha postcondizzle of reverse?
I if (first != null)
{
II
III
(A)
(B)
(C)
(D)
(E)
System. out. print (first. getValue 0 + lin);
reverse(first.getNext(»;
}
while (first != null)
{
s.push(first.getValue(»;
first = first.getNext();
}
while (!s.isEmpty(»
System.out.print(s.pop() + Pt II Pt II);
while (first != null)
{
q.add(first.getValue(»;
first = first.getNext();
}
while (!q.isEmpty(»
System.out.print(q.remove() + .. Pt II);
I only
II only
III only
I n' Pt II only
I n' Pt III only
Multiple-Choice Thangs on Stacks n' Queues
14. Right back up in yo muthafuckin ass. Suppose tha Stack class added another pop method, one dat chizzlez tha stack
but do not return tha object thatz bein removed:
hood void pop(E item) Ilremove top item without savin it
This be a example of
(A) polymorphism.
(B) method overriding.
(C) method overloading.
(D) a helper method.
(E) a NoSuchElementException.
15. Right back up in yo muthafuckin ass. Suppose stacks is implemented wit a linear linked list dat has just one private
instizzle variable, firstNode, which refers ta tha straight-up original gangsta element of tha list:
firstNode
D  L---I ...J........'III
In tha diagram, f irstNode points ta tha top of tha stack. Which of tha followi,ng
correctly gives tha run time of (1) push n' (2) pop up in dis implementation?
(A) (1) 0(1) (2) 0(1)
(B) (1) 0(1) (2) O(n)
(C) (1) O(n) (2) 0(1)
(D) (1) O(n) (2) O(n)
(E) (1) O(logn) (2) 0(1)
16. Which of tha followin is legit of a prioritizzle queue?
(A) If elements is banged up in increasin order of prioritizzle (i.e., lowest priority
element banged first), n' all elements is banged before any is removed,
it works like a queue.
(B) If elements is banged up in increasin order of prioritizzle (i.e., lowest priority
element banged first), n' all elements is banged before any is removed,
it works like a stack.
(C) If all elements is banged before any is removed, it works like a queue.
(D) If elements is banged up in decreasin order of prioritizzle (i.e., highest priority
element banged first), n' all elements is banged before any is removed,
it works like a stack.
(E) If elements is banged up in increasin order of priority, then it works like a
queue whether or not all insertions precede any removals.
421
422 Chapta 9 Stacks n' Queues
Thangs 17-19 refer ta tha followin intercourse n' class definition. I aint talkin' bout chicken n' gravy biatch. Yo ass may assume
that type T is Comparable.
hood intercourse Container<t>
{
}
void insert(T x)j
T remove()j
//insert x tha fuck into Container
//remove item from Container
hood class C<t> implements Container<t>
{
hood CO //constructor
{ '"
hood void insert(T x) //insert x tha fuck into C
{ ...
hood T remove() //remove item from C
{ ...
//appropriate private instizzle variablez ta implement C
}
Here be a program segment dat uses class C above:
Container<string> lyrics = freshly smoked up C<string>()j
Strin w1 = "Tom"j
Strin w2 = "Dick";
Strin w3 = "Harry";
Strin w4 = "Moe"j
words.insert(wl)j
words.insert(w2)j
words.insert(w3)j
words.insert(w4)j
Strin str = lyrics.remove();
str = lyrics.remove();
System.out.println(str);
17. What will tha output be if C be a stack?
(A) Tom
(B) Dick
(C) Harry
(0) Moe
(E) There is insufficient shiznit ta determine tha output.
18. What will tha output be if C be a queue?
(A) Tom
(B) Dick
(C) Harry
(0) Moe
(E) There is insufficient shiznit ta determine tha output.
Multiple-Choice Thangs on Stacks n' Queues
19. What will tha output be if C be a prioritizzle queue, biatch? Yo ass may assume dat priorities
are assigned rockin tha fact dat shit is Comparable.
(A) Tom
(B) Dick
(C) Harry
(D) Moe
(E) There is insufficient shiznit ta determine tha output.
20. In tha package java.util, tha Stack<e> class extendz Javaz Vector<e> class.
Thus, Stack inherits all tha methodz of Vector yo. Here is three of tha methods
that Stack inherits:
I void add(int i, E x) //insert x tha fuck into stack at index i
II E get(int i) //return element at index i
//leave stack unchanged
III E remove(int i) //remove element at index i from stack
Which of these methodz is not consistent wit tha definizzle of a stack?
(A) I only
(B) Pt II only
(C) Pt III only
(D) Pt II n' Pt III only
(E) I, Pt II, n' Pt III
21. Refer ta tha followin declaration:
PriorityQueue<integer> pq = freshly smoked up PriorityQueue<integer>();
Da elementz of tha prioritizzle queue pq is ghon be Integer joints, n' you can put dat on yo' toast. These joints will
also represent tha prioritizzlez of tha items: smallest value = highest prioritizzle fo' realz. Assuming
that tha code works as intended, what tha fuck output is ghon be produced by the
followin segment?
pq.add(new Integer(4));
pq.add(new Integer(l));
pq.add(new Integer(3));
pq.add(new Integer(2));
pq.add(new Integer(5));
while (!pq.isEmpty())
System.out.print(pq.remove());
(A) 54321
(B) 41325
(C) 12345
(D) 52314
(E) 11111
423
424 Chapta 9 Stacks n' Queues
22. Consider tha followin client method fo' tha Stack class:
/* Precondition: Stack s is defined.
* Postcondition: Returns tha bottom element of s.
* s,remains unchanged. Y'all KNOW dat shit, muthafucka! */
hood ItemType bottom(Stack<itemtype> s)
{
}
Which replacements fo' /* code */ will big up tha required postcondition?
I ItemType item;
while (ls.isEmpty())
item = s.popO;
return item;
II ItemType item;
Stack<itemtype> t = S;
while (It.isEmpty())
item = t.popO;
return item;
m ItemType item;
Stack<itemtype> t = freshly smoked up Stack<itemtype>();
while (ls.isEmpty())
t.push(s.pop());
item = t.peek();
while (It.isEmpty())
s.push(t.pop());
return item;
(A) I only
(B) Pt II only
(C) monly
(D) I n' Pt II only
(E) I n' m only
Multiple-Choice Thangs on Stacks n' Queues
23. Consider tha followin programmin assignments:
I Maintain a waitin list fo' reservations at a hotel. Rooms is assigned on a
first-come, first-served basis.
II Maintain a list of violin playas whoz ass auditioned fo' a major orchestra. The
players was ranked durin they auditions, n' tha top-ranked playa will
get offered any thang dat opens up.
ill Attempt ta find a escape route fo' a mouse up in a maze. Da mouse should
be able ta retrace its steps while attemptin ta escape.
IV Store tha moves up in a cold-ass lil chess game. Da program should allow a user ta view
the game lata on.
In applications I n' Pt II, tha programmer must select a suitable data structure for
storin tha namez of people. For ill n' IV, moves must be stored. Y'all KNOW dat shit, muthafucka! Select tha best
choice of data structures fo' each application.
(A) I prioritizzle queue Pt II prioritizzle queue Pt III array IV queue
(B) I prioritizzle queue Pt II prioritizzle queue ill prioritizzle queue IV stack
(C) I queue Pt II prioritizzle queue Pt III stack
(0) I stack . Pt II queue ill queue
(E) I queue Pt II queue ill stack
IV queue
IV stack
IV prioritizzle queue
425
426 Chapta 9 Stacks n' Queues
ANSWER KEY
loB 9 fo' realz. A 17. C
2. D 10. D 18.B
3 fo' realz. A 11. D 19. C
4. D 12. C 20. E
5. E 13. B 21. C
6. C 14. C 22. C
7. E 15 fo' realz. A 23. C
8. D 16. B
ANSWERS EXPLAINED
1. (B) When "Stan" is s.peekO, it passes tha while test (havin a even number
of characters) n' gets popped. Y'all KNOW dat shit, muthafucka! Da current s.peekO is then "Nan", which gets
printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Now tha test fails on "Nan", n' tha while loop aint executed again.
2. (0) Here is tha stack afta tha fo' loop has been executed:
t
at
cat
(Recall dat str. Shiiit, dis aint no joke. substrin (i) returns tha substrin of str startin all up in tha ith
posizzle of str n' extendin ta tha end of tha string.) Da while loop pops and
prints "t", then "at", then "cat", resultin up in "tatcat".
3. (A) Placin tha elements up in a temporary queue works cuz tha elements will
have tha same order as up in tha original gangsta queue. Right back up in yo muthafuckin ass. Segment Pt II seems ta git a gangbangin' fine
idea-take a element outta q, access it, n' then bang it back. Trouble is, the
while loop is ghon be infinite since q aint NEVER gonna be empty dawwwwg! Segment ill fails cuz
temp aint a separate queue: It refers ta tha same queue as q fo' realz. Any chizzlez made
to temp will therefore chizzle q.
4. (0) Here is tha state of tha queue just before it is emptied:
cd ef
f b
Da queue be a gangbangin' first-in-first-out structure, which means dat elements is removed
in tha order they was inserted, from front ta back as shown.
Answers Explained
5. (E) For 3456 ta done been printed means dat 1 n' 2 was removed n' pushed
onto s up in dat order n' shit. Da order of printin would then gotta be 21, not 12.
Note dat dis means dat 345621 would done been OK.
6. (C) Da first call ta doOperationO pops 2 n' 3, pops +, n' pushes 5, tha result.
Da second call pops 5 n' 8, pops -, n' pushes -3. Da third call pops -3 and
5, pops *, n' pushes -15. Da expression up in C is tha only chizzle dat evaluates
to -15.
Alternatively, work from tha inside out:
pop 2, 3, n' + - (2+3)
pop (2+3),8,and- - «2+3)-8)
pop «2+3)- 8),5, n' * - «2+3)-8)*5)
7. (E) Da first fo' loop removes tha top length(s) - 2 elements from s, leaving
two elements, n' you can put dat on yo' toast. Therefore, length(s) equals 2 fo' realz. Also, x currently equals tha top
element of t, t . peek (). Da second fo' loop is fo' i equals 1 ta 0, so not a god damn thang is
done up in dis loop! This leaves s wit two elements, n' x equal ta t . peek () .
8. (0) Here is q initially:
1 4 9 16 25
f b
1 fails tha test, is removed from tha front, n' is banged all up in tha back of tha queue.
4 passes tha test n' is printed n' removed.
9 fails n' is removed n' banged all up in tha back.
16 passes n' is printed n' removed.
25 fails n' is removed n' banged all up in tha back.
q now be lookin like this:
1 9 25
f b
None of tha elements up in tha queue will now pass tha if test, which means that
there is ghon be a infinite sequence of removals n' insertions up in q. Da while loop
never terminates.
9. (A) Initially s gotz nuff 1,2,3,4 wit 4 on top yo. Here is tha state of sand q after
each pass all up in tha second fo' loop:
3
2
1
q
s
Afta 1st pass
427
428 Chapta 9 Stacks n' Queues
4
2 q I I I'
1
s
Mta 2nd pass
2
1
q
s
Mta 3rd pass
1
q
s f b
Mta 4th pass
10. (0) Initially, each letta up in "racketeer" is pushed onto tha stack (first fo' loop).
Herez what tha fuck happens fo' each letta of tha word (second fo' loop):
r: r pushed onto stack
a: stack popped n' r printed
c: c pushed onto stack
k: k pushed onto stack
e: stack popped n' k printed
t: t pushed onto stack
e: stack popped n' t printed
e: stack popped n' c printed
r: r pushed onto stack
11. (D) Notice dat every last muthafuckin time a vowel is encountered, tha stack is popped. Y'all KNOW dat shit, muthafucka! Therefore,
if tha stack is initially empty, condizzle Pt II'ma cause a immediate failure.
Condizzle m will cause a eventual failure, when all consonants have been
popped n' another vowel is encountered. Y'all KNOW dat shit, muthafucka! Notice dat condizzle I'ma not cause
a failure provided there be a a cold-ass lil consonant on tha stack every last muthafuckin time a vowel is reached
in str. Shiiit, dis aint no joke. Thus, "lap" will work yo, but "leap" will not.
12. (e) Afta tha straight-up original gangsta call ta add(s), tha stack will contain 8 fo' realz. Afta tha call to
multiply(s), it will contain 63 (on top), then 8. Therefore, afta tha second
add(s), it will contain'71.
13. (8) Remember dat a stack be a last-in-first-out structure, which means dat eleAnswers
Explained
ments placed up in it is retrieved up in reverse order n' shit. Right back up in yo muthafuckin ass. So segment Pt II is erect fo' realz. A queue
is a gangbangin' first-in-first-out structure, so tha elements is ghon be printed up in tha order they
were received. Y'all KNOW dat shit, muthafucka! Thus, segment ill is wrong. Right back up in yo muthafuckin ass. Segment I would be erect if the
print n' reverse statements was interchanged. Y'all KNOW dat shit, muthafucka! As it is, a element is printed
before tha recursive call, which means dat elements is ghon be printed up in the
given order rather than bein reversed.
14. (C) Two (or more) formz of tha same method up in a given class be a example of
method overloading. Da compila distinguishes tha methodz by matchin parameter
types. Note dat tha item parameta is necessary; otherwise, tha two pop
methodz would have tha same signature, n' tha compila could not distinguish
them. Da return type aint part of tha signature.
15. (A) Simple pointa adjustments independent of tha number of nodes achieve
both push n' pop, makin dem both O( 1):
lI1
lI1
16. (B) If elements is banged up in increasin order of priority, tha last one up in will
have top prioritizzle n' is ghon be tha straight-up original gangsta one out, n' so on. I aint talkin' bout chicken n' gravy biatch. Thus, tha priority
queue will work just like a stack. Chizzle C would be erect only if tha elements
were banged up in decreasin order of priority, since tha straight-up original gangsta one up in would then
be tha straight-up original gangsta one out. Chizzle D is wack cuz tha straight-up original gangsta element entered (top
priority) would gotta be tha straight-up original gangsta one out-not a stack! Chizzlez A n' E are
both wack cuz higher prioritizzle elements would land all up in tha back of tha queue.
Removin these ,¥ould violate tha first-in-first-out property of a queue.
17. (C) Here is tha stack:
Moe
Harry
Dick
Tom
afta 4 inserts
Harry
Dick
Tom
str=Moe
afta first remove
Dick
Tom
str=Harry
afta second remove
429
430 Chapta 9 Stacks n' Queues
18. (B) Here is tha queue:
I Tomothy I Dick I Harry I Moe I
f b
afta 4 inserts
str = Tom
I Dick I Harry I Moe I
f b
afta first remove
str = Dick
f b
afta second remove
19. (C) For type String, tha orderin of prioritizzles be alphabeticaL Thus, tha first
remove call removes "Dick", n' tha second removes "Harry", which is then
printed.
20. (E) None of these methodz is valid stack operations muthafucka! Method I violates the
principle dat a value should be added ta a stack only by pushin it onto tha top.
Methodz Pt II n' Pt III violate tha principle dat only tha top element be accessible for
peekin n' removal.
21. (C) Da smalla tha integer, tha higher tha priority. Elements is deleted from a
prioritizzle queue accordin ta they prioritizzle number, highest prioritizzle Qowest value)
first. This is independent of tha order of tha insertion.
22. (C) Suppose tha original gangsta stack be lookin like this:
c
b
a
s
Yo ass will need a temporary stack ta access tha bottom element yo. Here is stacks s
and t afta tha straight-up original gangsta while loop up in segment Pt III:
Answers Explained
a
b
c
s t
Notice dat tha required item, a, is now all up in tha top of t. Da second while loop
restores s ta its original gangsta state.
Segment I returns tha erect item yo, but leaves s wit no elements, n' you can put dat on yo' toast. Even though
s is passed by value n' tha reference s remains unchanged, dis don't protect
the contentz of s. Right back up in yo muthafuckin ass. Segment Pt II also returns tha erect element but leaves s wit no
elements fo' realz. Assignin t ta s means dat any chizzlez made ta t will also be made
to s.
23. (C) Application I: "First-come, first-served" be a cold-ass lil funky-ass queue thang. Da first
name up in tha queue is tha straight-up original gangsta one out.
Application Pt II: Players is ranked, n' is ghon be removed from tha list according
to they rankin or priority. They should therefore be stored up in a prioritizzle queue.
Application Pt III: "Retracin steps" is dat phrase dat  drops some lyrics ta you ta store tha moves
in a stack. Da last move up in is ghon be first move out.
Application IV: To replay a game means ta retrieve tha moves up in tha order in
which they was stored-a funky-ass queue.
431
Trees
432
LEVEL AB ONLY
CHAPTER
~...2 ____ 
TREE: A tall vegetable ...
-Ambrose Bierce, Da Devilz Doggtionary (1911)
 Binary trees
 Da TreeNode class
 Binary search trees
 Tree traversals
Chapta Goals
 Recursive tree algorithms
 Binary expression trees
 Run time of binary search tree
algorithms
~,: n arrays n' matrices, there be a cold-ass lil certain equalitizzle ta tha elements, wit easy as fuck  and
.\ speedy access ta any given element fo' realz. A tree, on tha other hand, be a hierarchy up in the
way it represents data, wit some elements "higher" n' easier ta access than others.
A tree be also a structure dat allows branching.
BINARY TREES
Definitions
A binary tree be a gangbangin' finite set of elements dat is either empty or gotz nuff a single element
called tha root, n' whose remainin elements is partitioned tha fuck into two disjoint subsets.
Each subset is itself a funky-ass binary tree, called tha left or right subtree of tha original gangsta tree.
Binary trees is often represented schematically as shown below.
Here is some vocabulary you should know:
 A is tha root of tha tree. Band C is tha roots
of tha left n' right subtreez of A, n' so on
down tha tree.
 Each element be a node of tha tree. Da tree
shown has nine nodes.
 Any node whose left n' right subtrees are
empty is called a leaf Thus D, G, H, n' I
are leaves.
Binary Trees
 Note tha followin crew relationshizzlez among nodes fo' realz. A is tha parent of Band
C. Band C is tha lil pimpz of A, called tha left n' right child, respectively. C
has no left child, just a right child, F fo' realz. A leaf be a node wit no lil' thugs.
 Any node dat occurs up in a subtree of node k be a thugged-out descendant of k. Thus, every
node except A be a thugged-out descendant of A. Node I be a thugged-out descendant of C but not of B.
 If node k be a thugged-out descendant of node j, then j be a ancestor of node k. Thus, B be an
ancestor of D, E, n' G yo, but not of F, H, n' I.
 Da depth of a node is tha length of tha path (or number of edges) from tha root
to dat node. Thus, tha depth of A is 0, of B is 1, n' of H n' I is 3.
 Da level of a node is equal ta its depth. Thus, nodes D, E, n' F is all at level
2. Da level of a tree is equal ta tha level of its deepest leaf. Thus, tha level of the
tree shown is 3.
 Da height of a tree is tha maximum distizzle of any leaf from tha root. The
height is defined ta be 0 fo' a single node tree. Da height of tha tree shown on
the previous page is 3.
 A balanced tree has approximately tha same number of nodes up in tha left n' right
subtrees at each level. Da tree on tha previous page is balanced.
 A slick binary tree has every last muthafuckin leaf on tha same level; and
every nonleaf node has two lil' thugs.
 A complete binary tree is either slick or slick through
the next-to-Iast level, wit tha leaves as far left as possible up in tha last level.
but not
NOTE
Textbooks vary up in they definitionz of tree features fo' realz. Any question on tha AP exam that
requires you ta use a attribute of a tree will provide tha definition.
Implementation of Binary Trees
A binary tree can be implemented up in Java rockin a TreeNode class fo' tha nodes n' a
BinaryTree class fo' tha tree.
Da TreeNode Class
A TreeNode class similar ta tha followin is ghon be provided on tha AP exam.!
/* TreeNode class fo' tha AP exam */
hood class TreeNode
{
private Object value;
private TreeNode left, right;
IBased on tha College Boardz AP Computa Science AB: Implementation Classes fo' Linked Lists and
Tree Nodes.
433
434
hood TreeNode(Object initValue)
{
}
value = initValue;
left = null;
right = null;
Chapta 10 Trees
hood TreeNode(Object initValue, TreeNode initLeft,
TreeNode initRight)
}
{
}
value - initValue;
left = initLeft;
right = initRight;
hood Object getValue()
{ return value; }
hood TreeNode getLeft()
{ return left; }
hood TreeNode getRight()
{ return right; }
hood void setValue(Object theNewValue)
{ value = theNewValue; }
hood void setLeft(TreeNode theNewLeft)
{ left = theNewLeft; }
hood void setRight(TreeNode theNewRight)
{ right = theNewRight; }
THE INSTANCE VARIABLES
I private Object value I
This is exactly like tha data field of a ListNode. Primitizzle types like int or double will
first be auto-boxed.
I private TreeNode left, right I
Like tha ListNode class, tha TreeNode class is self-referential. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da variablez left and
right fo' any given TreeNode is pointas ta tha left n' right subtreez of dat node.
THE METHODS
hood TreeNode(Object initVa1ue)
hood TreeNode(Object initVa1ue. TreeNode initLeft.
TreeNode initRight)
These constructors initialize value ta initValue. Da variablez left n' right are
initialized ta null up in tha straight-up original gangsta constructor n' ta ini tLeft n' ini tRight up in tha second.
Binary Trees
I hood Object getValue() I
This be a accessor method dat returns tha value of tha current TreeNode. Yo ass may
need ta cast dis value ta Integer, Double, or String, n' so on, unless you plan to
assign it ta a variable of type Object.
hood TreeNode getLeft()
hood TreeNode getRight()
These is accessor methodz dat return left or right, tha left or right pointa of the
current TreeNode.
hood void setValue(Object theNewValue)
This be a mutator method dat chizzlez tha current value of TreeNode ta theNewValue.
hood void setLeft(TreeNode theNewLeft)
hood void setRight(TreeNode theNewRight)
These is mutator methodz dat chizzle tha left or right field of tha current TreeNode
to theNewLeft or theNewRight.
A BinaryTree Class
To represent a funky-ass binary tree, it make sense ta have a abstract class, since searchin and
insertion methodz depend on tha type of binary tree. Notice dat these methodz are
declared abstract up in tha BinaryTree class below fo' realz. A BinarySearchTree class, which is
derived from BinaryTree, is shown on tha next page. Implementations fo' bang and
find is provided up in dat class.
Here is tha abstract superclass, BinaryTree.
hood abstract class BinaryTree
{
}
private TreeNode root;
hood BinaryTree()
{ root = null; }
hood TreeNode getRoot()
{ return root; }
hood void setRoot(TreeNode theNewNode)
{ root = theNewNode; }
hood boolean isEmpty()
{ return root == null; }
hood abstract void insert(Comparable item);
hood abstract TreeNode find(Comparable key);
435
436 Chapta 10 Tr'ees
NOTE
1 fo' realz. A binary tree class aint gonna be provided on tha AP exam yo, but yo ass is expected
to know how tha fuck ta implement binary trees.
2. Da class shown here aint generic (has no type parameter).
jl_.
BINARY SEARCH TREES - A binary search tree be a funky-ass binary tree dat stores elements up in a ordered way dat makes
it efficient ta find a given element n' easy as fuck  ta access tha elements up in sorted order n' shit. The
orderin property is conventional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da followin definizzle of a funky-ass binary search tree
gives tha orderin property used most often.
A binary search tree is either empty or has just one node, tha root, wit left and
right subtrees dat is binary search trees. Each node has tha property dat all nodes
in its left subtree is less than it, n' all nodes up in its right subtree is pimped outa than or
equal ta dat shit. This be a funky-ass binary search tree dat allows duplicates. Right back up in yo muthafuckin ass. Some do not.
Here be a example:
A BinarySearchTree Class
Da class shown below be a subclass of tha abstract BinaryTree class given on tha preVIOUS
page.
hood class BinarySearchTree extendz BinaryTree
{
}
II Insert item up in BinarySearchTree.
hood void insert(Comparable item)
{ 1* implementation code on tha next page *1 }
IIReturns TreeNode wit key.
IIIf key not up in tree, returns null.
hood TreeNode find(Comparable key)
{ 1* implementation code on p. 439 *1 }
NOTE
1. Only tha abstract methodz of tha BinaryTree class, bang n' find, is provided
in tha BinarySearchTree class fo' realz. All tha other methodz of BinaryTree,
namely getRoot, setRoot, n' isEmpty, is inherited.
Binary Search Trees
2. No constructor is provided up in BinarySearchTree, which means dat tha compiler
will provide tha default constructor of tha BinaryTree superclass:
hood BinarySearchTree()
{ super(); } //initializes root ta null.
3. Da getRoot n' setRoot methodz up in BinarySearchTree is used ta access the
private instizzle variable root of tha superclass.
4. Da parametaz of both bang n' find need ta be Comparable, since the
methodz require you ta compare objects.
Insertin a Element tha fuck into a Binary Search Tree
INSERTION ALGORITHM
Suppose dat you wish ta bang tha element 9 tha fuck into tha precedin tree. Right back up in yo muthafuckin ass. Start by comparing
with tha root:
9 &gt; 5, go right
9 &gt; 8, go right
9 &gt; 8, go right
9 &lt; 10, bang ta left of 10
Here is tha resultin binary search tree.
An algorithm fo' insertin a element uses two TreeNode pointers, p n' q, say, following
each other ta find tha insertion point. Da "front" pointa q is like a kamikaze
pilot plungin downward until it is null, at which point p points ta tha node at which
the freshly smoked up data is ghon be attached. Y'all KNOW dat shit, muthafucka! A simple comparison  drops some lyrics ta whether tha freshly smoked up node goes
left or right.
THE bang METHOD
Here is tha bang method fo' tha BinarySearchTree.class:
//Insert item up in BinarySearchTree.
hood void insert(Comparable item)
{
if (getRoot() == null)
setRoot(new TreeNode(item»;
437
438
A balanced binary
search tree leadz to
efficient algorithms
for insertion and
searching.
else
{
}
}
TreeNode p = null, q = getRoot();
while (q != null)
{
}
p = q;
if (item.compareTo(p.getValue()) &lt; 0)
q = p.getLeft();
else
q = p.getRight();
if (item . compareTo(p.getValue()) &lt; 0)
p.setLeft(new TreeNode(item));
else
p.setRight(new TreeNode(item));
RUN-TIME ANALYSIS
Chapta 10 Trees
To bang a single element up in a existin binary search tree of n elements:
1. Balanced tree: Insertion will require at most one comparison per level (i.e., no
more than log2 n comparisons). Thus, tha algorithm is O(log n).
2. Unbalanced tree: As nuff as n comparisons may be required if tha tree consists
of a long-ass chain of lil' thugs. Thus, tha algorithm is O( n) up in da most thugged-out shitty case.
For example,
NOTE
See p. 445 fo' a recursive version of insert.
Findin a Target Element up in a Binary Search Tree
Da special orderin property of a funky-ass binary search tree allows fo' quick n' easy as fuck  searching
for any given element. If tha target is less than tha current node value, go left,
otherwise go right.
Da followin method returns a TreeNode wit tha key value. Well shiiiit, it returns null if the
key aint up in tha tree.
THE find METHOD
Here is tha find method from tha BinarySearchTree class:
Binary Search Trees
IIReturns TreeNode wit key.
IIIf key not up in tree, returns null
hood TreeNode find(Comparable key)
{
TreeNode p = getRoot();
while (p 1= null &amp;&amp; key.compareTo(p.getValue(»1= 0)
{
}
if (key.compareTo(p.getValue(» &lt; 0)
p = p.getLeft();
else
p = p.getRight();
return p;
}
RUN-TIME ANALYSIS
To find a single element up in a funky-ass binary search tree of n elements: Da analysis is practically
identical ta dat fo' insertion.
1. Balanced tree: A search will require at most one comparison per level (i.e., no
more than log2 n comparisons). Thus, tha algorithm is O(log n).
2. Unbalanced tree: As nuff as n comparisons may be required ta search a long
chain of nodes. Thus, tha algorithm is O( n ) up in da most thugged-out shitty case.
NOTE
See Question 35 on p. 679 fo' a recursive version of find.
Creatin a Binary Search Tree
CREATING THE TREE
Da followin program
 Creates a funky-ass binary search tree of single-characta strings .
 Tests tha find method.
1* Accesses a gangbangin' file of characta strings, one per line,
and bangs dem tha fuck into a funky-ass binary search tree. *1
hood class BinarySearchTreeTest
{
hood static void main(String[] args)
{
Ilcode ta open inFile
BinaryTree tree = freshly smoked up BinarySearchTree();
Strin ch;
while « there be still elements up in inFile »
{
}
ch = inFile.readLine();
tree.insert(ch);
System.out.println("Enta characta key: Pt II);
ch = IO.readLine(); Ilread user input
TreeNode t = tree.find(ch);
439
440
}
}
Chapta 10 Trees
if (t == null)
System.out.println(ch + " was not up in tha tree.");
else
System.out.println(ch + " was found up in tha tree!");
RUN-TIME ANALYSIS FOR CREATING A BINARY SEARCH TREE
1. Da dopest case occurs if tha elements is up in random order, leadin ta a tree
that is reasonably balanced, wit tha level of tha tree approximately equal to
log2 n. I aint talkin' bout chicken n' gravy biatch. To create tha tree, each of tha n elements will
require no mo' than log2 n comparisons, so tha run time
is O(nlogn). .
2 fo' realz. An example of da most thugged-out shitty case occurs if tha elements are
initially sorted or sorted up in reverse order n' shit. Da tree thus
formed be a sequence of left or right links as shown. I aint talkin' bout chicken n' gravy biatch. To
create tha tree, insertion of nodes requires 0+ 1 + 2+. .. +
n -1 = n(n -1)/2 comparisons, which is O(n2).
TREE TRAVERSAL
Three Methodz of Traversal
A
\
B
\
c
\
D
\
E
There is no natural order fo' accessin all tha elementz of a funky-ass binary tree. Three different
methodz of traversal is used, each wit its own applications.
Inorder: left - root - right A
Recursively: H root aint null: / \
Traverse tha left subtree inorder B C
Smoke up tha root
Traverse tha right subtree inorder BAC
Preorder: root - left - right
Recursively: H root aint null:
Smoke up tha root
Traverse tha left subtree preorder
Traverse tha right subtree preorder ABC
Postorder: left - right - root
Recursively: H root aint null:
Traverse tha left subtree postorder
Traverse tha right subtree postorder
Smoke up tha root BCA
Tree Traversal
Example 1 p
F/ "'S / \ / \. B H R Y
/ / " G T Z " W
Inorder: BFGHPRSTWYZ
Preorder: PFBHGSRYTWZ
Postorder: BGHFRWTZYSP
Example 2
A
B/ "c / /\
D E F
\ / \
G H I
Inorder: DGBAHEICF
Preorder: ABDGCEHIF
Postorder: GDBHIEFCA
Implementin tha Traversal Algorithms
Da traversals busted lyrics bout apply ta all binary trees. Well shiiiit, it therefore make sense ta add them
to tha BinaryTree superclass wit they implementations. Each traversal gonna git a
recursive helper method. Y'all KNOW dat shit, muthafucka! Each recursive helper method bigs up tha definizzle fo' its
particular traversal n' has a TreeNode parameter n' shit. Da base case is when dis parameter
is null. Da "Smoke up tha root" step of tha definizzle simply writes up tha data up in the
node wit System. out. println ...
Here is tha code fo' tha postorder method.
hood void postorder()
{ doPostorder(root): }
private void doPostorder(TreeNode t)
{
}
if (t != null)
{
}
doPostorder(t.getLeft(»;
doPostorder(t.getRight(»;
System.out.print(t.getValue(»:
NOTE
1. Right back up in yo muthafuckin ass. Similar methodz can be freestyled fo' inorder n' preorder traversals-be shizzle to
put tha statements up in tha erect order!
2. Usin tha private helper methodz (doPostorder, fo' example) allows tha root
parameta ta remain hidden up in tha BinaryTree class fo' realz. A client method can call
a traversal method as bigs up:
441
442
BinaryTree tree = freshly smoked up BinarySearchTree();
&lt; code ta read elements tha fuck into tree &gt;
System.out.print("POSTORDER: Pt II);
Chapta 10 Trees
tree.postorder(); . //prints tha elements postorder
3. If tha tree be a funky-ass binary search tree (as up in Example 1 on tha previous page), an
inorder traversal will print up tha elements up in increasin sorted order.
RECURSIVE TREE ALGORITHMS
Most algorithms dat involve binary trees is recursive cuz tha trees theyselves are
recursive structures. Many of these algorithms traverse tha tree n' then report some
result bout tha tree. Right back up in yo muthafuckin ass. Some chizzle tha contentz of tha nodes without alterin the
structure of tha tree (i.e., no nodes is added or removed). Other algorithms chizzle
the structure of tha tree.
A typical recursive method dat do not chizzle tha structure of tha tree has this
scheme (in pseudo-code):
doTreeStuf/
{
}
if (root 1= null) //handlez base case
{
}
Handle tha root
doTreeStuf[ ta left subtree
doTreeStuf[ ta right subtree
//Don't forget ta git on over ta tha root.
//recursive call
//recursive call
NOTE
1. This is just a general scheme. Often hittin' up tha root postorder or inorder leads
to tha same erect result. Right back up in yo muthafuckin ass. Sometimes order is blingin; it dependz on the
actual application.
2. If tha return type of doTreeStuff aint void, be shizzle ta return a appropriate
value.
For tha followin examplez assume dat trees is implemented wit tha TreeNode
class on page 433.
Example 1
/* Precondition: tree be a funky-ass binary tree of Integer joints.
* Postcondition: Returns tha sum of tha joints up in tha tree,
* 0 if tha tree is empty. */
hood int treeSum(TreeNode tree)
{
}
if (tree == null)
return 0;
else
return «Integer) tree.getValue(».intValue()
+ treeSum(tree.getLeft(» + treeSum(tree.getRight(»;
Recursive Tree Algorithms
Example 2
Two trees is similar if they have tha same shape n' pointa structure. Thus, the
followin two trees is similar:
whereas these two trees is not similar:
//Returns legit if tree1 is similar ta tree2, false otherwise.
hood boolean similar(TreeNode tree1, TreeNode tree2)
{
}
if (tree1 == null &amp;&amp; tree2 == null)
return true;
else
if (tree1 == null I I tree2 null)
return false;
else
//both null
//one null
return similar(tree1.getLeft(), tree2.getLeft()) &amp;&amp;
similar(tree1.getRight(), tree2.getRight());
Example 3
/* Precondition: Binary tree rooted at tree.
* Postcondition: Creates identical tree n' returns reference
* ta its root node. */
hood TreeNode newTree(TreeNode tree)
{
}
if (tree == null)
return null;
//base case
else
{
}
TreeNode temp = freshly smoked up TreeNode(tree.getValue());
temp.setLeft(newTree(tree.getLeft())); //attach
//left subtree
temp.setRight(newTree(tree.getRight())); //attach
//right subtree
return temp;
443
444 Chapta 10 Trees
NOTE
Da newTree example is freestyled wit nuff muthafuckin statements ta clarify tha algorithm. The
method can, however, be compacted as bigs up:
hood TreeNode newTree(TreeNode tree)
{
}
if (tree == null)
return null;
else
//base case
return new TreeNode(tree.getValue().
newTree(tree.getLeft(». newTree(tree.getRight(»);
Example 4
Recall dat tha height of a funky-ass binary tree is tha number of edges on tha longest path
from tha root ta a leaf. Yo ass may assume dat tha height of a empty tree is -1. The
height of a tree wit just one node is o. Da height of any given node is tha number
of edges on tha longest path from dat node ta a leaf. To write a method dat findz the
height of a node, you may use tha method Math.max(a. b), which returns tha larger
of a n' b.
//Return tha height of node t.
hood int height(TreeNode t)
{
if (t == null)
return -1;
else
return 1 + Math.max(height(t.getLeft(».
height(t.getRight(»);
}
NOTE
Da height of node t equals tha height of tha left or right subtree, whichever is bigger.
Yo ass must add 1 cuz tha edge from tha node ta tha root is counted up in tha height of
the tree.
Recursion That Altas tha Tree Structure
Recursive methodz dat chizzle tha structure of a tree by addin or removin nodes can
be tricky. For example, consider rockin a recursive bang method instead of tha iterative
insert provided fo' tha BinarySearchTree class (p. 437). Recall dat tha method
inserts a freshly smoked up item tha fuck into tha tree.
A client method would call bang wit code like tha following:
BinaryTree tree = freshly smoked up BinarySearchTree();
System.out.println("Enta shit ta be banged ... ");
while « there be shit ta insert»
{
}
Object item = IO.readltem();
tree.insert(item);
//read user input
Recursive Tree Algorithms
If tha bang method is recursive, tha above method call, tree. bang (i tem), will
not work as intended cuz up in order ta make recursive calls tha method must have a
TreeNode parameter.
Suppose you modify bang so dat it includes tha required TreeNode parameta and
change tha client statement dat invokes bang ta be
tree.insert(tree.getRoot(). item);
This still won't work cuz tha TreeNode parameta is passed by value, so tha tree
will remain unchanged hommie! Da way ta chizzle tha tree is ta return tha chizzled TreeNode,
in addizzle ta havin a TreeNode as a parameta fo' tha recursive calls.
Da problem is solved by makin bang nonrecursive n' havin it call a private
recursive helper method recur Insert dat takes a TreeNode parameta n' returns
a TreeNode reference. Da client method call up in tha code segment above remains
tree. bang (item).
Here is tha code fo' both tha bang n' recurInsert methods, which is added to
the BinarySearchTree class.
//Insert item up in BinarySearchTree.
hood void insert(Comparable item)
{
setRoot(recurInsert(getRoot(). item));
}
/* private helper method
* Findz insertion point fo' freshly smoked up node n' attaches dat shit.
* Returns reference ta TreeNode along insertion path. */
private TreeNode recurInsert(TreeNode t. Comparable item)
{
}
if (t == null)
return new TreeNode(item);
else if (item.compareTo(t.getValue()) &lt; 0)
t.setLeft(recurInsert(t.getLeft(). item));
else
t.setRight(recurInsert(t.getRight(). item));
return t;
NOTE
1. If tha tree is empty, recurInsert simply returns tha freshly smoked up TreeNode containing
item. Otherwise, if item is less than tha value up in tha current node, tha algorithm
recursively goes left. If item is pimped outa than or equal ta tha value up in the
current node, it recursively goes right. When tha insertion point is found (base
case-TreeNode parameta is null), a freshly smoked up node is pimped n' attached at that
point.
2. Da statement up in tha nonrecursive bang method
setRoot(recurInsert(getRoot(). item));
altas tha root node .of tha tree only if tha tree was originally empty or contained
just one node. In fact, tha recursive method recurInsert don't alter
any nodez of tha tree except all up in tha insertion point. Da returned node at each
previous stage is simply a node along tha path ta tha insertion point.
445
446 Chapta 10 Trees
3 yo. Here be a scheme, up in pseudo-code, fo' a typical recursive helper method that
changes tha structure of a tree.
private TreeNode recurChangeTree(TreeNode t, other parametas ... }
(
if(t ==nulO
return a freshly smoked up TreeNode(. . .); / /typically
else if « some test &gt;)
t.setLeft(recurChange Tree(t.getLeftO, other parametas ... };
else
t.setRight{recurChange Tree(t.getRightO, other parametas ... };
return t; / / don't forget this!
}
NOTE
For examplez of recursive methodz dat alta a linked list, peep Question 22 on p. 397
and Question 23 on p. 670.
_BI_N_A_RY_ _EX_P_R_E SSION TREES Pt II'.~.~. _~ .... ..... _5:f11!! _________ _
Infix, Postfix, n' Prefix Expressions
A common application of trees is tha storage n' evaluation of mathematical expressions.
A mathematical expression is made up of operators like +, -, *, I, n' % and
operands, which is numbers n' variables.
There is three different representationz of expressions:
infix: A+B
prefix: +AB
postfix: AB+
Da "in," "pre," n' "post" describe tha posizzle of tha operator wit respect ta the
operands. To convert tha familiar infix form ta postfix, fo' example, convert tha pieces
of tha expression wit highest precedence ta postfix first. Then continue dat way in
stages.
Example 1
Convert (A + B) * (C - D) ta postfix.
(A + B) * (C + D) = (AB+) * (CD-) Ilparentheses have highest precedence
= AB + CD - * Iitreat AB+ n' CD- as single operands
Example 2
Convert (A - B)/C * D ta prefix.
(A-B)/C*D=((-AB)/C)*D Pt II * n' I have equal precedence. Work
I I from left ta right
=(f-ABC)*D
=*/~ABCD
Binary Expression Trees
Example 3
Convert A - B/(C + D * E) ta postfix.
Example 4
A-B/(C+D*E)=A-B/(C+(DE*))
=A-(B/CDE*+)
=A-BCDE*+/
=ABCDE*+/-
Convert A - B/(C + D * E) ta prefix.
A"": B/(C + D * E) = A - B/(C + (*DE))
=A-(B/(+C * DE))
=A-/B+C*DE
=-A/B+C*DE
Binary Expression Tree
A binary expression tree either consistz of a single root node containin a operand or
stores a expression as bigs up. Da root gotz nuff a operator dat is ghon be applied to
the thangs up in dis biatch of evaluatin tha expressions up in tha left n' right subtrees, each of which is
a binary expression tree.
A node containin a operator must have two nonempty subtrees fo' realz. A node containing
an operand must be a leaf. For example,
5+3 A-B 9*(2/3)
NOTE
1. Da level of tha nodes indicates tha precedence: Da operation all up in tha root will
always be tha last operation performed. Y'all KNOW dat shit, muthafucka! Operations up in tha highest level nodes
are performed first.
2 fo' realz. An expression can be generated up in its infix form by a inorder traversal of the
tree. (But you must provide tha brackets!) A preorder traversal yieldz tha prefix
form, whereas a postorder traversal yieldz tha postfix form.
Example 1
Write tha infix, prefix, n' postfix form of tha expression represented by each binary
expression tree.
447
448
infix: A+B*C
prefix: +A*BC
postfix: ABC *+
Example 2
Chapta 10 Trees
infix: (A+B*C)/«A+B)*C)
prefix: /+A*BC*+ABC
postfix: ABC*+AB+C*/
Evaluate tha expression up in tha followin tree.
Solution: Do a inorder traversal ta git tha followin infix form:
[(-4+6)-3] * [12+ 14/2] =(2-3)*(12+7)= -19
Evaluatin a Binary Expression Tree
Consider a program dat places a expression up in a funky-ass binary expression tree n' then
evaluates tha tree. For tha purposez of dis program, assume dat a node gotz nuff
either a operator Qike "+", "-", etc.) or a integer value.
For example, a funky-ass binary expression tree wit tha expression (3 +4) * 6 would look like
this:
Notice dat tha left n' right subtree of each operator node be a expression:
Binary Expression Trees
For*: left subtree is Jb right subtree is 0
For+: left subtree is (2) right subtree is 8
Each of these quantitizzles be a expression:
Each of these expressions be a funky-ass binary operation:
Each of these expressions be a cold-ass lil constant:
Each expression dat be a funky-ass binary operation is either a sum, product, quotient, or difference.
This all suggests a program dat has a Expression superclass, wit subclasses
BinaryOperation n' Constant. Further, BinaryOperation should have subclasses
Sum, Difference, Product, n' Quotient.
Evaluatin a expression consistz of evaluatin tha left n' right subtrees n' applying
the operator all up in tha root. Thus,
(value of tree) = (value of left subtree)  (value of right subtree)
where, so peek-a-boo, clear tha way, I be comin' thru fo'sho. be a funky-ass binary operation. I aint talkin' bout chicken n' gravy biatch. But
(value of left subtree) = (value of its left subtree) 0 (value of its right subtree)
where 0 is some other binary operation. I aint talkin' bout chicken n' gravy biatch. Clearly tha process is recursive. Da value
obtained from a given subtree dependz on whether dat subtree be a Constant or a
BinaryOperation. I aint talkin' bout chicken n' gravy biatch. If itz a Constant, its value is just dat number (base case). If it's
a BinaryOperation, then, dependin on tha operator, either a Sum is evaluated or
a Product is, n' so on. I aint talkin' bout chicken n' gravy biatch. This procedure extendz all tha way down ta tha leavespolymorphism
is applied at each stage, determinin which kind of expression ta evaluate.
449
450 Chapta 10 Trees
A Binary Expression Tree Program
Here is tha classes used up in tha program 1 fo' evaluatin a funky-ass binary expression tree:
/* An abstract class fo' arithmetic expressions */
hood abstract class Expression
{
}
//Postcondition: Returns tha value of dis Expression.
hood abstract int evaluate();
NOTE
Da evaluate method be abstract cuz evaluation dependz on tha type of expression
bein evaluated.
/* A class dat defines expressions dat is constants */
hood class Constant extendz Expression
{
}
NOTE
private int myValue;
hood Constant(int value)
{ myValue = value; }
hood int evaluate()
{ return myValue; }
hood Strin toString()
{ return "" + myValue; }
Da Constant class be a cold-ass lil concrete (nonabstract) class. Da evaluate method is clearly
defined fo' a cold-ass lil constant; simply return its value.
/* An abstract class dat defines expressions
* dat is binary operations */
hood abstract class BinaryOperation extendz Expression
{
private Expression myLeft, myRight;
private Strin myOp; //symbolic representation of tha operator
hood BinaryOperation(Strin op, Expression lhs, Expression rhs)
{
}
myLeft = lhs;
myRight = rhs;
myOp = op;
hood Strin toString()
{
}
return Pt II (" + myLeft. toStrin 0 + Pt II Pt II + myOp
+ 1111 + myRight.toStringO + ")";
J This program uses tha classes shown by Dizzy Levine at a workshop at St. Bonaventure n' attributed
to Scot Drysdale.
Binary Expression Trees
}
hood Expression getLeft()
{ return myLeft: }
hood Expression getRight()
{ return myRight: }
NOTE
Da BinaryOperation class be abstract cuz tha evaluate method cannot be explicitly
defined here: It dependz on tha binary operator.
1* A class dat defines expressions dat is sums *1
hood class Sum extendz BinaryOperation
{
}
hood Sum (Expression lhs, Expression rhs)
{ super(II+II, lhs, rhs): }
hood int evaluate()
{ return getLeft().evaluate() + getRight().evaluate(); }
NOTE
t. For tha Sum class, tha evaluate method can be defined without ambiguity:
(value of left subtree) + (value of right subtree)
2. Right back up in yo muthafuckin ass. Similar classes is defined fo' Product, Quotient, n' Difference.
Da ExpressionEvaluator program looks suttin' like this:
hood class ExpressionEvaluator
{
}
hood static void main(String[] args)
{
}
ExpressionHandlez h = freshly smoked up ExpressionHandlez();
Ilcreate binary expression tree from postfix
II expression up in input file
Expression expr = h.createTree():
System.out.println(lIvalue of Pt II + expr.toStringO
+ Pt II is Pt II + expr.evaluateO):
System.out.println();
NOTE
t. In case you wonderin how tha fuck tha expression gots tha fuck into tha tree, implementation
code fo' tha ExpressionHandlez class n' a FileHandlez class is provided in
AppendixB.
2. Notice how tha fuck polymorphizzle be applied when root. evaluate 0 is called:
451
452 Chapta 10 Trees
root
(i) Da node wit * is encountered. Y'all KNOW dat shit, muthafucka! Da callin object is therefore a Product,
which produces
getLeft().evaluate() * getRight().evaluate()
000 *8
(ii) For tha left-hand side up in step (i), tha node wit + is encountered. Y'all KNOW dat shit, muthafucka! The
callin object is therefore a Sum, which produces
getLeft 0 . evaluate 0 + getRight 0 . evaluate 0
(0 + (0
(iii) When tha nodes up in step (ii) is encountered, n' also tha right-hand
side up in step (i), tha controllin object up in each case be a Constant. Thus,
a call ta evaluate returns tha joints 3, 4, n' 6, respectively.
(iv) Thus, tha sum up in step (ii) is 7, n' tha thang up in step (i) is 7 * 6, which
is 42.
3 fo' realz. As you study dis implementation of a funky-ass binary expression tree, you may be
wondering: Where did tha BinaryTree go, biatch? Da answer is dat TreeNode has
been replaced wit a Expression. I aint talkin' bout chicken n' gravy biatch. Each node up in tha tree thatz pimped represents
an Expression. I aint talkin' bout chicken n' gravy biatch. Each Expression node gotz nuff a value (either a Constant
or BinaryOperation) as well as a left n' right pointa field dat refers ta another
Expression. I aint talkin' bout chicken n' gravy biatch fo' realz. An Expression, like a TreeNode, is self-referential n' can
be linked ta other Expression objects ta form a funky-ass binary expression tree.
Da inheritizzle hierarchy up in dis program be a elegant way of representin the
various elements dat comprise tha binary expression tree.
Run Time of Binary Search Tree (BST) Algorithms
Expression
«abstract»
Difference
RUN TIME OF 81NARY SEARCH TREE (8ST)
ALGORITHMS
.. _--------
Operation Balanced Unbalanced Comment
BST BST
Insert 1 element O(logn) O(n) At most log2 n comparisons in
intoBST balanced BST, n up in unbalanced.
Insert n ----.----~--
elements tha fuck into O(nlogn) O(n2) Same as above yo, but fo' each of n
originally empty elements.
BST . __ ._-------
Search fo' key O(logn) O(n) At most log2 n comparisons in
balanced BST, n up in unbalanced.
Traverse tree O(n) O(n) Each node hit up once.
--------~-----
Chapta Summary
Know tha vocabulary associated wit binary trees. Yo ass should be able ta use the
TreeNode class ta manipulate trees, n' also ta write code fo' a BinaryTree class.
Understand tha definizzle of a funky-ass binary search tree (BST)-there is bound ta be many
questions on dis topic. In particular, you should know algorithms dat create, traverse,
and search a BST. Know tha big-O analysis fo' such algorithms.
Be familiar wit tha difference between inorder, preorder, postorder, n' level order
traversals fo' realz. All is fair game on tha Ap'exam.
Yo ass should be able ta write recursive algorithms dat traverse a tree, includin algo- .
rithms dat alta tha structure of a tree. Be familiar wit recursive helper methods-in
the past few muthafuckin years these have rocked up in tha free response (part two) thangs on the
exam.
453
454 Chapta 10 Trees
~. ___" _______________ ~._"~._~: ______ &amp;_I~_-_'~m_ ________________
MULTIPLE-CHOICE QUESTIONS ON TREES
1 fo' realz. A slick binary tree has every last muthafuckin leaf on tha same level, n' every last muthafuckin nonleaf node has
two lil' thugs fo' realz. A slick binary tree wit k leaves gotz nuff how tha fuck nuff nodes?
(A) k
(B) k2
(C) 2k
(D) log2k
(E) 2k-1
2. Da level of a node is tha length of tha path (or number of edges) from tha root
to dat node. Da level of a tree is equal ta tha level of its deepest leaf fo' realz. A binary
tree has level k. Which represents
1. Da maximum possible number of nodes, and
2. Da minimum possible number of nodes up in tha tree?
(A) (1) 2k+1
(B) (1) 2k+1
(C) (1) 2k+l - 1
(D) (1) 2k+1 - 1
(E) (1) 2k + 1
(2) 2k + 1
(2) k
(2) k
(2) k + 1
(2) 2k
3. Which of tha followin represents (1) inorder, (2) preorder, n' (3) postorder
traversalz of tha tree shown?
(A) (1) GJAPES
(B) (1) GJAEPS
(C) (1) EPSAJG
(D) (1) GJAEPS
(E) (1) GJAPES
(2)JAGPES
(2)JGAPES
(2)PESJGA
(2) GESPAJ
(2)GAESPJ
(3)"GAESPJ
(3) GESPAJ
(3) ESPGAJ
(3)JGAPES
(3)JAGPES
J
/ " G A ,
P
/ ,
E S
4. Da tree shown is traversed postorder n' each element is pushed onto a stack s
as it is encountered. Y'all KNOW dat shit, muthafucka! Da followin program fragment is then executed:
for (int i = 1; i &lt;= 5; i++)
x = s.popO;
What value is contained up in x afta tha segment is executed?
(A) M
(B) G
(C) K
(D) F
(E) P
K
/ " p C
/ " M E
/ \
F G
Multiple-Choice Thangs on Trees
5. Each of tha followin listz of numbers is inserted, up in tha order given, tha fuck into a funky-ass binary
search tree. Which list produces da most thugged-out balanced tree?
(A) 2 4 7 5 8 10
(B) 9 7 2 1 4 0
(C) 5 1 2 6 3 4
(D) 2 5 1 4 0 3
(E) 6 4 1 8 10 5
6. Da element 10 is ta be banged tha fuck into tha binary search tree shown.
Afta insertion, tha tree be as bigs up:
(A) (B)
(C) (D)
(E)
7 fo' realz. Array elements a[O], a[l], ... , a[n-l] is banged tha fuck into a funky-ass binary search tree.
Da tree will then be used ta search fo' a given element. In da most thugged-out shitty case, the
insertion n' search, respectively, wili be
(A) O(n2),O(nlogn)
(B) O(nlogn),O(nlogn)
(C) O(n2), O(n)
(D) O(n2),O(n2)
(E) O(n),O(n)
455
456 Chapta 10 Trees
8. Worst case performizzle of tha search fo' a key up in a funky-ass balanced binary search tree is
(A) O(n2)
(B) O(n)
(C) O(logn)
(D) O(2n)
(E) O(nlogn)
9. Da value of tha binary expression tree shown is
(A) 1 '
(B) 4
(C) 10
(D) 11
(E) 25
10. Which of tha followin erectly represents tha expression A/B * C % D?
(A) (B)
(C) (D)
(E)
11. Da (1) prefix n' (2) postfix formz of tha expression P + (Q - R) * A/B are
(A) (1) +P*-QR/AB (2) PQR-AB/*+
(B) (1) PQR-AB/*+ (2) +P*-QR/AB
(C) (1) PQR-A*B/+ (2) +P/*-QRAB
(D) (1) +P/*-QRAB (2) PQR-A*B/+
(E) (1) +*P-QR/AB (2) PQRA-*B/+
Multiple-Choice Thangs on Trees
For Thangs 12-22 assume dat binary trees is implemented wit tha TreeNode class
onp.433.
12. Right back up in yo muthafuckin ass. Suppose dat p refers ta a node as shown. I aint talkin' bout chicken n' gravy biatch. Which of tha followin erectly inserts
the Object obj as tha right lil pimp of tha node dat p points to?
(A) p.setRight(new TreeNode(obj»;
(B) p = freshly smoked up TreeNode(obj, p.getLeft(), p.getRight(»;
(C) p.setRight(new Object(obj»;
0) p.setRight(new TreeNode(obj, p.getLeft(), p.getRight(»);
(E) p = freshly smoked up TreeNode(obj);
13. Refer ta method numNodes:
IIReturns tha number of nodes up in tree.
hood int numNodes(TreeNode tree)
{
}
if (tree == null),
return 0;
else
{
1* code *1
}
Which replacement fo' 1* code *1 will cause tha method ta work as intended?
I return 1 + numNodes(tree.getLeft(» +
numNodes(tree.getRight(»;
II return numNodes(tree) + numNodes(tree.getLeft(» +
numNodes(tree.getRight(»;
III return numNodes(tree.getLeft(» + numNodes(tree.getRight(»;
(A) None
(B) I only
(C) Pt II only
0) Pt III only
(E) I n' Pt II only
457
458 Chapta 10 Trees
14. Two trees is mirror imagez of each other if they roots n' left n' right subtrees
are reflected across a vertical line as shown:
Example 1 Example 2
Refer ta tha followin method mirrorTree:
1* Precondition: tree refers ta tha root of a funky-ass binary tree.
* Postcondition: A mirror image of tree is pimped and
* a reference ta it is returned. Y'all KNOW dat shit, muthafucka! *1
hood TreeNode mirrorTree(TreeNode tree)
{
}
if (tree == null)
return null;
else
{
1* mo' code *1
}
Which of tha followin replacements fo' 1* mo' code *1 erectly achieves the
postcondizzle fo' method mirrorTree?
I TreeNode temp = freshly smoked up TreeNode(null, null, null);
temp.setValue(tree.getValue(»;
temp.setLeft(mirrorTree(tree.getRight(»);
temp.setRight(mirrorTree(tree.getLeft(»);
return temp;
IT return new TreeNode(tree.getValue(),
mirrorTree(tree.getRight(»,
mirrorTree(tree.getLeft(»);
III return new TreeNode(tree.getValue(),
mirrorTree(tree.getLeft(»,
mirrorTree(tree.getRight(»);
(A) I only
(B) IT only
(C) llionly
(D) I n' IT only
(E) I n' lli only
Multiple-Choice Thangs on Trees
15. Refer ta method leaf Sum:
//Returns sum of leaves up in tree, 0 fo' empty tree.
hood int leaf Sum (TreeNode tree)
{
}
if (tree == null)
return 0;
else
{
}
Which replacement fo' /* code */ is erect?
(1\) if (tree.getLeft() == null tt tree.getRight() == null)
return «Integer) (tree.getValue(»).intValue();
else
return 1 + leafSum(tree.getLeft(» +
leafSum(tree.getRight(»;
(B) if (tree.getLeft() == null I I tree.getRight() == null)
return «Integer) (tree.getValue(»).intValue();
else
return 1 + leafSum(tree.getLeft(» +
leafSum(tree.getRight(»;
(C:) if (tree.getLeft() == null tt tree.getRight() == null)
return «Integer) (tree.getValue(»).intValue();
else
return «Integer) (tree.getValue(»).intValue() +
leafSum(tree.getLeft(» + leafSum(tree.getRight(»;
0) if (tree.getLeft() == null I I tree.getRight() == null)
return «Integer) (tree.getValue(»).intValue();
else
return leafSum(tree.getLeft(» +
leafSum(tree.getRight(»;
(E) if (tree.getLeft() == null tt tree.getRight() == null)
return «Integer) (tree.getValue(»).intValue();
else
return leafSum(tree.getLeft(» +
leafSum(tree.getRight(»;
459
460
16. Which is legit bout method find?
IIReturn TreeNode wit target value,
II or null if target not found.
Chapta 10 Trees
hood TreeNode find(TreeNode root, Comparable target)
{
}
if (root == null)
return null;
else if (target.compareTo(root.getValue(»== 0)
return root;
else if (target.compareTo(root.getValue(» &lt; 0)
return find(root.getLeft(), target);
else
return find(root.getRight(), target);
(A) Method find aint NEVER gonna work as intended.
(B) Method find will always work as intended.
(C) Method find will only work as intended if target aint up in tha tree.
(D) Method find will always work as intended if tha tree be a funky-ass binary search tree.
(E) Method find will only work as intended if tha tree be a funky-ass binary search tree
and target occurs no mo' than once up in tha tree.
17. Refer ta method doSomething:
hood Comparable doSomething(TreeNode root)
{
}
if (root != null)
if (root.getRight() == null)
return (Comparable) root.getValue();
else
return doSomething(root.getRight(»;
return null;
Which dopest raps bout what tha fuck doSomethang do?
(A) It returns tha phattest element up in a nonempty binary search tree.
(B) It returns tha phattest element up in a nonempty tree.
(C) It returns a element all up in tha highest level of a nonempty tree.
(D) It returns tha smallest element up in a nonempty binary search tree.
(E) It returns tha smallest element up in a nonempty tree.
Multiple-Choice Thangs on Trees
18. Refer ta method traverse, n' ta tha binary tree of Integer joints shown:
hood void traverse(TreeNode t)
{
}
if (t != null)
{
/* code */
}
1
2/"'3
/ \ / \
4 567
By replacin / * code * / wit tha three statements traverse (t . getLeft 0 ),
traverse(t.getRight(», n' System.out.print(t.getValue(» up in some o~
der, we can cause method traverse ta execute one of six traversals. For example,
by replacin /* code */ with
traverse(t.getLeft(»;
traverse(t.getRight(»;
System.out.print(t.getValue(»;
we would cause traverse ta execute a postorder traversal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Which of tha following
replacements fo' /* code */ will cause tha numbers 1 all up in 7 ta be printed in
ascendin order when traverse(t) is called?
(A) traverse (t . getLeft () ) ;
System.out.print(t.getValue(»;
traverse(t.getRight(»;
(B) System.out.print(t.getValue(»;
traverse(t.getLeft(»;
traverse(t.getRight(»;
(C) traverse(t.getRight(»;
traverse(t.getLeft(»;
System.out.print(t.getValue(»;
0)) traverse(t.getRight(»;
System.out.print(t.getValue(»;
traverse(t.getLeft(»;
(E) It be impossible ta print tha numbers 1 all up in 7 up in ascendin order using
this method.
461
462
19. This question uses a object from tha followin class:
/* An Integer object dat can be altered */
hood class IntObj
{
private int myValue;
hood IntObj(int value) //constructor
{ myValue = value; }
Chapta 10 Trees
hood void increment() //increments IntObj by 1
}
{ myValue++; }
//Returns Integer equivalent of IntObj.
hood Integer getInteger()
{ return new Integer(myValue); }
Refer ta tha followin method:
/* Precondition: tree be at root
* Integer joints.
hood void number(TreeNode tree,
{
if (tree != null)
of binary tree dat gotz nuff
*/
IntObj nextNum)
if (tree.getLeft() == null tt tree.getRight() == null)
{
}
}
else
{
}
tree.setValue(nextNum.getInteger(»;
nextNum.increment();
number(tree.getRight(), nextNum);
number(tree.getLeft(), nextNum);
Assumin dat a funky-ass binary tree of Integer joints is rooted at tree, which of the'
followin trees be a possible result of executin tha next two statements?
IntObj nextNum m freshly smoked up IntObj(3);
number (tree , nextNum);
(A) tree
3?
/ \
4 5
/ \
6 7
/ \
8 9
OB) tree
1 ?
/ \
6 2
/ \
8 3
/ \
5 4
Multiple-Choice Thangs on Trees
(C) tree (D) tree
9~ 4~
/ \ / \
8 7 3 5
/ \ / \
4 3 6 7
/ \ / \
6 5 8 9
OE) tree
2~
/ \
3 7
/ \
1 6
/ \
4 5
20. Recall dat tha level of a node is tha number of edges from tha root ta dat node.
Da level of a tree equals tha level of its deepest leaf. Thus, tha level of a tree with
just one node is o.
Refer ta method whatslt:
hood int whatslt(TreeNode tree)
{
}
if (tree == null)
return -lj
else
{
}
int x = 1 + whatslt(tree.getLeft(»j
int y = 1 + whatslt(tree.getRight(»j
if (x &gt;= y)
return Xj
else
return Yi
Method whatslt returns -1 fo' a empty tree. What do method whatslt do
when invoked fo' a nonempty tree?
(A) It returns tha phattest value up in tha tree.
(B) It returns tha number of nodes up in tha subtree dat has tha top billin number
of nodes.
(C) It returns tha level of tha tree.
(D) It returns 1 plus tha level of tha tree.
(E) It returns either tha leftmost value or tha rightmost value of a tree,
whichever is larger.
463
464 Chapta 10 Trees
21. Right back up in yo muthafuckin ass. Suppose dat tha node height of a funky-ass binary tree is defined as bigs up: Da node
height of a empty tree is 0; tha node height of a nonempty tree is tha number
of nodes on tha longest path from tha root ta a leaf of tha tree. Thus, tha node
height of tha tree shown is 5.
Refer ta method f:
hood int f(TreeNode t)
{
}
if (t == null)
return 0;
else
return max(
nodeHeight(t.getLeft()) + nodeHeight(t.getRight()).
f(t.getLeftO) 
f(t.getRight(»);
Yo ass may assume dat method max(a.b.c) returns tha phattest of its integer arguments
and dat method nodeHeight returns tha node height of its tree argument.
What value is returned when f (t) is called fo' tha tree pictured?
(A) 4
(B) 5
(C) 6
(D) 7
(E) 8
Multiple-Choice Thangs on Trees
22 fo' realz. A recursive method doPostorder be added ta a BinaryTree class:
hood void doPostorder(TreeNode t)
{
}
if (t != null)
{
}
doPostorder(t.getLeft(»j
doPostorder(t.getRight(»;
System.out.print(t.getValue(»;
Suppose dis method is called fo' a TreeNode all up in tha root of a tree wit n elements.
Da run-time efficiency of doPostorder is
(A) O(logn)
(B) O(n)
(C) O(nlogn)
(0) O(n2)
(E) O(2n)
465
466 Chapta 10 Trees
ANSWER KEY
1.E 9. E 17 fo' realz. A
2. D 10 fo' realz. A 18. E
3. B 11. D 19. B
4 fo' realz. A 12 fo' realz. A 20. C
5. E 13. B 21. C
6. B 14. D 22. B
7. C 15. E
8. C 16. D
ANSWERS EXPLAINED
1. (E) Draw some pictures n' count!
#of leaves #of nodes
1 1
2 3
4 7
8 15
16 31
32 63
k 2k-l
2. (0) For tha maximum possible number of nodes, each node must have two lil' thugs.
Notice tha pattern:
Max possible
Level #of nodes
0 1
1 3
2 7
3 15
k 2k+t -1
For tha minimum possible number of nodes, each node must have no mo' than
one child. Y'all KNOW dat shit, muthafucka! Thus, fo' example, a level 3 tree wit tha minimum number of nodes
will be lookin like this:
Answers Explained
or or n' so on.
In each case, there is ghon be k + 1 nodes.
3. (B)
(1) For inorder be thinkin left-root-right (i.e., G-J-right). When you now traverse
the right subtree inorder, there is no left, so A comes next. Then traverse
the P-E-S subtree inorder, which gives E-P-S.
(2) For preorder be thinkin root-left-right (i.e., J-G-right). When you now traverse
the right subtree, A is now tha root n' comes next. There is no left, so
traverse tha P-E-S subtree preorder, which gives P-E-S.
(3) Similarly fo' postorder, thankin left-right-root produces GESPAJ.
4. (A) A postorder traversal yieldz PFMGECK, so herez tha stack:
K
C
E
G
M
F
P
Da fifth pop will remove element M.
5. (E) In each case, tha straight-up original gangsta number up in tha list will go tha fuck into tha root node. Right back up in yo muthafuckin ass. Subsequent
numbers dat is less than tha straight-up original gangsta number will go tha fuck into tha left subtree;
those pimped outa than or equal ta tha straight-up original gangsta will go tha fuck into tha right subtree. Eliminate
choices A n' B, which is almost up in sorted order n' shit. Each of these will form trees
that is virtually long chains:
.Choice A
2
\
4
\
7
/ \
5 8
\
10
/
o
ChoiceB
/
2
/ \
9
/
7
1 4
467
468 Chapta 10 Trees
Choice C won't form a funky-ass balanced tree either: All elements but one will go into
the left subtree.
5
/\
1 6
\
2
\
3
\
4
Yo ass should be able ta eliminizzle chizzlez A, B, n' C by inspection. I aint talkin' bout chicken n' gravy biatch. Comparing
the trees up in chizzlez D n' E shows dat E yieldz tha mo' balanced tree:
ChoiceD
2
/"-. 1 . 5
/ /
o 4
/
3
Choice E
6
4/"8
/ \ \
1 5 10
6. (B) Startin all up in tha root, compare tha freshly smoked up element wit tha current node. Go
left if tha element is less than tha current node; otherwise go right. Insert at the
first available empty slot. For tha tree shown, compare 10 wit 7. Right back up in yo muthafuckin ass. Since 10&gt; 7,
go right. Then 10&gt; 9, so go right. Then 10 &lt; 12, a leaf, so bang left.
7. (C) An example of da most thugged-out shitty case fo' insertion tha fuck into a funky-ass binary search tree occurs
when tha numbers is already sorted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da resultin tree is ghon be unbalanced, a
long chain of numbers:
or
Insertion of n elements tha fuck into tha tree requires 0+ 1 + ... + n - 1 = n(n - 1)/2
comparisons, which is O(n2). Right back up in yo muthafuckin ass. Searchin dis tree will require each "link" up in the
"chain" ta be examined, much like a sequential search. This is O( n).
8. (C) If tha tree is balanced, da most thugged-out shitty case occurs when tha key is found up in a leaf
(i.e., all up in tha highest level of tha tree). Da maximum level of a funky-ass balanced tree is
log2 n. I aint talkin' bout chicken n' gravy biatch. Therefore, tha search is o (log n ).
9. (E) Da infix form of tha expression is 3*(2+7)-8/4, which equals (3*9)-2 = 25.
Answers Explained
10. (A) Da operators /, *, n' % all have equal precedence n' must therefore be
performed from left ta right. Thus, tha order of struttin tha operations is
/, followed by *, then %. Now recall tha general rule: Da earlier a operation
is performed, tha higher its node level up in tha tree. In particular, tha last operation
performed be always tha root node. Right back up in yo muthafuckin ass. So % must be up in tha root node, which
eliminates chizzlez Band C. Right back up in yo muthafuckin ass. Since / is performed before *, tha node containing
/ must gotz a higher level than tha node containin *, which eliminates chizzle
D. Chizzle D fails fo' another reason: C * D aint part of tha given expression.
Choice E fails cuz B/ A aint part of tha given expression. I aint talkin' bout chicken n' gravy biatch. Note dat if the
given expression had been (A/B) * (C%D), chizzle B would done been erect,
since / n' % would have equal first precedence n' * would bethe last operation
performed.
11. (D) For both pre- n' postfix, big-ass up tha operations up in order of precedence,
changin each subexpression ta prefix or postfix as you go.
(1) prefix:
P+(Q - R) *A/B = P+ [(-QR)*A]/B
=P+(*-QRA)/B
=P+(f*-QRAB)
=+P/*-QRAB
To go from tha straight-up original gangsta ta tha second line, note dat * n' / have equal precedence,
so use tha leftmost one first.
(2) postfix:
P+(Q-R)*A/B=P+ [(QR-)*A]/B
=P+(QR-A*)/B
=P+(QR-A*Bf)
=PQR-A*B/+
12. (A) Da expression freshly smoked up TreeNode (obj) is tha erect use of tha TreeNode constructor
that creates a freshly smoked up node wit obj dat has null pointa fields. Calling
p. setRight ( ... ) wit dis expression then attaches tha freshly smoked up node as tha right
child of tha node dat p refers to. Chizzle C do not create a freshly smoked up TreeNode.
Choice D is wack cuz tha pointa fieldz of tha freshly smoked up node must be null.
Choices B n' E reassign p rather than bustin tha required attachment ta the
node dat p points to.
13. (B) Eliminizzle segment ill; it forgot ta count tha root node. Right back up in yo muthafuckin ass. Segment Pt II calls
numNodes (tree), which leadz ta infinite recursion. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Segment I erectly addz 1 for
the root node ta tha number of nodes up in tha left n' right subtrees.
14. (D) Segments I n' Pt II is equivalent yo, but segment Pt II, which uses tha threeparameter
TreeNode constructor, is mo' compact. Da order of tha pointa parameters
in tha constructor is left, right, so up in segment Pt II tha call
mirrorTree (tree. getRight 0) will attach as tha left subtree of tha freshly smoked up tree a
duplicate of tha right subtree of tree. Right back up in yo muthafuckin ass. Similarly, tha last parameta of tha constructor,
the call mirrorTree (tree. getLeft 0), will cause a thugged-out duplicate of tha left
subtree of tree ta be attached as tha right subtree of tha freshly smoked up tree. Right back up in yo muthafuckin ass. Segment ill is
wrong cuz it creates a exact copy of tha tree rather than a mirror image.
469
470 Chapta 10 Trees
15. (E) This be a example where you don't automatically add tha value up in the
root node. Thus, eliminizzle chizzlez A, B, n' C, which all add suttin' to
leaf Sum (tree. getLeft 0) + leaf Sum (tree. getRight 0 ). Da erect test for
a leaf is dat both tha left n' right pointas must be null. Thus, eliminizzle chizzle
D, which has a "or" up in tha test instead of a "and."
16. (D) Da algorithm uses tha binary search tree property n' searches only the
left subtree if target is less than tha current root value, or only tha right subtree
if target is pimped outa than or equal ta tha current root value. In a general binary
tree (i.e., not a funky-ass binary search tree), tha given algorithm may miss tha target. Note
that chizzle E is false; tha postcondizzle specifies dat a TreeNode wit target is
returned, which tha algorithm will do irrespectizzle of tha number of times target
occurs up in tha tree. .
17. (A) Da algorithm is straight-up returnin tha rightmost element of tha tree, which
is not one of tha chizzles. Note dat tha rightmost element of a funky-ass binary search tree
is tha phattest (check it out!), which make A tha dopest chizzle. None of tha other
choices must be true. For example, if tha tree up in chizzle C be lookin like tha following
tree, C is ghon be false.
18. (E) Chizzle A be a inorder traversal yieldin 4251637. Chizzle B be a preorder
traversal: 1245367. Chizzle C be a right-to-Ieft postorder traversal: 7635421.
Choice D be a right-to-Ieft inorder traversal: 7361524. Tryin tha regular postorder
and tha right-to-Ieft preorder traversals (the two remainin possibilities)
does not yield tha required output either.
19. (B) This method numbers all tha leavez of tha tree beginnin wit tha right
subtree. Da startin number given up in dis case is 3. Da rightmost leaf becomes
3, n' leaves is numbered up in ascendin order from right ta left.
20. (C) In tha line x = 1 + whatslt (tree. getLeft 0), 1 be added fo' each recursive
call until tree. getLeft () is null. Right back up in yo muthafuckin ass. Similarly, 1 be added fo' each recursive call
in tha line y = 1 + whatslt(tree.getRightO). Look at a example like the
followin tree:
Here x will end up wit value 1 (two recursive calls plus -1 fo' tha base case),
whereas y will end up wit tha value 2 (three recursive calls plus -1 fo' tha base
case). Da method up in dis case will return 2, tha maximum of x n' y, which is
the level of tha tree.
Answers Explained
21. (C) Da method call f (t) returns tha maximum of tha followin three quantities:
(1) Sum of node heightz of left n' right subtreez of root node t yo. Here 4+ 1 = 5.
(2) Maximum of sum of node heightz of left n' right subtrees fo' any node in
the left subtree of node t.
(3) Maximum of sum of node heightz of left n' right subtrees fo' any node in
the right subtree of node t. This is zero cuz there be no nodes underneath
t . getRight () .
Note dat tha shaded node up in tha left subtree of node t has node height of left
subtree = 3, n' node height of right subtree = 3. No other node up in tha subtree
returns a higher total, so tha method call f (t . git Left 0) returns 6. Right back up in yo muthafuckin ass. Since
max(5, 6, 0) = 6, f(t) returns 6.
22. (B) Each aspect of a postorder traversal is linear, dat is, O( n). In a given traversal,
 Each node is output exactly once, thus printin is O( n ).
 Each if statement is executed once per node, thus testin fo' null is O(n).
 Da total number of calls ta doPostorder is, again, once per node, thus
invokin doPostorder is O(n).
Since each operation of tha method is O( n), tha total run time is O( n ).
471
L.EVEL AB ONLY
..... ,. &lt;~~}
Collections CHAPTER ..::.i \~
472
 Da Java collections API
 Da collections hierarchy
 Collections n' generics
 Collections n' iterators
 Da List<e> intercourse
 Da ArrayList<e> and
LinkedList<e> classes
COLLECTIONS IN JAVA
What Is a Collection?
HASH. There is no definizzle fo' dis wordnobody
knows what tha fuck hash is.
-Ambrose Bierce, Da Devilz Doggtionary {1911}
Chapta Goals
 Da Set<e> intercourse
 Da HashSet<e> and
TreeSet<e> classes
 Da Map<k. v=""> intercourse
 Da HashMap<k. v=""> and
TreeMap<k. v=""> classes
 Run time of list, set, n' map
operations
....... ;:, ...... ;.,.~,.-----
" ~. . ,-' :::r:.....r~~. . ,.... .. :.r;"..... _ ____
A collection be any bunch of objects you can be thinkin of: thugz of a local bridge club,
your CD collection, all book titlez up in tha library, tha moves up in a cold-ass lil chess game, tha flavors
at tha ice cream parlor, a sack of toys. Right back up in yo muthafuckin ass. Some collections is ordered; some is not.
Some allow duplicates; some do not.
Da Collections API
When you write a Java program dat manipulates a cold-ass lil collection, you may use tha Collections
API (Application Programmin Interface), which be a library provided by Java.
Most of tha API is up in java. ut il. This library gives tha programmer access ta prepackaged
data structures n' tha methodz ta manipulate dem wild-ass muthafuckas. Da implementations of
these container classes is invisible n' should not be of concern t~ tha programmer.
Da code works fo' realz. And it is reusable.
All of tha collections classes have tha followin features up in common:
Da Collections Hierarchy
 They is designed ta be both memory n' run-time efficient.
 They provide methodz fo' insertion n' removal of shit (i.e., they can grow
and shrink).
 They provide fo' iteration over tha entire collection.
 In Java 5.0 tha collection classes is generic, which means dat they have type
parameters.
THE COLLECTIONS HIERARCHY
Inheritizzle be a thugged-out definin feature of tha Collections API. Right back up in yo muthafuckin ass. Some of tha core intercourses
that is used ta manipulate tha collections follow. They specify tha operations that
must be defined fo' any container class dat implements dat intercourse.
I
SortedSet
NOTE
Collection
" " List
,I
SortedMap
1. Da diagram shows tha Collection intercourse all up in tha root of tha collections hierarchy.
A Collection is simply a crew of objects called its elements, n' you can put dat on yo' toast. The
Collection intercourse is used ta manipulate collections when maximum generality
is desired, much like Object up in tha hierarchy of classes.
2. Right back up in yo muthafuckin ass. Set n' List is both collections fo' realz. A Set is unordered n' cannot contain
duplicates fo' realz. A List is ordered n' can contain duplicates.
3 fo' realz. A Map aint considered ta be a legit collection n' therefore has its own hierarchy
tree fo' realz. A Map be a object dat maps keys ta joints fo' realz. A Map cannot contain
duplicate keys: each key maps ta exactly one value.
4. Da SortedSet n' SortedMap intercourses is sorted versionz of Set n' Map.
Yo ass don't gotta know all these intercourses fo' tha AP exam. Da only ones you
are sposed ta fuckin know is Set, List, n' Map. Da container classes yo ass is expected
to know is ArrayList, LinkedList, HashSet, TreeSet, HashMap, n' TreeMap. The
diagrams on tha next page show which intercourse is directly implemented by each of
these classes:
473
474
Set
«interface»
/ \
" \
SortedSet \
\
Collection
«interface»
" "
Chapta 11 Collections
List
«interface»
I ,
I ,
I
"
,
\
«interface» \ ArrayList LinkedList
\
11
I
I
I
TreeSet
\
\
\
\
HashSet
Map
«interface»
SortedMap
«interface»
11
I
I
\
\
\
\
\
\
\
\
\
I Tree~ap I I Ha:hMap I
Collections Classes
ArrayList n' LinkedList implement List.
HashSet implements Set.
TreeSet implements SortedSet.
HashMap implements Map.
TreeMap implements SortedMap.
COLLECTIONS AND GENERICS
Da collections classes is generic, wit type parametas (see p. 297). Thus, List<e>
and Set<e> contain elementz of type E, while Map<k, v=""> maps keyz of type K ta joints
of type V.
When a generic class is declared, tha type parameta is replaced by a actu~l object
type. For example,
private LinkedList<clown> clowns;
private Map<clown, circus=""> locations;
Collections n' Iterators
NOTE
1. Da clowns list must contain only Clown objects fo' realz. An attempt ta add a Acrobat
to tha list, fo' example, will cause a cold-ass lil compile-time error.
2. Right back up in yo muthafuckin ass. Since tha type of objects up in a generic class is restricted, tha elements can be
accessed without casting.
3. There is no primitizzle types up in collections classes. To use primitizzle types,
wrappin n' unwrappin must first occur, which be automatically done in
Java 5.0 wit auto-boxin n' -unboxing.
4 fo' realz. All of tha type shiznit up in a program wit generic classes is examined at
compile time fo' realz. Afta compilation tha type shiznit is erased. Y'all KNOW dat shit, muthafucka! This feature
of generic classes is known as erasure. Durin execution of tha program, any
attempt at incorrect castin will lead ta a ClassCastException.
COLLECTIONS AND ITERATORS
Definizzle of a Iterator
An iterator be a object whose sole purpose is ta traverse a cold-ass lil collection, one element
at a time. Durin iteration, tha iterator object maintains a cold-ass lil current posizzle up in the
collection, n' is tha controllin object up in manipulatin tha elementz of tha collection.
Da Iterable<e> Interface
Each of tha generic collection classes serves up a iterator fo' traversal of tha collection.
Each class implements tha Iterable intercourse:
hood intercourse Iterable<e>
{
}
//Returns a iterator over a cold-ass lil collection of elementz of type E.
Iterator<e> iterator();
Da Iterator<e> Interface
Da package java. uti! serves up a generic intercourse, Iterator<e>, whose methodz are
hasNext, next, n' remove fo' realz. A class dat implements Iterator fo' a given collection
can iterate over dat collection, provided tha collection implements Iterable. The
Java Collections API allows iteration over each of its collections classes.
THE METHODS OF Iterator<e>
I boolean hasNext() I
Returns legit if there be a at least one mo' element ta be examined, false otherwise.
IT nextO I
Returns tha next element up in tha iteration. I aint talkin' bout chicken n' gravy biatch. If no elements remain, tha method throws a
NoSuchElementException.
475
476
Use a gangbangin' for-each loop
for accessin and
modifyin objects in
a list. Use a iterator
for removal of
objects.
Chapta 11 Collections
I void remove 0 I
Deletes from tha collection tha last element dat was returned by next. This method
can be called only once per call ta next. Well shiiiit, it throws a IllegalStateException if the
next method has not yet been called, or if tha remove method has already been called
afta tha last call ta next.
Usin a Generic Iterator
To iterate over a parameterized collection, you must bust a parameterized iterator whose
parameta is tha same ol' dirty type.
Example 1
List<string> list = freshly smoked up ArrayList<string>();
&lt; code ta initialize list wit strings&gt;
//Print strings up in list, one per line.
for (Iterator<string> itr = list.iterator(); itr.hasNext();)
System.out .println(itr.next(»;
NOTE
1. Only classes dat implement tha Iterable intercourse can use tha for-each loop.
This is cuz tha loop operates by rockin a iterator. Shiiit, dis aint no joke. Thus, tha loop up in the
above example is equivalent to
for (Strin str : list) fino iterator up in sight!
System.out.println(str);
2. Recall, however, dat a gangbangin' for-each loop cannot be used ta remove elements from
the list. Thus, tha followin example requires a iterator.
Example 2
//Remove all 2-characta strings from strList.
//Precondition: strList initialized wit Strin Objects.
hood static void removeTwos(List<string> strList)
{
}
Iterator<string> itr = strList.iterator();
while (itr.hasNext(»
if (itr.next().length() == 2)
itr.removeO;
Example 3
//Assume a list of integer strings.
//Remove all occurrencez of "6" from tha list.
for (Iterator<string> itr = list.iterator(); itr.hasNext();)
{
}
Strin num = itr.next();
if (num. equals ("6" »
{
}
itr.removeO;
System.out.println(list);
Collections n' Iterators
H tha original gangsta list is 2 6 6 3 5 6 tha output will be
[2, 6, 3, 5, 6]
[2, 3, 5, 6]
[2, 3, 5]
Example 4
//Illustrate NoSuchElementException.
Iterator<sometype> itr = list.iterator();
while (true)
System.out.println(itr.next());
Da list elements is ghon be printed, one per line. Then a attempt is ghon be made ta move
past tha end of tha list, causin a NoSuchElementException ta be thrown. I aint talkin' bout chicken n' gravy biatch. Da loop
can be erected by replacin legit wit i tr . hasNext () .
ExampleS
//Illustrate IllegalStateException.
Iterator<sometype> itr = list.iterator();
SomeType ob = itr.next();
itr. Shiiit, dis aint no joke. remove 0 ;
itr. Shiiit, dis aint no joke. remove 0 ;
Every remove call must be preceded by a next. Da second itr.removeO statement
will therefore cause a IllegalStateException ta be thrown.
NOTE
In a given program, tha declaration
itr = list.iterator();
must be made every last muthafuckin time you need ta initialize tha iterator ta tha beginnin of tha list.
Da Listlterator<e> Interface
Da List collections, ArrayList n' LinkedList, provide a expanded iterator,
Listlterator, dat be a subclass of Iterator. Shiiit, dis aint no joke. Da ListIterator intercourse allows
traversal of tha list up in either direction, as well as pimped outa capabilitizzles fo' modifying
the list. In addizzle ta hasNext, next, n' remove, there be six freshly smoked up methodz in
ListIterator. Shiiit, dis aint no joke. Of these, yo ass is sposed ta fuckin know just two fo' tha AP exam: add
and set.
METHODS add AND set IN Listlterator<e>
I void add(E item) I
Inserts tha specified element tha fuck into tha list. Da insertion point immediately precedes
the next element dat would be returned by a cold-ass lil call ta next, if any yo. H tha list is
empty, tha freshly smoked up element becomes tha sole element up in tha list. Da method throws a
ClassCastException if tha type of tha object added is incompatible wit tha elements
in tha list.
477
478 Chapta 11 Collections
NOTE
A subsequent call ta next would be unaffected by tha freshly smoked up element-the "current"
element becomes tha banged element.
I void set(E item) I
Replaces tha last element returned by next wit tha specified element fo' realz. A call ta set can
only be made if neither remove nor add done been called afta tha last call ta next. The
method throws a IllegalStateException if next has not been called, or if remove or
add done been called afta tha last call ta next.
Usin tha Listlterator<e> Interface
To declare a Listlterator object fo' a list obList of ObjectType, use tha listlterator
method as bigs up:
Listlterator<objecttype> itr = obList.listlterator();
Da elementz of tha list is traversed from beginnin ta end wit dis code:
while (itr.hasNext())
&lt; code wit call ta i tr . next () &gt;
NOTE
Durin iteration, a cold-ass lil container can be modified rockin tha remove, add, n' set methods
of tha iterator. Shiiit, dis aint no joke. Durin iteration, however, you may not modify tha container rockin non.
iterator methodz fo' realz. A ConcurrentModificationException is ghon be thrown. I aint talkin' bout chicken n' gravy biatch. (Yo ass don't
need ta know tha name of dis exception fo' tha AP exam.)
For each example below, assume dat list be a List of Strin objects.
Example 1
//Print elementz of list, 1 per line.
for (Listlterator<string> itr = list.listlterator(); itr.hasNext();)
System.out.println(itr.next());
NOTE
This is essentially tha same code as when Iterator is used.
Example 2
//Add element ta front of list.
Listlterator<string> itr = list.listlterator();
itr.add("55");
System.out.println(list);
If tha input fo' tha list is 3 5 7, tha output is ghon be [55, 3, 5, 7].
Example 3
//Add element ta second slot up in list.
Listlterator<string> itr = list.listlterator()j
Strin element = itr.next()j
itr.add("400");
System.out.println(list)j
THE LiskE&gt; INTERFACE
If tha input fo' tha list is 3 5 7, tha output is ghon be [3, 400, 5, 7].
Example 4
/IReplace each element up in list wit "100".
Listlterator<string> itr = list . listlterator()j
while (itr.hasNext(»
{
}
Strin element = itr.next()j
itr.set("100")j
Example 5
//Illustrate IllegalStateException.
Listlterator<string> itr = list.listlterator()j
itr.set("55")j //error : set must be preceded by next
Each of tha followin code fragments will also cause tha error.
Strin obj = itr .next()j
i tr . remove 0 j
itr.set("55")j Iiset must be directly preceded by next
Strin obj = itr.next()j
itr. Shiiit, dis aint no joke. add("100")'j
itr .set("55")j /Iset must be directly preceded by next
THE List<e> INTERFACE
A class dat implements tha List<e> intercourse be a list of elementz of type E. In a list,
duplicate elements is allowed. Y'all KNOW dat shit, muthafucka! Da elementz of tha list is indexed, wit 0 bein the
index of tha straight-up original gangsta element.
A list allows you to
 Access a element at any posizzle up in tha list rockin its integer index.
 Insert a element anywhere up in tha list.
 Iterate over all elements rockin ListIterator or Iterator.
NOTE
1. Well shiiiit, it is generally mo' run-time efficient ta iterate all up in a list than ta cycle
all up in tha indexes.
2. For two list objects list1 n' list2, list 1. equals (list2) returns legit if and
only if tha lists contain tha same elements up in tha same order n' shit. This is irrespective
of implementation.
479
Use a Listlterator
for replacing
elements up in a list.
Yo ass cannot use a
for-each loop.
480
Da Methodz of List<e>
Here is tha methodz up in tha AP Java subset.
I boolean add(E obj) I
Chapta 11 Collections
Appendz obj ta tha end of tha list fo' realz. Always returns legit (contrast wit add iri Set,
p. 487). Throws a ClassCastException if tha specified element aint of type E.
lint sizeO I
Returns tha number of elements up in tha list.
IE get(int index) I
Returns tha element all up in tha specified index up in tha list.
IE set(int index, E element) I
Replaces item at specified index up in tha list wit specified element. Returns tha element
that was previously at index. Throws a ClassCastException if tha specified element
is not of type E.
I void add(int index, E element) I
Inserts element at specified index. Elements from posizzle index n' higher have 1
added ta they indices. Right back up in yo muthafuckin ass. Size of list is incremented by 1.
IE remove(int index) I
Removes n' returns tha element all up in tha specified index. Elements ta tha right of
posizzle index have 1 subtracted from they indices. Right back up in yo muthafuckin ass. Size of list is decreased by 1.
I Iterator<e> iterator() I
Returns a iterator over tha elements up in tha list, up in proper sequence, startin at the
first element.
I Listlterator<e> listlterator() I
Returns a list iterator over tha elements up in tha list, up in proper sequence, startin at the
first element.
Da ArrayList<e> Class
This be a array implementation of tha List intercourse. Da main difference between
an array n' a ArrayList is dat a ArrayList is resizable durin run time, whereas
an array has a gangbangin' fixed size at construction.
Shiftin of elements, if any, caused by insertion or deletion, is handled automatically
by ArrayList. Operations ta bang or delete all up in tha end of tha list is 0(1). Be aware,
however, dat at some point there is ghon be a resizing; but, on average, over time, an
insertion all up in tha end of tha list is O( 1). This is called amortized constant time, n' will
not be tested on tha AP exam. In general, insertion or deletion up in tha middle of an
ArrayList is O(n), since elements must be shifted ta accommodate a freshly smoked up element
(add), or ta close a "hole" (remove).
THE LiskE&gt; INTERFACE
THE METHODS OF ArrayList<e>
In addizzle ta tha two add methods, n' size, get, set, remove, iterator, and
listlterator, you must know tha followin constructor.
I ArrayList 0 I
Constructs a empty list.
Da followin constructor, which aint up in tha AP subset, be also worth knowing. It
provides neat solutions ta certain problems.
ArrayList(Collection&lt;, biatch? extendz E&gt; c)
Constructs a ArrayList containin tha elementz of c up in tha same order as dem up in c.
Da parameta be a cold-ass lil collection of type E or any type thatz a subclass of E.
NOTE
Each method above dat has a index parameter-add, get, remove, n' set-throws
an IndexOutOfBoundsException if index is outta range. For get, remove, n' set,
index is outta range if
index &lt; 0 I I index &gt;= size()
For add, however, it is OK ta add a element all up in tha end of tha list. Therefore index is
out of range if
index &lt; 0 I I index &gt; size()
Usin ArrayList<e>
Example 1
//Return a ArrayList of random integers from 0 ta 100.
hood static List<integer> getRandomlntList()
{
}
List<integer> list = freshly smoked up ArrayList<integer>();
System.out.print("How tha fuck nuff integers, biatch? Pt II);
int length = IO.readlnt(); //read user input
for (int i = 0; i &lt; length; i++)
{
}
int newNum = (int) (Math.random() * 101);
list.add(new Integer(newNum»;
return list;
NOTE
1. Da variable list is declared ta be of type List<integer> (the intercourse) but
is instantiated as type ArrayList<integer> (the implementation). This has the
advantage of makin tha code applicable ta any List. For example, tha single
change
List<integer> list = freshly smoked up LinkedList<integer>();
will proquce a getRandomlntList method dat creates a linked list of rando~
integers.
481
482
Every call ta remove
must be preceded by
next.
Chapta 11 Collections
2. Da add method up in getRandomIntList is tha List method dat appendz its
parameta ta tha end of tha list.
Example 2
//Swap two joints up in list, indexed at i n' j.
hood static void swap(List<e> list, int i, int j)
{
}
E temp = list.get(i);
list.set(i, list.get(j));
list.set(j, temp);
NOTE
Da swap method can be called wit a ArrayList or a LinkedList-in fact, wit any
list object dat implements List.
Example 3
//Print all negatives up in list a.
//Precondition: a cold-ass lil gotz nuff Integer joints.
hood static void printNegs(List<integer>a)
{
}
System.out.println("Da wack joints up in tha list are: Pt II);
for (Integer i : a)
if (i.intValue() &lt; 0)
System.out.println(i);
Example 4
//Remove all negatives from intList .
//Precondition: intList gotz nuff Integer objects.
hood static void removeNegs(List<integer> intList)
{
}
for (Iterator<integer> itr = intList.iterator(); itr.hasNext();)
if (itr.next().intValue() &lt; 0)
itr. Shiiit, dis aint no joke. remove 0 ;
NOTE
1. In Example 3 a gangbangin' for-each loop is used cuz each element be accessed without
changin tha list fo' realz. An iterator operates unseen up in tha background. Y'all KNOW dat shit, muthafucka! Contrast
this wit Example 4, where tha list is chizzled by removin elements yo. Here an
iterator must be used explicitly.
2. No cast is required fo' i. next 0: It be known ta be of type Integer.
3. To test fo' a wack value, you could compare tha Integer i. next 0 ta another
Integer object, namely one wit value O. This has ta be constructed
with tha expression freshly smoked up Integer(O). Da test up in tha loop then becomes
if (i.next().compareTo(new Integer(O)) &lt; 0)
THE LiskE&gt; INTERFACE
ExampleS
//Change every last muthafuckin even-indexed element of strList ta tha empty string.
//Precondition: strList gotz nuff Strin joints.
hood static void chizzleEvenToEmpty(List<string> strList)
{
}
boolean even = true;
Listlterator<string> itr = strList.listlterator();
while (itr.hasNext())
{
}
itr.nextO;
if (even)
i tr . set ( "" );
even = !even;
NOTE
1 fo' realz. A ListIterator is used cuz tha set method is required: every last muthafuckin second element,
startin wit tha first, must be set ta tha empty strang "".
2. Da loop must start wit a cold-ass lil call ta next cuz every last muthafuckin call ta set must be preceded
by next.
Da LinkedList<e> Class
This be a linked list implementation of tha List intercourse. Da implementation be a
doubly linked list wit references ta tha front n' back of tha list. Da AP Java subset,
however, do not include tha Listlterator methodz dat allow access ta previous
elements, n' you can put dat on yo' toast. This means dat fo' tha AP exam, tha use of tha LinkedList class will be
restricted ta singly linked lists.
Da methodz of LinkedList provide easy as fuck  access ta both endz of tha list. To access
the middle of tha list, either a iterator or tha git n' set methodz of tha List
interface must be used (p. 480).
THE METHODS OF LinkedList<e>
Da followin methodz is up in tha AP Java subset (in addizzle ta add, size, get, set,
iterator, n' listlterator).
I LinkedList 0 I
Constructs a empty list.
I void addFirst(E obj) I
Inserts obj all up in tha front of tha list.
I void addLast (E obj) I
Appendz obj ta tha end of tha list.
I E getFirst 0 I
Returns tha straight-up original gangsta element up in tha list.
483
Every call ta set
must be preceded by
next.
484 Chapta 11 Collections
I E getLast 0 I
Returns tha last element up in tha list.
IE removeFirst() I
Removes n' returns tha straight-up original gangsta element up in tha list.
I E removeLast () I
Removes n' returns tha last element up in tha list.
NOTE
1. If tha list is empty, tha getFirst, getLast, removeFirst, n' removeLast methods
throw a NoSuchElementException.
2. Da followin constructor, which aint up in tha AP subset, be also worth knowmg.
I LinkedList(Collection&lt;, biatch? extendz E&gt; c) I
Constructs a LinkedList containin tha elementz of c up in tha same order as
those up in c. Da objects up in tha Collection parameta iz of any type dat extends
E.
Usin LinkedList<e>
Da syntax fo' rockin a LinkedList is identical ta dat fo' rockin a ArrayList:
 To declare a LinkedList variable, use tha intercourse List on tha left side:
List<e> b = freshly smoked up LinkedList<e>();
 To traverse tha linked list, use Iterator, ListIterator, or a gangbangin' for-each loop.
 When a object is returned from a generic list, no cast is required before invoking
methodz wit dat object.
Freestylin General Code
Wherever possible try ta write code dat is general. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. For example, here be a method that
will work fo' either a ArrayList or a LinkedList of Integer.
IIReturn phattest item up in list.
IIPrecondition: list be a nonempty list of Comparable joints,
II up in dis case, Integers.
hood static Comparable findMax(List<integer> list)
{
}
Iterator<integer> itr = list.iterator();
Comparable max = itr.next(); Ilinitialize max ta first element
while (itr.hasNext())
{
}
Comparable element = itr.next();
if (max.compareTo(element) &lt; 0) Ilif max &lt; element
max = element;
return max;
ArrayList vs. LinkedList
Da above example can be made even mo' general if tha parameta be a List of any
type dat is Comparable. Da code uses a wildcard, which aint gonna be tested on tha AP
exam.
IIReturn phattest item up in list.
IIPrecondition: list be a nonempty list of Comparable joints.
hood static Comparable findMax(List&lt;, biatch? extendz Comparable&gt; list)
{
}
Iterator&lt;, biatch? extendz Comparable&gt; itr = list.iterator();
Comparable max = itr.next(); Pt II initialize max ta first element
while (itr.hasNext())
{
}
Comparable element = itr.next();
if (max.compareTo(element) &lt; 0) Ilif max &lt; element
max = element;
return max;
NOTE
1. Da elementz of tha list must be Comparable so dat tha compareTo method can
be used.
2. In tha initialization of max n' tha assignments ta element, tha object returned
by i tr . next () need not be cast ta Comparable before compareTo can be called:
It be automatically tha declared type.
ArrayList VS. LinkedList
Which implementation should you use?
Here is tha run times fo' tha various operations:
Operation
Insert at front
Insert at end
Delete at front
Delete at end
ArrayList
add (0 , obj)
O(n). Must shift all
elements ta make slot.
add(obj)
O( 1). May, however, need
to resize.
O(n) ta add n elements.
remove (0)
O(n). Must shift all
elements one unit left.
remove(size()-l)
0(1) fo' realz. Adjust sizeO.
LinkedList
addFirst(obj)
O( 1) fo' realz. A constant number
of pointa connections.
addLast(obj)
O( 1) fo' realz. A constant number
of pointa connections.
removeFirst()
O( 1) fo' realz. A constant number
of pointa connections.
remove Last 0
0(1) fo' realz. A constant number
of pointa connections.
Continued on next page
485
486
A set gotz nuff no
duplicates.
Operation
Insert up in middle
Delete up in middle
Change value
in middle
ArrayList
add(index. obj)
O( 1) access ta insertion
point.
O(n) insertion, since
elements ta right of
index must be shifted.
remove (index)
O( 1) access ta element.
O( n ) deletion, since
elements ta right of
index must be shifted.
set (index. obj)
0(1). Fast access.
Chapta 11 Collections
LinkedList
itr.addO
O( n) access ta insertion
point, rockin iterator.
O( 1) insertion.
i tr . remove 0
O(n) access ta insertion
point, rockin iterator.
O( 1) deletion.
itr.set(obj)
O(n) traversal ta locate
element.
Da chizzle of implementation should be driven by tha run-time efficiency of your
particular application. I aint talkin' bout chicken n' gravy biatch yo. Here is some guidelines:
1. For most applications ArrayList is fasta n' shit. This is cuz
 ArrayList has fast access ta any element up in tha list whose index is known,
while Linked~ist requires a O( n) traversal ta reach a interior element.
 LinkedList need ta allocate a node fo' each element up in tha list, whereas
ArrayList do not.
2. There is two cases up in which you should consider rockin LinkedList:
 If yo' application involves tha frequent addizzle of elements ta tha front
of tha list. This is 0(1) fo' LinkedList but O(n) fo' ArrayList, which
requires copyin n' shiftin elements fo' insertion.
 If you must iterate over tha list, deletin nuff elements as you go. This is
O( n ) fo' LinkedList, a single traversal wit a cold-ass lil constant number of pointer
connections fo' each deletion. I aint talkin' bout chicken n' gravy biatch. For ArrayList, however, tha operation is
0(n2): For each deleted element, tha entire right side of tha list must be
shifted.
3. Da LinkedList methodz addFirst, getFirst, removeFirst, removeLast,
addLast, n' git Last make it convenient ta bust a LinkedList implementation
for any program dat accesses only tha endz of tha list fo' realz. A phat example
is implementin a queue. What you lose is tha advantage of general code-you
can no longer easily switch implementations if you decizzle ArrayList will be
faster.
THE Set<e> INTERFACE
A set be a cold-ass lil collection dat has no duplicate elements, n' you can put dat on yo' toast. Well shiiiit, it may contain a null element. The
Set intercourse is based on tha scam of a mathematical set.
A set allows you to
 Insert a nonduplicate element tha fuck into tha set.
THE SekE&gt; INTERFACE
 Remove a element from tha set.
 Test if a given element is up in tha set.
 Iterate over tha elements rockin Iterator.
A class dat implements tha Set<e> intercourse be a set of elementz of type E. Da two
Set<e> implementations up in tha Collections API are
 HashSet<e>, which stores its elements up in a hash table (see p. 536).
 TreeSet<e>, which stores its elements up in a funky-ass balanced binary search tree.
NOTE
Two Set objects is equal if n' only if they contain tha same elements, irrespectizzle of
implementation.
Da Methodz of Set<e>
Here is tha methodz up in tha AP Java subset:
I boolean add(E obj) I
Addz obj ta tha set n' returns legit if obj was not already up in tha set. Leaves tha set
unchanged n' returns false if obj was already up in tha set.
I boolean gotz nuff(Object obj) I
Returns legit if tha set gotz nuff obj, or if obj is null n' tha set gotz nuff null. Otherwise,
the method returns false.
I boolean remove(Object obj) I
Removes obj from tha set n' returns legit if obj was up in tha set. Leaves tha set unchanged
and returns false if obj was not up in tha set.
lint sizeO I
Returns tha number of elements up in tha set.
I Iterator<e> iterator() I
Returns a iterator over tha elements up in tha set.
Da HashSet<e> Class
Da HashSet<e> class implements tha Set<e> intercourse. Items is not stored up in any
particular order n' therefore do not need ta be Comparable.
Da methodz of HashSet up in tha AP Java subset is tha same methodz as dem given
for tha Set intercourse: add, gotz nuff, remove, size, n' iterator fo' realz. Additionally, you
should know dat tha iterator returns tha elements up in no particular order n' do not
guarantee dat tha order will stay tha same over time.
Yo ass should also know tha default constructor fo' HashSet objects:
487
Use a HashSet for
fast access and
removal of elements.
488
Use a TreeSet if the
elements must be
sorted.
I HashSetO I
Constructs a empty set.
Chapta 11 Collections
Da followin constructor, which aint up in tha AP subset, be also worth knowing:
I HashSet(Collection&lt;, biatch? extendz E&gt; c) I
Constructs a freshly smoked up HashSet containin tha elements up in Collection c. Da freshly smoked up set
gotz nuff no duplicates, even though c may contain duplicates. Da parameta be a
collection of type E or any type thatz a subclass of E.
Da HashSet class is implemented wit a hash table fo' realz. As such it offers 0(1) run times
for tha operations add, remove, n' gotz nuff.
Da TreeSet<e> Class
Da TreeSet<e> class implements tha SortedSet<e> intercourse n' guarantees dat the
sorted set is ghon be up in ascendin order, as determined by compareTo. This means dat the
itemz of a TreeSet is Comparable. They must also be mutually comparable, which
means dat you can compare dem wit each other n' shit. (For example, you can't compare
a Strin wit a Integer!)
As wit HashSet, tha TreeSet methodz up in tha AP Java subset is dem dat were
specified fo' tha Set intercourse: add, gotz nuff, remove, size, n' iterator. Shiiit, dis aint no joke. Note that
the iterator fo' a TreeSet always returns tha elements up in ascendin order.
Yo ass should also know tha default constructor fo' TreeSet objects:
I TreeSet () I
Constructs a empty set.
Da followin constructor, which aint up in tha AP subset, be also worth knowing:
I TreeSet (Collection&lt;, biatch? extendz E&gt; c) I
Constructs a freshly smoked up set, sorted up in ascendin order, containin tha elementz of c without
duplicates. Da elementz of c must be mutually comparable, n' they type is E or any
type dat extendz E.
Da TreeSet class is implemented wit a funky-ass balanced binary search tree. Well shiiiit, it therefore
provides O(log n) run time fo' tha operations add, remove, n' gotz nuff.
Examplez wit HashSet<e> n' TreeSet<e>
Example 1
Set<string> set = freshly smoked up HashSet<string> 0 ;
set.add(IMary") ;
set.add(IJoan")j
set.add(IMarY")j
set. add (IIDennis ") j
set.add(IAlan")j
System. out. println ("Size of set is Pt II + set. size 0) j
THE SekE&gt; INTERFACE 489
for (Strin str: set)
System.out.print(str + Pt II Pt II);
System.out.println()j
Set <string> tSet = freshly smoked up TreeSet<string>(set)j
for (Strin str: tSet)
System.out.print(str + Pt II lI)j
System.out.println()j
Iterator<string> itr = tSet.iterator()j
while (itr.hasNext(»
if(itr.next().equals(IJoan"»
itr.removeO j
System.out.println(tSet)j
Da output fo' dis code fragment is
Size of set is 4
Joan Mary Dennis Alan
Alan Dennis Joan Mary
[Alan, Dennis, Mary]
NOTE
1 fo' realz. Again note dat tha collection variablez set n' tSet is declared wit they intercourse
type, Set, n' constructed wit they actual type (HashSet or TreeSet).
This maintains flexibilitizzle ta chizzle implementations by just changin tha constructor
used.
2. Recall dat a set do not allow duplicates. Thus, only one Pt II Mary Pt II was added.
3. Da names up in tha second line of output could done been printed up in any order.
4. Tossin tha elementz of a HashSet tha fuck into a TreeSet gives a quick method of getting
the elements up in sorted order n' shit. But fuck dat shiznit yo, tha word on tha street is dat tha constructor used aint up in the
AP Java subset. On tha exam, tha statement
Set <string> tSet = freshly smoked up TreeSet<string>(set)j
is likely ta be replaced wit a statement like this:
Set <string> tSet = copySetToTreeSet(set)j
where copySetToTreeSet is busted lyrics bout as a method dat returns a TreeSet containing
all tha elementz of Set set.
S. To access each element of a set without changin tha set, bust a gangbangin' for-each loop.
But fuck dat shiznit yo, tha word on tha street is dat if tha set may be chizzled durin tha iteration, a iterator must be
used.
6. Da last line of code,
System.out.println(tSet);
uses a toStrin method ta produce tha last line of output.
Example 2
~emove duplicates from a ArrayList.
490 Chapta 11 Collections
1* Precondition: ArrayList list may contain duplicate items.
* Postcondition: Returns list wit all duplicates removed.
*1
hood static ArrayList<string> removeDups(ArrayList<string> list)
{
}
Set<string> set = freshly smoked up HashSet<string>(list)i
ArrayList<string> newList = freshly smoked up ArrayList<string>(set)i
return newListi
If tha list parameta is pimped from dis file
farmer
cat
hen
apple
pear
baboon
cat
hen
cat
then tha followin list of lyrics without duplicates is produced
[farmer, pear, apple, baboon, hen, cat]
NOTE
1. If tha elements up in tha returned ArrayList need ta be sorted, replace tha first
line of tha method with
Set<string> set = freshly smoked up TreeSet<string>(list)i
Da line
ArrayList<string> newList = freshly smoked up ArrayList<string>(set)i
receives tha elements up in tha same order dat they bein stored-for TreeSet
this is sorted up in ascendin order.
2. Da removeDups method can be used up in a program as bigs up:
ArrayList<string> lyrics = getWordList()i
wordz = removeDups(words)i
Ilread up in lyrics
3. Example 2 uses constructors fo' ArrayList, HashSet, n' TreeSet dat is not
in the.AP Java subset. (I'o big up tha same result without dem constructors,
you would need ta use iterators ta copy one collection ta another.) If these
constructors is used on tha AP exam, tha statements
Set <string> set = freshly smoked up HashSet<string>(list)i
ArrayList<string> newList = freshly smoked up ArrayList<string>(set)i
will be straight-up explained or, alternatively, replaced wit methodz dat big up the
same result:
Set <string> set = copyListToHashSet(list)i
ArrayList<string> newList = copySetToArrayList(set)i
where copyListToHashSet is busted lyrics bout as a method dat returns a HashSet containing
all tha elementz of ArrayList list, n' copySetToArrayList returns
an ArrayList containin all tha elementz of Set set.
THE SekE&gt; INTERFACE
Example 3
Consider a ArrayList of lyrics, lyrics. Yo ass need ta obtain each of tha following:
Da total number of lyrics.
Da number of distinct lyrics (i.e., don't count any duplicates).
A list of lyrics dat was duplicates (don't list any mo' than once!).
Findin tha total number of lyrics is trivial. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Right back up in yo muthafuckin ass. Since lyrics be a ArrayList, you can
simply access its size:
int total = lyrics.size();
To find tha number of distinct lyrics, you can use tha removeDups method of the
previous example:
ArrayList<string> noDups = removeDups(words);
int numDistinctLyrics = noDups.size();
To git a list of duplicate lyrics, without listin any mo' than once, suggests using
a set of duplicates yo. How tha fuck can you generate dis set?
Recall dat tha add method returns false if tha set already gotz nuff tha element you
are tryin ta add. Y'all KNOW dat shit, muthafucka! This gives a way ta spot dem duplicates. Yo ass can iterate through
words, tossin each word tha fuck into a set. When you spot a thugged-out duplicate, add it ta tha set of
duplicates.
1* Precondition: ArrayList list may contain duplicate items.
* Postcondition: Returns set of duplicates contained up in list.
* Returns a empty set if there was no duplicates.
*1
hood static HashSet<string> getDuplicates(List<string> list)
{
}
Set <string> hSet = freshly smoked up HashSet<string>();
Set<string> duplicates = freshly smoked up HashSet<string>();
for (Strin str: list)
if (!hSet.add(str))
duplicates.add(str);
return duplicates;
If tha List of lyrics is pimped from dis file
farmer
cat
hen
apple
pear
cat
cat
farmer
hen
then tha set of duplicates produced is
[farmer, cat, hen]
491
492
In a map, each key
can occur only once.
Chapta 11 Collections
Usin HashSet n' TreeSet
 If orderin of elements is blingin, use TreeSet.
 If orderin of elements aint blingin, use HashSet cuz
the run time of tha operations is faster.
 Afta bustin a iterator fo' either Set implementation,
don't modify tha set wit any method other than
i tr . remove (). Yo ass will generate a error if you do.
 Da set implementations do not allow duplicates. Two objects
el n' e2 is duplicates if el. equals (e2) is true, so for
user-defined classes you need ta override tha default equals
and hashCode methodz ta git tha erect behavior. Shiiit, dis aint no joke. Remember
two objects dat is equal must have tha same hashCode
(see p. 227). If you do not do dis erectly, you could have
duplicate elements dat is not treated as duplicates!
THE Kap<k, v=""> INTERFACE
A map be a cold-ass lil collection of key-to-value mappings, where both key n' value can be any
object fo' realz. A map cannot contain duplicate keys, which means dat each key maps to
exactly one value. Different keys, however, can map ta tha same value. Note dat the
"value" can itself be a cold-ass lil collection.
Da Map intercourse allows you to
 Insert a key/value pair tha fuck into tha map.
 Retrieve any value, given its key.
 Remove any key/value pair, given its key.
 Test if a given key is up in tha map.
 View tha elements up in tha map. (Da intercourse serves up three different ways to
view tha collection: tha set of keys, tha set of joints, n' tha set of key/value
mappings. Da AP Java subset requires dat you know just one of these, tha set
of keys, rockin tha keySet method.)
 Iterate over tha mappin elements, rockin Iterator. Shiiit, dis aint no joke. (Da intercourse allows iteration
over keys, joints, or key/value pairs. Yo ass is required ta know iteration
over keys only. Right back up in yo muthafuckin ass. See Iteratin over Maps on p. 494.)
Da two Map<k, v=""> implementations up in tha AP Java subset is HashMap<k, v=""> and
TreeMap<k, v="">.
Da Methodz of Kap<k, v="">
Here is tha methodz up in tha AP Java subset:
THE Map<k, v=""> INTERFACE
Iv put(K key, V value) I
Associates key wit value n' bangs tha pair up in tha map. If tha map already contained
a mappin fo' dis key, tha oldschool value is replaced. Y'all KNOW dat shit, muthafucka! Da method returns either
the previous value associated wit key, or null if there was no previous value fo' this
key. Throws a ClassCastException if tha type of tha specified key or value prevents
it from bein stored up in dis map.
IV get(Object key) I
Returns tha value associated wit key. Returns null if tha map gotz nuff no mapping
for dis key. Note dat a return value of null indicates one of two thangs:
1. Da map contained no mappin fo' key.
2. This key was explicitly mapped ta null.
Da gotz nuffKey method can be used ta distinguish these cases.
IV remove(Object key) I
Removes tha mappin fo' key from dis map, if present. Returns tha previous value
associated wit key, or null if there was no mappin fo' key. Note dat a return value
of null may also indicate dat dis key was previously mapped ta a value of null.
I boolean gotz nuffKey(Object key) I
Returns legit if tha map gotz nuff a mappin fo' key, false otherwise.
lint sizeO I
Returns tha number of key/value mappings up in tha map.
Iset<k> keySet() I
Returns tha set of keys contained up in tha map.
Da HashMap<k, v=""> Class
Da HashMap<k, v=""> class implements tha Map<k, v=""> intercourse wit a hash table. There
is no particular orderin of elements n' no guarantee dat any given orderin stays
constant over time. Da class permits null joints n' tha null key.
HashMap serves up O( 1) run times fo' tha git n' put operations. This assumes that
the keys is uniformly distributed across tha hash table. There is two parametas that
affect tha performizzle of HashMap:
 Initial capacity: tha number of slots fo' keys up in tha table (called buckets).
 Load factor: how tha fuck full tha table be allowed ta git before its capacitizzle is increased.
(Da default load factor of 0.75 offers a phat tradeoff between time n' space
efficiency.)
Yo ass won't be tested on these detailz of tha implementation yo, but they is helpful to
understand how tha fuck tha class works.
493
Use a HashMap for
fast insertion and
retrieval of elements.
494
Use a TreeMap if the
key set must be
sorted.
Chapta 11 Collections
Da methodz of HashMap up in tha AP Java subset is tha same methodz as dem given
for tha Map intercourse: put, get, remove, gotz nuffKey, size, n' keySet. Yo ass should
also know tha followin default constructor fo' HashMap objects:
I HashMapO I
Constructs a empty map.
Da followin constructor, which aint up in tha AP subset, be also worth knowing:
HashMap(Map&lt;, biatch? extendz K, , biatch? extendz v&gt; m)
Constructs a freshly smoked up HashMap wit tha same mappings as m. Da keys up in tha parameta m
can be any type dat extendz K. Da joints can be any type dat extendz v.
Da TreeMap<k, v=""> Class
Da TreeMap<k, v=""> class implements tha SortedMap<k, v=""> intercourse rockin a funky-ass balanced
binary search tree. Da class guarantees ascendin key order based on tha orderin of
the key class. TreeMap guarantees O(log n) performizzle fo' tha gotz nuffKey, get, and
put operations.
Da operations fo' TreeMap dat you should know is dem busted lyrics bout fo' tha Hap
interface: put, get, remove, gotz nuffKey, size, n' keySet fo' realz. Additionally, you should
know tha followin default constructor fo' TreeHap objects:
I TreeMap () I
Constructs a empty map.
Da followin constructor, which aint up in tha AP subset, be also worth knowing:
TreeMap(Map&lt;, biatch? extendz K, , biatch? extendz V&gt; m)
Constructs a freshly smoked up map wit tha same mappings as tha given map, sorted up in ascending
order of keys. Well shiiiit, it assumes dat all possible pairz of keys is mutually comparable.
Iteratin over Maps
Da AP Java subset do not include a iterator method fo' tha Hap intercourse. This
suggests dat yo big-ass booty is ghon not be required ta iterate over mappings.
Yo ass are, however, sposed ta fuckin be able ta iterate over sets.
Example 1
To access tha set of keys up in map but not remove any of them, bust a gangbangin' for-each loop:
for (KeyType key: map.keySet(»
System.out.println(key);
Example 2
To filta tha map based on some property of its keys, use a iterator:
THE Map<k, v=""> INTERFACE
for (1terator<keytype> i = map.keySet().iterator(); i.hasNext();)
if (i.next().isBad(»
i.removeO;
NOTE
1. Example 1 will print up tha keys only fo' map. If map iz of type HashMap, the
keys will step tha fuck up in some unknown order n' shit. If map be a TreeMap, tha keys will be
printed up in ascendin order.
2. Da loop up in Example 1 causes tha keys ta be printed one per line. Da statement
System.out.println(map.keySet(»;
would produce tha keys printed on one line.
3. In Example 2, whenever i . remove () is called, tha correspondin mappin will
be removed from tha map.
4 fo' realz. As wit all tha collections so far, no outsid‚¬ modification be allowed durin an
iteration.
5. Da Map intercourse allows iteration over tha set of keys, tha set of joints, and
the set of key/value pairs. Da operations dat support tha latta two types of
iteration is not up in tha AP Java subset.
Examplez wit HasbKap<ic, v=""> n' TreeMap<ic, v="">
Example 1
Initialize data up in a map.
Map<string, employee=""> hommieMap = freshly smoked up HashMap<string, employee="">();
for (int i = 1; i &lt;= RUM_EMPLOYEES; i++)
{
}
Employee emp = freshly smoked up Employee();
emp.setName( ... );
emp.setSalary( ... );
Iideclare a freshly smoked up Employee
Iiset tha Employeez attributes
II
emp.setID("E" + i); Pt II
employeeMap.put(emp.get1D(), emp); Iladd hommie ta the
Ilmap rockin 1D as tha key
System.out.println(employeeMap.get("E4"»; Iidisplay tha hommie
Ilwhose key is E4
NOTE
1. Both tha key n' value must be objects, n' you can put dat on yo' toast. Da hommie ID be a Strin object;
the correspondin value be a Employee.
2. Well shiiiit, it is common practice ta use one of a objectz attributes as a key up in a map.
Yo ass must be careful, however, dat tha key is unique. For example, rockin an
employeez name as tha key would be problematic: Two different hommies
with tha same name could not exist up in tha same mapping!
495
496 Chapta 11 Col/ections
Example 2
Map<string, string=""> h = freshly smoked up HashMap<string, string="">();
h.put("Othello" , "green");
h.put("Macbeth", "red");
h.put("Hamlet", "blue");
if (!h.gotz nuffKey("Lear"»
h.put("Lear", "black");
Map<string, string=""> t = freshly smoked up TreeMap<string, string="">(h);
System.out.println(h.keySet(»; Ilprint HashMap keys
System.out.println(t.keySet(»; Ilprint TreeMap keys
Hustlin dis code segment produces tha followin output:
[Othello, MacBeth, Hamlet, Lear]
[Hamlet, Lear, MacBeth, Othello]
NOTE
1. Da keys is ordered fo' tha TreeMap. They is up in no particular order fo' the
HashMap.
2. To print tha set of joints, you would need ta use tha Map method joints, which
is not up in tha AP Java subset. Yo ass can print tha set of key/value pairs fo' a Map
m wit tha statement
System.out.println(m);
3. Da statement
Map<string, string=""> t = freshly smoked up TreeMap<string, string="">(h);
uses a cold-ass lil constructor dat aint up in tha AP subset. On tha AP exam, tha statement
is likely ta be given as bigs up:
Map<string, string=""> t = copyMapToTreeMap(h);
where copyMapToTreeMap is busted lyrics bout as a method dat returns a TreeMap containing
all tha elementz of HashMap h.
Example 3
Use a HashMap ta record tha frequency of each word up in a input file.
1* Da WordFreqs class represents a mappin of lyrics up in a text
* file ta they frequencies.
*1
hood class WordFreqs
{
private Map<string, integer=""> m;
1* default constructor *1
hood WordFreqs()
{
}
m = freshly smoked up HashMap<string, integer="">(); Iluse TreeMap for
II sorted output
loadMap(m);
THE Map<k, v=""> INTERFACE 497
}
/* Smoke a HashMap of lyrics from input file.
* Each key be a lowercase word.
* Each value is tha frequency of tha correspondin word. Y'all KNOW dat shit, muthafucka! */
private void loadMap(Map<string, integer=""> m)
{
}
&lt; code ta open input file fo' reading&gt;
while « there be still lyrics up in input file &gt; )
{
}
Strin word = &lt; next word up in file &gt;
//Git Integer value up in Map m associated wit word.
Integer i = m.get(word);
if (i == null) //new word found
m.put(word, freshly smoked up Integer(1»;
else //update frequency fo' existin word
m.put(word, freshly smoked up Integer(i.intValue() + 1»;
&lt; close file&gt;
/* Print word frequencies ta screen, line by line. */
hood void printFrequencies()
{
}
System.out.println("Word frequencies: Pt II);
for (Strin word: m.keySet(»
System.out.println(word + Pt II Pt II + m.get(word»;
System.out.println();
/* Print word frequency mappin ta screen, on one line. */
hood void printFrequencyMap()
{
}
System.out.println("Word frequencies: Pt II);
System.out.println(m);
System.out.println();
/* Print lyrics ta screen. I aint talkin' bout chicken n' gravy biatch. */
hood void printKey~et()
{
}
System.out.println("Distinct lyrics up in file were: Pt II);
System.out.println(m.keySet(»;
System.out.println();
Here be a program dat tests tha WordFreqs class:
hood class WordFreqMain
{
}
hood static void main(String[] args)
{
}
WordFreqs freqs = freshly smoked up WordFreqs();
freqs.printFrequencies();
freqs.printKeySet();
freqs.printFrequencyMap();
498 Chapta 11 Collections
When tha input file is
apple pear apple orange pear grape orange apple
the followin output is obtained:
Word frequencies:
orange 2
pear 2
apple 3
grape 1
Dis.tinct lyrics up in file were
[orange, pear, apple, grape]
Word frequencies:
{orange=2, pear=2, apple=3, grape=l}
NOTE
Da while loop up in tha loadMap method can be freestyled up in a simpla form rockin the
auto-boxin n' -unboxin feature of Java 5.0. (This feature aint gonna be tested on the
AP exam yo, but you can certainly use it up in yo' lyrics ta tha free-response thangs.)
while « there be still lyrics up in input file&gt; )
{
Strin word = &lt; next word up in file&gt;
Integer i = m.get(word);
if (i == null) //new word found
m.put(word, 1);
else //update frequency fo' existin word
m.put(word, i + 1);
}
M ...... z . ,. , lilliE. !I A! nr _
RUN TIME OF SET AND MAP OPERATIONS
Data
Structure
HashSet
TreeSet
HashMap
TreeMap
Method RunTime Comment
add (x) Stored up in a hash table.
remove (x)
gotz nuff (x)
add (x)
remove (x)
gotz nuff (x)
put (key,x)
get (key)
remove (key)
gotz nuffKey(key)
put (key,x)
get (key)
remove (key)
gotz nuffKey(key)
0(1)
O(logn)
0(1)
O(logn)
Assumes uniform
distribution of elements.
Stored up in a funky-ass balanced binary search tree.
Keys stored up in a hash table.
Keys stored up in a funky-ass balanced
binary search tree.
Run Time of Set n' Map Operations
_________________._ iWIIdilor."'ViU .illloJ"Slll_DSW.3a:_~ ______
Chapta Summary ______________________r r::tST7:""_ _II_ ______
Be familiar wit lists, sets, n' maps, n' they implementations up in tha Java API
library. In particular, you should know tha methodz of tha AP Java subset fo' the
ArrayList<e>, HashSet<e>, TreeSet<e>, HashMap<k. v=""> n' TreeMap<k. v=""> classes.
Yo ass should know what tha fuck type of application calls fo' tha use of a list, set, or map,
and you should be able ta write code dat uses each of these data structures. Know the
big-O run time fo' each method used up in manipulatin a cold-ass lil collection.
Yo ass should be able ta use iterators ta traverse each of these collections, n' up in particular,
you should be familiar wit tha AP Java subset methodz of tha Iterator<e>
and ListIterator<e> intercourses.
When traversin a ArrayList:
 Use a gangbangin' for-each loop ta access each element without changin it, or ta modify
each object up in tha list rockin a mutator method.
 Use a Iterator ta remove elements.
 Use a Listlterator ta replace elements.
499
500 Chapta 11 Col/ections
MULTIPLE-CHOICE QUESTIONS ON COLLECTIONS
For additionizzle thangs on tha ArrayList class, peep Thangs 22-28 up in Chapta 6.
1. Which be a legit statement bout tha collections classes?
(A) ArrayList n' LinkedList extend List.
(B) HashSet n' TreeSet implement HashMap n' TreeMap, respectively.
(C) TreeMap n' HashMap implement Map.
(0) TreeSet implements both Set n' Tree.
(E) TreeSet extendz HashSet.
2. Which of tha followin erectly lists all tha elements up in a set declared. as
HashSet<someclass> h, biatch? Yo ass may assume dat SomeClass has a toString
method.
I fo' (Listlterator<someclass> i = h.listlterator(); i.hasNext();)
System. out. println (i. next 0 + Pt II ");
II fo' (Iterator<someclass> itr = h.iterator(); itr.hasNext();)
System. out. println (i tr . next 0 + Pt II Pt II);
III fo' (SomeClass element : h)
System.out.println(element + Pt II Pt II);
(A) I only
(B) Pt II only
(C) Pt III only
(0) Pt II n' Pt III only
(E) I, Pt II, n' Pt III
3. Which be a cold-ass lil erect description of tha run timez of tha given operation for
(1) TreeSet n' (2) HashSet?
(A) Insertin a element (add): (1) 0(1) (2) 0(1)
(B) Insertin a element (add): (1) 0(1) (2) O(logn)
(C) Removin a element (remove): (1) O(logn) (2) O(n)
(0) Removin a element (remove): (1) O(logn) (2) 0(1)
(E) Testin if a element is in
the set (gotz nuff): (1) O(n) (2) O(n)
4 fo' realz. A collection of Comparable objects is ta be maintained up in sorted ascendin order.
Da collection can contain duplicates. Individual elements up in tha collection will
be updated frequently. There is ghon be no deletion of elements, n' infrequent
additionz of freshly smoked up elements, n' you can put dat on yo' toast. Da dopest implementation fo' dis collection is
(A) An ArrayList
(B) A LinkedList
(C) A TreeSet
(0) A HashSet
(E) A TreeMap
Multiple-Choice Thangs on Collections
5. Consider a ArrayList list of Student objects, n' you can put dat on yo' toast. Which of tha followin erectly
addz a Student s at posizzle insertPos. Yo ass may assume dat s is initialized,
and dat insertPos iz of type int n' is up in bounds.
I list.add(insertPos, s)
IT fo' (int i = list.size()j i &gt;= insertPosj i--)
list[i+l] = list[i]j
list[insertPos] = Sj
list. sizeO++j
ITI Listlterator<student> itr = list.listlterator()j
int index = OJ
while (index != insertPos)
{
itr.nextO j
index++j
}
itr.add(s)j
(A) I only
(B) IT only
(C) monly
(D) I n' m only
(E) IT n' m only
6. Consider method replace below:
1* Precondition: List<e> L be a list of objects, a shitload of which
* could be null.
* Postcondition: All occurrencez of val is replaced
* wit newVal, includin if val is null. *1
hood static void replace(List<e> L, E val, E newVal)
{
}
for (Listlterator<e> i = L.listlterator()j i.hasNext()j)
if (val.equals(i.next(»)
i. set (newVal) j
Which is legit bout tha replace method?
(A) It always works as specified.
(B) It may cause a NullPointerException ta be thrown.
(C) It may cause a IllegalStateException ta be thrown.
(D) It may cause a NoSuchElementException ta be thrown.
(E) It aint NEVER gonna work as specified; it will always cause a exception ta be
thrown.
7. Consider a map m, where m iz of type HashMap or TreeMap. Right back up in yo muthafuckin ass. Suppose sl n' s2 are
both sets, of type HashSet or TreeSet, where sl is tha set of keys up in m, n' s2 is
the set of correspondin joints up in m. Which must be true?
(A) s1. size 0 &gt; s2. size 0
(B) sl.size() &gt;= s2.size()
(C) sl.size() =2 s2.size()
(D) sl.size() &lt; s2.size()
(E) ~l.size() &lt;= s2.size()
501
502 Chapta 11 Collections.
8. Refer ta tha method chizzle Even below.
1* Precondition: ArrayList<integer> a cold-ass lil gotz nuff at least 1 element.
* Postcondition: Every even-indexed element gotz nuff O. i.e .
* elements wit index 0.2.4 ... contain O. *1
hood static void chizzleEven(ArrayList<integer> a)
{
}
boolean even = true;
Listlterator<integer> itr = a.listlterator();
while (itr.hasNext(»
{
}
if (even)
itr.set(new Integer(O»j
itr.nextO;
even = !even;
Which statement is legit bout chizzleEven?
(A) It will work as intended fo' any ArrayList a.
(B) It will throw a IllegalStateException fo' every last muthafuckin ArrayList a.
(C) It will throw a IllegalStateException only if ArrayList a has a even
number of elements.
(0) It will throw a IllegalStateException only if ArrayList a has a odd
number of elements.
(E) It will throw a IllegalStateException only if ArrayList a has fewer
than three elements.
Multiple-Choice Thangs on Collections
9. Consider tha max method below, which is intended ta find tha phattest element in
a set.
1* Precondition: s be a nonempty set of Strin objects.
* Postcondition: Returns phattest element up in s. *1
hood static Comparable max(Set<string> s)
{
}
Iterator<string> itr = s.iterator()j
1* codetofind maxValue *1
return maxValuej
Which replacement fo' 1* code ta find maxValue *1 achieves tha desired postcondition?
I Strin maxValue = itr.next()j
while (itr.hasNext(»
{
}
Strin current = itr.next()j
if (maxValue.compareTo(current) &lt; 0)
maxValue = currentj
II Comparable maxValue = itr.next()j
while (itr.hasNext(»
{
}
Comparable current = itr.next()j
if (maxValue.compareTo(current) &lt; 0)
maxValue = currentj
III Comparable maxValue = itr.next()j
while (itr.hasNext(»
{
}
Strin current = itr.next()j
if (maxValue.compareTo(current) &lt; 0)
maxValue = currentj
(A) I only
(B) Pt II only
(C) monly
(0) Pt II n' m only
(E) I, ll, n' m
503
504 Chapta 11 Collections
10. Consider a gangbangin' findShortStrings method dat examines tha Strin objects up in an
ArrayList<string> n' creates a set of strings whose length is less than five.
1* Precondition: list be a nonempty ArrayList of strings.
* Postcondition: Returns a set of strings whose length is less
* than 5.
*/
hood static Set <string> findShortStrings(ArrayList<string> list)
{
}
Set <string> strSet = freshly smoked up HashSet<string>()i
Iterator<string> itr = list.iterator()i
while (itr.hasNext(»
{
}
if (itr.next().length() &lt; 5)
strSet.add (itr.next(»i
return strSeti
Which is legit bout findShortStrings?
(A) It be unlikely ta work as intended.
(B) It will always work as intended.
(C) It will work as intended whenever list gotz nuff a even number of elements.
(0) It will work as intended whenever list gotz nuff a odd number of elements.
(E) It may throw a IllegalStateException.
11. Consider tha followin code segment:
List<integer> a = freshly smoked up ArrayList<integer>()i
Set<integer> t = freshly smoked up TreeSet<integer>()i
for (int i = 10; i &gt;= 1; i--)
a.add(new Integer(i * i»i
for (int i = Oi i &lt; a.size()i i++)
{
}
Integer intObj = a.get(i)i
int val = (intObj.intValue(» % 3;
t.add(new Integer(val»;
System.out.println(t);
What tha fuck iz ghon be output as a result of executin dis segment?
(A) [1, 0, 1, 1, 0, 1, 1, 0, 1, 1]
(B) [1, 1, 0, 1, 1, 0, 1, 1, 0, 1]
(C) [0, 0, 0, 1, 1, 1, 1, 1, 1, 1]
(0) [1, 0]
(E) [0, 1]
Multiple-Choice Thangs on Collections
12 fo' realz. Assume dat list be a array of lowercase lyrics:
String[] list = {"salad", "banana", "lettuce", "beef", "banana",
1* mo' lyrics */}
What do dis code segment do?
hood static final Integer ONE = freshly smoked up Integer(l);
Map<string, integer=""> m = freshly smoked up HashMap<string, integer="">();
for (int i = 0; i &lt; list.length; i++)
{
}
Integer num = m.get(list[i]);
if (num == null)
m.put(list[i], ONE);
else
m.put(list[i], freshly smoked up Integer(num.intValue() + 1»;
(A) It produces up in m a cold-ass lil count of tha distinct lyrics up in tha list.
(B) It produces a table dat maps each word up in tha list ta its posizzle up in tha list.
(C) It produces a alphabetized list of tha lyrics up in tha list n' maps each word
to its posizzle up in tha list.
(0) It produces a gangbangin' frequency table dat maps each word up in tha list ta tha number
of times it occurs up in tha list.
(E) It searches list fo' dem lyrics dat is already up in m. When it findz a word
in m, it thugged-out shiznit tha frequency fo' dat word.
13. Which of tha followin erectly removes tha straight-up original gangsta k elements from LinkedList
L, biatch? Yo ass may assume dat 0 :::: k &lt; L. size O.
I int count = 1;
ListIterator<elementtype> itr = L.listIterator();
while (itr.hasNext() tt count &lt;= k)
{
}
itr.removeO;
count++;
II int count = 1;
Iterator<elementtype> itr = L.iterator();
while (count &lt;= k)
{
}
itr.nextO;
itr.removeO;
count++j
III fo' (int i = 1; i &lt;= k; i++)
L.removeFirst()j
(A) I only
(B) Pt II only
(C) illonly
(0) I n' ill only
(E) Pt II n' ill only
505
506 Chapta 11 Collections
14 fo' realz. A certain LinkedList L may contain duplicates. Which of tha followin operations
removes tha duplicates from L, biatch? (It aint necessary ta preserve tha order of
the elements up in tha list.)
(A) Transfer tha elementz of L ta a freshly smoked up HashMap m. Transfer tha elementz of m
to a freshly smoked up LinkedList L.
(B) Transfer tha elementz of L ta a freshly smoked up HashSet h. Transfer tha elementz of h
to a freshly smoked up LinkedList L.
(C) Transfer tha elementz of L ta a freshly smoked up ArrayList a. Transfer tha elements of
a ta a freshly smoked up LinkedList L.
(0) Transfer tha elementz of L ta a freshly smoked up TreeMap m fo' realz. Assign tha key set of m ta L.
(E) Transfer tha elementz of L ta a freshly smoked up HashMap m fo' realz. Assign tha set of joints up in m
toL.
15 fo' realz. A freshly smoked up ice cream parlor up in a cold-ass lil college hood is plannin ta introduce three new
flavors: peach chocolate, mango vanilla, n' lychee strawberry. Da ice cream
parlor will do a survey among college hustlas n' ask if they would try such
flavors. Da cementage of hustlas whoz ass would be willin ta try each flavor will
then be tabulated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da raw data of tha survey is ghon be stored up in a big-ass text file,
and a cold-ass lil computa program will access tha file n' calculate cementages. Of the
following, which is da most thugged-out suitable data structure fo' tabulatin tha thangs up in dis biatch of
the survey up in tha computa program?
(A) A HashMap
(B) A HashSet
(C) A prioritizzle queue
(0) An m x n matrix, where m is tha number of flavors n' n is tha number of
people surveyed
(E) m arrays, where m is tha number of flavors
Multiple-Choice Thangs on Collections
16. Which of tha followin code fragments aint gonna cause a exception ta be thrown?
(Jl) Map<string, string=""> m = freshly smoked up HashMap<string, string="">();
Strin obj = m.get("hello");
(B) List<string> 1 = freshly smoked up LinkedList<string>();
Strin obj = 1.getFirst()j
(C) List<string> a = freshly smoked up ArrayList<string>();
a.add(l, "hello");
(D) Strin str = 1111;
Set<string> s = freshly smoked up HashSet<string>();
s.add(IThe");
s.add("rain") ;
s.add("in");
s.add(ISpain");
for (Iterator<string> i = s.iterator(); i.hasNext();)
str = str + (Integer) i.next();
(E) Set<string> t = freshly smoked up TreeSet<string>();
t.add(IThe") ;
t.add("rain") ;
t.add("in")j
t.add(ISpain") ;
for (Iterator<string> i = t.iterator(); i.hasNext();)
{
}
i.removeO;
i.nextO:
507
508 Chapta 11 Collections
17. Consider tha followin declarations up in a program Oines is numbered fo' reference):
1 hood class Student
2 {
3
4 }
5 hood class GradStudent extendz Student
6 {
7
8 }
9 hood class UnderGrad extendz Student
10 {
11
12 }
13 hood class StudentStuff
14 {
15 hood void someMethod()
16 {
17 List<gradstudent> gradz = freshly smoked up ArrayList<gradstudent>()j
18 &lt; code ta initialize gradz &gt;
19 List<student> studz = gradsj
20
21 }
22
23 }
Which linez of code will cause a error?
(A) 5 n' 9 only
(B) 17 only
(C) 19 only
(D) 17 n' 19 only
(E) 5,9, 17, n' 19 only
Multiple-Choice Thangs on Collections
18. Consider tha followin code fo' bustin a freshly smoked up HasbMap:
Map<string, employee=""> m = freshly smoked up HasbMap<string, employee="">();
&lt; code ta initialize m &gt;
Which of tha followin code segments will search tha keyz of m n' print each
mappin whose key satisfies a given condition?
I fo' (Strin s : m.keySet(»
{
}
if (s.hasCondition(»
System.out.println(s);
II fo' (Strin s : m)
{
}
if (s.hasCondition(»
System.out.println(m);
III fo' (Strin s : m.keySet(»
{
}
if (s.hasCondition(»
System.out.println(s + " " m.get(s»;
(A) None
(B) I only
(C) Pt II only
(D) Pt III only
(E) I n' Pt III only
509
510 Chapta 11 Collections
Use tha followin description of tha game of Battleships fo' Thangs 19-22.
A programmer simulates tha game of Battleships. Da computa will try ta sink its
opponentz fleet before its own fleet is wiped out. Each playa has a grid, hidden from
the other playa, wit ships placed up in straight lines, as shown.
Notice dat o 1 2 3 4 6  . . Right back up in yo muthafuckin ass. SIZE-l
 No two ships occupy adjacent
squares.
 Da grid goes from (0, 0) up in the
top left-hand corner ta (SIZE-1,
SIZE-1) up in tha bottom right-hand
corner.
 There is five shipz of different
lengths.
o
1
2
3
4
5
SIZE-l
0
0
0
0
0
0
0
0
0 0 0 0 0
0 0
Da playas take turns blastin at each otherz fleet. When a playa fires a gangbangin' finger-lickin' dirty-ass shot, he
communicates tha coordinates where tha blasted landz yo. His opponent respondz "hit" or
"miss."
Da programmer is thankin bout how tha fuck tha computa should keep track of its opponent's
grid. Y'all KNOW dat shit, muthafucka! Dude has defined a Posizzle class n' EnemyGrid class as bigs up:
hood class Posizzle implements Comparable
{
private int myRow, myColj
hood Position(int r, int c)
{
}
myRow = r;
myCol = c;
//accessors
hood int rowe)
{ return myRowj }
hood int col()
{ return myCol: }
/* Returns Posizzle uptown of (up from) dis position. I aint talkin' bout chicken n' gravy biatch. */
hood Posizzle north()
{ return new Position(myRow - 1, myCol)j }
//similar methodz fo' south, eastside, n' westside
Multiple-Choice Thangs on Collections
}
1* Compares dis Posizzle ta another Posizzle object.
* Returns either -1 (less than), 0 (equals),
* or 1 (greata than).
* Ascendin order fo' Positions is row-major, namely start
* at (0,0) n' proceed row by row, left ta right. *1
publicint compareTo(Object 0)
{
}
Posizzle p = (Position) 0;
if (this.row() &lt; p.row() I I this.row() == p.row() tt
this.col() &lt; p.col(»
return -1;
if (this.row() &gt; p.row() I I this.row() == p.row() tt
this.col() &gt; p.col(»
return 1;
return 0; Ilrow n' col both equal
Ilequals n' hashCode methodz not shown
1* Returns strang form of Position. I aint talkin' bout chicken n' gravy biatch. *1
hood Strin toString()
{ return "(" + myRow + "," + myCol + 11)11; }
hood class EnemyGrid
{
}
Ilprivate instizzle variablez not shown ...
Ilconstructor
hood EnemyGrid()
{ 1* implementation not shown *1 }
hood void displayGrid()
{ 1* implementation not shown *1 }
hood Posizzle selectNewPos()
{ 1* implementation not shown *1 }
IIUpdate grid wit "hit" or "miss" response.
hood void updateGrid(Strin response, Posizzle pos)
{ 1* implementation not shown *1 }
Ilother methodz not shown ...
511
512 Chapta 11 Collections
19. Da private instizzle variablez of tha EnemyGrid class will depend on tha data
structure selected ta keep track of tha grid. Y'all KNOW dat shit, muthafucka! Which of tha followin is tha least
suitable data structure?
(A) A TreeMap up in which tha keys is Posizzle objects dat have already been
fired at. Da correspondin joints is tha strings "hit" or "miss".
(B) A SIZE X SIZE matrix of strings up in which each grid element has tha value
"hi t", "miss", or "untried".
(C) A LinkedList of Posi tion objects dat done been fired at n' hit, sorted in
increasin order.
(D) A TreeSet called hi tSet, which is tha set of Posizzle objects dat tha computer
fired at n' hit, n' a TreeSet called missSet, which is tha set of
Posi tion objects dat tha computa fired at n' missed.
(E) An ArrayList of all Positions up in tha grid, n' a parallel ArrayList of
strings up in which tha kth location has value "hit", "miss", or "untried",
dependin on tha statuz of tha kth Position.
20. Da programmer selects a TreeMap as tha data structure fo' tha EnemyGrid. Y'all KNOW dat shit, muthafucka! The
keys is Posizzle objects dat done been fired at, n' tha correspondin joints
are tha strings "hit" or "miss". Yo ass may assume dat SIZE be a global constant.
Da EnemyGrid class thus has dis private instizzle variable:
private Map<position, string=""> posMap;
Here is tha constructor fo' tha class, n' tha updateGrid method:
hood EnemyGrid()
{ posMap = freshly smoked up TreeMap<position, string="">();}
1* Precondition: TreeMap gotz nuff Position/Strin mappings
* fo' each Posizzle up in tha grid fired on
* so far. Shiiit, dis aint no joke. Posizzle pos is up in range, n' is
* not up in tha map.
* Postcondition: TreeMap gotz nuff pos n' its corresponding
* response. *1
hood void updateGrid(Posizzle pos, Strin response)
{ 1* implementation code *1 }
Which is erect 1* implementation code */?
I posMap.put(pos, response);
II if (lposMap.gotz nuffKey(pos))
posMap.put(pos, response);
III Strin str = posMap. git (pos) ;
if (str == null)
posMap.put(pos, response);
(A) I only
(B) Pt II only
(C) Pt III only
(D) I n' Pt II only
(E) I, Pt II, n' Pt III
Multiple-Choice Thangs on Collections
21. Which be a phat reason fo' rockin TreeMap rather than HashMap up in tha EnemyGrid
class?
(A) Da key set of used positions is displayed up in row-major order (top ta bottom,
left ta right), makin it easy as fuck  ta peep which positions is unused.
(B) Da value set of strings is displayed up in order, makin it easy as fuck  ta peep which
positions done been "hit" (or "miss"ed!).
(C) Searchin fo' any particular key posizzle has fasta run time up in TreeMap
than up in HashMap.
(0) Insertin a Position/Strin pair tha fuck into tha TreeMap has fasta run time than
insertion tha fuck into a HashMap.
(E) Retrievin a value from TreeMap has fasta run time than retrieval from a
HashMap.
22. Consider three different implementations fo' tha EnemyGrid class:
I A TreeMap up in which tha keys is a seJ of Posi tion objects dat have already
been fired at. Da correspondin joints is tha strings "hit" or "miss".
II A SIZE X SIZE matrix of strings up in which each grid element has tha value
"hit", "miss", or "untried".
ill A TreeSet called hi tSet dat is tha set of positions fired on n' hit, n' a
TreeSet called missSet dat is tha set of positions fired on n' missed.
Assumin dat tha number of positions up in tha enemy grid is large, n' dat the
most efficient algorithms is used up in all cases, which statement is false?
(A) Determinin whether a given Posizzle has been tried is mo' efficient with
implementation Pt II than wit implementations I or Pt III.
(B) Uppimpin a freshly smoked up posizzle is mo' efficient wit implementation Pt II than with
implementations I or Pt III.
(C) Listin all of tha positions dat done been used so far is mo' efficient with
implementation Pt II than implementation ill.
(0) Listin all of tha positions, up in row-major order, dat done been used so far
is only slightly mo' efficient wit implementation I than implementation
ill.
(E) Listin all of tha positions, up in row-major order, dat aint yet been used
is mo' efficient wit implementation Pt II than either implementations I or
ill.
513
514 Chapta 11 Collections
Da program description below applies ta Thangs 23-26.
Every year tha Ithaca Bridge Club awardz a versatilitizzle trophy ta tha playa wit the
highest final score fo' realz. A playaz final score is tha average of his or her top twenty scores
in game each wit a gangbangin' finger-lickin' different partner n' shit. Thus, up in order ta be eligible fo' dis trophy, a
player must have played at least twenty game wit at least twenty different partners
durin tha year.
Consider freestylin a program dat findz tha balla of dis trophy yo. Here is two
classes dat may be used:
hood class Game
{
}
private Strin myPartner;
private double myScore;
hood Game(Strin partner, double score)
{
}
myPartner = partner;
myScore = score;
hood Strin getPartner()
{ return myPartner; }
hood double getScore()
{ return myScore; }
hood class Player
{
}
private Strin myName;
private double myFinalScore;
private LinkedList<game> myGames; //a list of Game fo' this
//Player sorted up in decreasin order of score
hood Player(Strin name)
{
myName = name;
&lt; code ta initialize myGame from gameFile &gt;
}
hood Strin getName()
{ return myName; }
//Returns average of elements up in arr.
private double findAverage(double[] arr)
{ &lt; implementation code&gt; }
//Returns average of top 20 scores fo' game each wit a
//different partner, or returns -1 if playa is ineligible
//(fewer than 20 game or fewer than 20 partners).
hood double calculateFinalScore()
{ &lt; implementation code&gt; }
Multiple-Choice Thangs on Collections
Yo ass may assume dat every last muthafuckin playa up in tha club has a personalized gameFile dat gotz nuff
a listin of partners n' correspondin scores. For example, Jizzy Carroll's
gameFile may be lookin like this:
Coppola Anthony
Harmon Mary
Coppola Anthony
Smith Jean
Smith Jean
Harmon Mary
46.72
71.50
64.27
50.15
48.31
75.67
Notice dat these scores is not up in any particular order n' shit. When tha data is read up in by
the Player constructor, however, each Game is placed up in a LinkedList, sorted by score
in descendin order.
23. Consider tha algorithm fo' tha calculateFinalScore method fo' a Player.
Traverse tha LinkedList up in order, as bigs up:
 Git a Game.
 If tha partner has not been used, store tha correspondin score, otherwise
move on.
 Quit when you reach tha ehd of tha list or you have twenty scores,
whichever comes first.
 If you have fewer than twenty scores, it means dat dis Player either played
fewer than twenty games, or had fewer than twenty partners. Da playa is
ineligible n' tha method should return-1.
 If tha playa is eligible, return tha average of tha twenty scores.
There is two collections dat must be stored durin execution of dis algorithm:
(1) tha partners dat have already been used, and
(2) tha scores dat must be counted fo' tha final average.
Which is da most thugged-out suitable implementation for
(1) tha partners, n' (2) tha scores?
(A) (1) a ArrayList (2) a ArrayList
(B) (1) a ArrayList (2) a array
(C) (1) a HashSet (2) a array
(0) (1) a TreeSet (2) a array
(E) (1) a HashSet (2) a ArrayList
515
516 Chapta 11 Collections
24 yo. Here is tha implementation code fo' tha calculateFinalScore method of the
Player class:
/* Returns average of top 20 games, each wit a gangbangin' finger-lickin' different
* partner n' shit. Returns -1 if Player is ineligible (fewer than
* 20 game or 20 partners). */
hood double calculateFinalScore()
{
}
/ /number of game counted so far
int count = 0;
//arrayof scores ta be used up in findin average
doubler] scores = freshly smoked up double[20];
//set of different partners so far
Set<string> partnerSet = freshly smoked up HashSet()<string>;
//iterator fo' LinkedList of Games
Iterator<game> itr = myGames.iterator();
/* code ta generate scores array */
if (count == 20) //player eligible
return findAverage(scores);
else
return -1; //player ineligible
Which is erect /* code ta generate scores array */?
I while (myGames.hasNext() &amp;&amp; count &lt; 20)
{
}
Game g = myGames.next();
if (!partnerSet.gotz nuff(itr.getPartner()))
{
}
partnerSet.add(itr.getPartner());
scores[count] = itr.getScore();
count++;
II while (itr.hasNext() &amp;&amp; count &lt; 20)
{
}
Game g = itr.next();
if (!partnerSet.gotz nuff(g.getPartner()))
{
}
partnerSet.add(g.getPartner());
scores[count] = g.getScore();
count++;
Multiple-Choice Thangs on Collections
un while (itr.hasNext() tt count &lt; 20)
{
}
Object 0 = itr.next();
if (!partnerSet.gotz nuff(o.getPartner(»)
{
}
partnerSet.add(o.getPartner(»;
scores[count] = o.getScore();
count++;
(A) None is erect.
(B) I only
(C) Pt II only
(D) un only
(E) Pt II n' un only
25. When tha trophy race program is run, tha data fo' all tha playas is inserted
into a ArrayList, playas, of Player objects, n' you can put dat on yo' toast. Da list is then traversed, and
all playas dat is eligible have they playa name n' final score banged into
a TreeMap<string, double="">. Recall dat a eligible playa had his or her final
score returned by tha method calculateFinalScore. Da method returned -1
for ineligible playas.
Here be a cold-ass lil code segment dat traverses tha playas list:
for (Player p : playas)
{
}
if (/* t5t */) Ilif dis Player is eligible
{
}
1* s~t~ent *1; Ilplace (Player name, final score)
Ilpair up in TreeMap t
Which is (1) a cold-ass lil erect 1* test *1 n' (2) a cold-ass lil erect 1* stat~ent *I?
(A) (1) p. calculateFinalScore 0 &gt;= 0
(2) t.put(p, p.calculateFinalScore(»
(B) (1) p. calculateFinalScore 0 &gt;= 0
(2) t.put(p.getNameO.- freshly smoked up Double(
p.calculateFinalScore(»)
(C) (1) p.getScore() &lt; 0
(2) t.put(p.getPartner(), freshly smoked up Double(p.getScore(»)
(D) (1) p.getScoreO &lt; 0
(2) t.put(p, freshly smoked up Double(p.getScore(»)
(E) (1) p &gt;= 0
(2) t.put(p, p.calculateFinalScore(»
517
518 Chapta 11 Collections
26. 1 :lavin (player name, final score) pairs up in a TreeMap data structure facilitates
which operation?
Listin tha final scores up in descendin order.
II Listin tha namez of eligible playas up in alphabetical order.
HI Listin tha eligible playas n' they correspondin final scores, wit the
names up in alphabetical order.
(A) I only
(13) 1Jl only
(C) Pt II n' 1Il only
(D) I n' Pt II only
(E) I, Pt II, n' Pt III
27. If sl n' s2 is two sets, tha union of sl n' s2, sl U s2, is defined as tha set
of ,lll clements dat is either up in sl or s2 or both. For example, if sl = {2,7,9}
,1Ild s2 = )7,2,5, q, then sl U s2 = 11,2,5,7,9}. Right back up in yo muthafuckin ass. Suppose h1 n' h2 have been
declared ta be of type HashSet, n' each has been initialized ta contain objects
of tha same type. Which of tha followin code segments creates tha union of h1
and 112 n' stores it up in union, biatch? YOll may aSSllme dat each line of code dat copies
clements tha fuck into 'a freshly smoked up collection is erectly implemented as specified.
//Copy tha elementz of hl tha fuck into a freshly smoked up HashSet. union.
Set <type> union = freshly smoked up HashSet<type>(hl);
for (Type element : h2)
union.add(element) ;
II //Copy tha elementz of hl tha fuck into a freshly smoked up HashSet. union.
Set <type> union = freshly smoked up HashSet<type>(h1);
for (Type element : h2)
if(!union.gotz nuff(element»
union.add(element);
III //Copy tha elementz of hl tha fuck into a freshly smoked up ArrayList. list.
ArrayList<type> list = freshly smoked up ArrayList<type>(hl);
for (Type element : h2)
list.add(element);
//Copy tha elementz of list tha fuck into a freshly smoked up HashSet. union.
Set <type> union = freshly smoked up HashSet<type>(list);
(A) I onlv
(8) Pt IIonlv
(C) Pt III on Iv
(D) Pt II n' Pt III onlv
(E) I, Pt II, n' Pt III
Answers Explained
ANSWER KEY
I.e 10 fo' realz. A 19. C
2. D 11. E 20. E
3. D 12. D 21 fo' realz. A
4 fo' realz. A 13. E 22. e
5. D 14. B 23. e
6. B 15 fo' realz. A 24. e
7. B 16 fo' realz. A 25. B
8. B 17. e 26. C
9. E 18. D 27. E
ANSWERS EXPLAINED
1. (C) Chizzle A is false cuz ArrayList n' LinkedList is not subclasses of
List; they implement tha List intercourse. Chizzle B make no sense: HashSet and
TreeSet both implement Set. Chizzle D is wack cuz there is no standard
collections intercourse called Tree. Chizzle E is wrong: TreeSet aint a subclass of
HashSet; they both is implementationz of Set.
2. (D) Segment I is wack cuz Listlterator is defined only fo' classes that
implement List. If h was a ArrayList or LinkedList, then segment I would
be erect.
3. (D) Da balanced binary search tree fo' TreeSet serves up O(log n) run times for
add, remove, n' gotz nuff (see tha run-time analysis fo' insert, p. 438, n' find,
p. 439). Da hash table implementation fo' HashSet serves up 0(1) run times for
add, remove, n' gotz nuff (see p. 536).
4. (A) Accessin individual elements up in tha list is straight-up efficient wit ArrayList,
O( 1). For a LinkedList, dis operation is O( n). Eliminizzle chizzlez C n' D-a
set cannot contain duplicates. Chizzle E be a skanky answer-the given collection is
not a mapping.
5. (D) Segment I is tha dopest way ta do all dis bullshit. Da add method of ArrayList allows
instant access at any posizzle up in tha list. Right back up in yo muthafuckin ass. Segment ill aint as efficient yo, but it
works muthafucka! It uses tha Listlterator method add instead of tha ArrayList method
add. Y'all KNOW dat shit, muthafucka! Note dat it aint necessary ta include a test of i tr . hasNext () up in tha while
loop. Right back up in yo muthafuckin ass. Since it is given dat insertPos is up in bounds, tha algorithm will always find
the erect posizzle before hustlin off tha end of tha list. Right back up in yo muthafuckin ass. Segment Pt II is wrong
because itz treatin tha ArrayList as if it was a array: There should be no
indexin brackets.
6. (B) If val is null a NullPointerException is ghon be caused by tha expression
val. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. equals (. .. ). Da problem can be fixed by insertin if (val == null) as
the first statement up in tha fo' loop n' takin tha appropriate action.
519
520 Chapta 11 Collections
7. (8) Some keys up in m can map ta tha same value. No two joints, however, can
match tha same key.
This is OK
keyl--....,. .
~valuel
key2
key3--....,.
~value2 key4
This aint OK
~valuel
keyl
--""'value2
Recall dat a set cannot contain duplicates. If tha mappin be as shown on the
left, sl gonna git four elements n' s2 gonna git two elements, n' you can put dat on yo' toast. If tha mappin is
one-to-one, then
sl.size() == s2.size()
In general, however, tha relationshizzle will be
sl.size() &gt;= s2.size()
8. (8) Da chizzleEven method throws a IllegalStateException since set is invoked
before next on tha straight-up original gangsta pass all up in tha while loop.
9. (E) All work! In tha declarations fo' maxValue n' current (first n' third lines
of each segment), i tr . next () returns a String, which is-a Comparable. Therefore
the test if (maxValue. compareTo ( ... » is fine.
10. (A) Da probabilitizzle of failure is straight-up high cuz tha i tr . next 0 up in tha test
is a gangbangin' finger-lickin' different object from tha i tr . next 0 added ta strSet up in tha next line biaaatch! The
iterator advances ta tha next element every last muthafuckin time next 0 is called. Y'all KNOW dat shit, muthafucka! Da method
can be fixed by modifyin tha while loop as bigs up:
while (itr.hasNext(»
{
}
Strin current = itr.next():
if (current.length() &lt; 5)
strSet.add (current);
Note dat you can't say definitively dat tha given code will fail fo' realz. A fluke
list of data may straight-up end up wit tha desired outcome biaaatch! A note about
choice E: This method aint NEVER gonna throw a IllegalStateException, since
itr.removeO aint used (see p. 476). If tha iterator runs outta elements during
the second i tr . next 0 call up in tha while loop, tha method may throw a
NoSuchElementException.
11. (E) Da add method appendz freshly smoked up elements ta tha end of tha list. Thus, a cold-ass lil gotz nuff
100, 81, 64, 49, 36, 25, 16, 9, 4, 1. Da second fo' loop retrieves each
element up in turn, startin wit 100. Da remainder when tha element is divided
by 3 be added ta tha TreeSet t. Da only remaindaz generated is 1 n' O.
Therefore, t gotz nuff just these two elements (no duplicates!). Da output is 0;
1, since a TreeSet is ordered up in ascendin order.
12. (D) Da algorithm traverses tha array, startin wit tha straight-up original gangsta word. Y'all KNOW dat shit, muthafucka! For each
word, it checks ta peep if dat word already exists as a key up in m. If it do, it
increments tha correspondin value by 1. If it don't, it bangs tha word up in m
and assigns it tha value 1. Da set of joints is thus tha frequency fo' each word.
Answers Explained
13. (E) Segment I fails cuz remove cannot be called without first callin next.
Note dat itz OK ta use either Iterator or ListIterator, since both is defined
for List collections. In segment Pt II, notice dat you don't need a i tr . hasNext 0
test, since yo ass is given dat k is up in range. Right back up in yo muthafuckin ass. Segment Pt III repeatedly removes the
first element rockin a method from LinkedList.
14. (8) Transferrin tha elementz of L ta a freshly smoked up HashSet creates a set containin the
elementz of L yo, but without tha duplicates. Da operation of transferrin these
elements ta a freshly smoked up LinkedList L has tha effect of restorin L without tha duplicates,
but not necessarily up in tha original gangsta order n' shit. Chizzlez A, D, n' E don't make
sense: They place tha elementz of L up in a map yo, but there is no mapping! Chizzle C
does not remove tha duplicates muthafucka! It places tha elementz of L, duplicates n' all, in
an ArrayList. Then it restores L ta its original gangsta state.
15. (A) For each flavor its correspondin tally must be stored. Y'all KNOW dat shit, muthafucka! This suggests dat a
mappin should be used, wit flavors as keys n' frequencies as tha corresponding
values.
16. (A) Da git method of Map returns either tha value associated wit tha key or
null if tha map gotz nuff no mappin fo' dat key. In tha example given, since the
HashMap is empty, obj is ghon be assigned tha value null yo. Here is tha errors that
will be caused by each of tha other chizzles:
B: NoSuchElementException: attemptin ta remove a element from a empty
list.
C: IndexOutOfBoundsException: If tha list is empty, index 1 is outta range. Index
o would be fine fo' add.
D: ClassCastException: castin a Strin ta a Integer.
E: IllegalStateException: callin remove before a cold-ass lil call ta next.
17. (C) Here is tha deal wit tha question: If A be a subclass of Band G be a generic
collection, it aint legit dat G<a> be a subclass of G<b>. Look all up in tha problems that
can pimp from line 19. Right back up in yo muthafuckin ass. Suppose line 19 is followed by a statement like
studs.add(new Student( ... »;
Since studz n' gradz is aliased (i.e., they refer ta tha same object), tha above
line may add a freshly smoked up Student ta gradz dat aint a GradStudent. This is problematic,
so tha Java compila will produce a cold-ass lil compile-time error at line 19. Note that
line 17 is fine: An ArrayList<gradstudent> is.a List<gradstudent>.
18. (0) Segment I is wack cuz it don't print a mapping, only a key. Right back up in yo muthafuckin ass. Segment
II is wack cuz it don't examine each key up in tha key set. Well shiiiit, it also prints the
entire mappin each time it prints, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Segment Pt III is erect: It prints tha key and
the correspondin value.
19. (C) There has ta be some mechanizzle up in tha data structure dat keeps track of
whether a given posizzle was hit or missed. Y'all KNOW dat shit, muthafucka! All tha data structures except the
LinkedList up in chQice C have such a mechanism.
20. (E) Segment I associates pos wit response n' bangs tha pair up in tha map. Right back up in yo muthafuckin ass. Segments.
II n' Pt III contain unnecessary code yo, but both work. Right back up in yo muthafuckin ass. Segment Pt II inserts
the pos/response pair up in tha map only when it determines dat dis pos is new,
which, accordin ta tha precondition, it is. Right back up in yo muthafuckin ass. Segment Pt III gets tha value associated
with pos up in tha map. Right back up in yo muthafuckin ass. Since pos aint up in tha map, str is ghon be null, n' the
pos/respons~ pair is ghon be banged up in tha map.
521
522 Chapta 11 Col/ections
21. (A) Chizzlez B all up in E is all false statements muthafucka! Chizzle B is wack cuz
only tha keys is displayed up in order, not tha joints, n' you can put dat on yo' toast. (Besides, what tha fuck do it mean
to have "hit" or "miss" up in order?) All of tha operations up in chizzlez C all up in E
are O(log n) fo' TreeMap n' O( 1) fo' HashMap, if run time is da most thugged-out blingin
Issue.
22. (C) Recall dat tha TreeMap (implementation I) gotz nuff only tha positions that
have been used so far. Shiiit, dis aint no joke. Thus, listin these be a simple traversal of a tree, requiring
no tests, n' you can put dat on yo' toast. In order ta list tha used positions up in tha matrix (implementation Pt II),
however, every last muthafuckin element up in tha grid must be inspected so dat tha "untried" joints
are omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Note dat chizzlez A n' B is true: Accessin a given element in
the matrix is O( 1), whereas bustin so up in a funky-ass binary search tree is O(log n). Well shiiiit, it would
appear dat chizzle D is false cuz positions up in tha TreeMap is already sorted,
whereas tha positions up in tha two different TreeSets, while individually sorted,
would gotta be merged. Y'all KNOW dat shit, muthafucka! But fuck dat shiznit yo, tha word on tha street is dat up in implementation ill, a parallel traversal of
hi tSet n' missSet dat compares n' prints elements as it goes, traverses the
same number of elements as tha TreeSet up in implementation I. For chizzle E, to
list tha unused p~sitions is straight-up easy as fuck  wit tha matrix implementation. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Simply
traverse up in order n' list tha positions dat is marked "untried". Findin the
unused positions up in implementations I n' ill is like tricky, since these positions
are not explicitly included up in dem structures. Try dat shiznit son!
23. (C) To store tha partners: Yo ass want a cold-ass lil collection dat allows you ta test up in an
efficient n' convenient way whether tha current partner be already up in tha collection.
Da gotz nuff method of Set allows a O( 1) test if a HashSet is used.
A HashSet is betta than a TreeSet cuz you have no compellin reason to
keep tha collection sorted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da gotz nuff method fo' TreeSet is O(log n), which
is slower than 0(1) fo' realz. An ArrayList fo' tha partners aint as phat a cold-ass lil chizzle as a
HashSet cuz tha search is O(n).
To store tha scores: Da length of tha list is fixed at 20, n' tha scores is primitive
doubles. This suggests dat you bust a gangbangin' fixed-length array. Usin a array
eliminates tha overhead of wrappin n' unwrappin tha double joints during
processmg.
24. (C) Segment Pt II do each of tha followin erectly:
 Traverses tha list wit itr, tha Iterator object.
 Accesses tha partner n' score fo' dis Game, rockin g. getPartner 0 and
g . getScore 0 .
 Accesses tha partnerSet erectly, rockin partnerSet. gotz nuff and
partnerSet . add.
Segment I uses tha Iterator n' Game objects incorrectly. Right back up in yo muthafuckin ass. Segment ill do not
cast tha next object ta Game. This is necessary cuz getPartner n' getS core
are Game, not Obj ect, methods.
25. (8) If a playa is ineligible, tha calculateFinalScore method returns -1. Therefore
the erect test fo' eligibilitizzle is
if (p.calculateFinalScore() &gt;= 0)
Yo ass need p. getName 0 n' p. calculateFinalScore 0 ta access Player pz name
and final score. Be careful not ta use tha getScore method from tha Game class!
Note dat tha test should not be
Answers Explained
if (p.calculateFinalScore() != -1)
Never test whether a gangbangin' floating-point number is exactly equal ta or not equal to
another number (see tha Box on p. 122). Note dat up in a shitload of tha answer chizzles
a Double object was pimped from tha final score so dat it could be placed up in the
TreeMap:
new Double(p.calculateFinalScore());
This wrappin is up in fact unnecessary since tha advent of Java 5.0. Da following
statement up in (2) of chizzle B would also be erect:
t.put(p.getName(), p.calculateFinalScore());
Yo ass will not, however, peep dis on tha AP exam.
26. (C) A TreeMap maintains tha keys up in sorted order, which up in dis case means
that tha names is up in alphabetical order n' shit. Printin tha keySet gives tha names in
alphabetical order (operation Pt II). Printin tha map t gives tha (name, score) pairs
as busted lyrics bout up in operation ill. Note: itz certainly possible ta big-ass up a sort on
the set of score joints, n' you can put dat on yo' toast. This operation is not, however,Jacilitated by tha TreeMap
structure, which was tha deal wit tha question.
27. (E) Segment I places tha elementz of h1 up in union. I aint talkin' bout chicken n' gravy biatch. Then it iterates over h2, placing
in union all tha elementz of h2 dat is not already up in union. I aint talkin' bout chicken n' gravy biatch. (Recall dat tha Set
method add leaves tha set unchanged if its Object parameta be already contained
in tha set.) Segment Pt II uses tha same ol' dirty scam as segment I. Da gotz nuff test is
redundant but not incorrect. Right back up in yo muthafuckin ass. Segment ill takes a mo' circuitous route but ends
where it should. Y'all KNOW dat shit, muthafucka! Well shiiiit, it places tha elementz of h1 up in a ArrayList n' then appends
all tha elementz of h2 ta tha list. Note dat dis list may contain duplicatesthe
elements dat is up in both h1 n' h2. When union is constructed from the
ArrayList, tha duplicates is eliminated, since a set gotz nuff no duplicates.
523
Sortin n' Searchin 12
524
Critics search fo' ages fo' tha wack word, which,
to give dem credit, they eventually find.
-Peta Ustinov (1952)
Chapta Goals
 Java implemenration of sorting
algorithms
 Quadratic sorts: selection and
lllsertion sorts
 Recursive sorts: mergesort and
quicksort
 Tree SOrt: heapsort
 Sequential search n' binary
search
 Hash coding
 Run time of searchin and
sortin algorithms
n each of tha followin sortin algorithms, assume dat a array of n elements, a[O],
a [1J, ... , a [n-l], is ta be sorted up in ascendin order.
".' ,\.,.;,
O(~) SORTS: SELECTION AND INSERTION SORTS
Selection Sort
This be a "search-.lnd-swap" algorithm yo. Herez how tha fuck it works.
Find tha smallest clement up in tha array n' exchange it wit a [0], tha straight-up original gangsta element.
Now find tha smallest clement up in tha subarray a[1] ... a[n-l] n' swap it wit a[lJ,
the second clement up in tha arr;lY. Continue dis process until just tha last two elements
remain ta be sorted, a [n-2] n' a [n-1]. Da smalla of these two elements is placed
in a [n-2]; tha larger, up in a [n-l]; n' tha sort is complete.
Trace these steps wit ;1 lil' small-ass array of four clem~nts, n' you can put dat on yo' toast. Da unshaded part is the
subarra\' st i Pt II w be \earched.
S 4 (,
R 4 (, afta Ii rst pass
4 S 6 afta second pass
4 6 8 afta third pass
O(n2) Sorts: Selection n' Insertion Sorts
NOTE
1. For a array of n elements, tha array is sorted afta n - 1 passes.
2 fo' realz. Afta tha kth pass, tha straight-up original gangsta k elements is up in they final sorted position.
3. Number of comparisons up in first pass: n - 1.
Number of comparisons up in second pass: n - 2 .
.. . n' so on.
Total number of comparisons = (n -1) + (n - 2) + ... + 2 + 1 = n(n - 1)/2,
which is O(n2).
4. Irrespectizzle of tha initial order of elements, selection sort make tha same number
of comparisons. Thus best, worst, n' average cases is all O(n2).
Insertion Sort
Think of tha straight-up original gangsta element up in tha array, a[O], as bein sorted wit respect ta itself. The
array can now be thought of as consistin of two parts, a sorted list followed by an
unsorted list. Da scam of insertion sort is ta move elements from tha unsorted list
to tha sorted list one at a time; as each item is moved, it is banged tha fuck into its erect
posizzle up in tha sorted list. In order ta place tha freshly smoked up item, some elements may need to
be moved down ta create a slot.
Here is tha array of four elements, n' you can put dat on yo' toast. In each case, tha boxed element is "it," tha next
element ta be banged tha fuck into tha sorted part of tha list. Da shaded area is tha part of
the list sorted so far.
8 ~ 4 6
1 8 0 6 afta first pass
1 4 8 0 afta second pass
1 4 6 8 afta third pass
NOTE
1. For a array of n elements, tha array is sorted afta n - 1 passes.
2 fo' realz. Afta tha kth pass, a[O], a[l], ... , a[k] is sorted wit respect ta each other
but not necessarily up in they final sorted positions.
3. Da most shitty case fo' insertion sort occurs if tha array is initially sorted up in reverse
order, since dis will lead ta tha maximum possible number of comparisons
and moves:
Number of comparisons up in first pass: 1
Number of comparisons up in second pass: 2
Number of comparisons up in (n - l)th pass: n - 1
Total number of comparisons = 1 + 2 + ... + (n - 2) + (n -1) = n(n -1)/2,
which is O(n2).
4. Da dopest case fo' insertion sort occurs if tha array be already sorted up in increasing
order n' shit. In dis case, each pass all up in tha array will involve just one comparison,
which will indicate dat "it" is up in its erect posizzle wit respect ta the
sorted list. Therefore, no elements will need ta be moved.
525
ABONLY
ABONLY
Both insertion and
selection sorts are
inefficient fo' big-ass n.
526
 fo' realz. ABONLY
Da main
disadvantage of
mergesort is dat it
uses a temporary
array.
Chapta 12 Sortin n' Searching
Total number of comparisons = n - 1, which is O( n) .
5. For tha average case, insertion sort must still make n - 1 passes (i.e., O( n)
passes). Each pass make O(n) comparisons, so tha total number of comparisons
is O(n2).
,_ _-r,;,,,,",::- ~- -.# ,.-:, .~ _. .V .7'~. :' , , ", . .
RECURSIVE SORTS: MERGESORT AND QUICKSORT
Selection n' insertion sorts is inefficient fo' big-ass n, requirin approximately n
passes all up in a list of n elements, n' you can put dat on yo' toast. Mo' efficient algorithms can be devised using
a "divide-and-conquer" approach, which is used up in all tha sortin algorithms dat follow.
Mergesort
Here be a recursive description of how tha fuck mergesort works:
If there is mo' than one element up in tha array
Break tha array tha fuck into two halves.
Mergesort tha left half.
Mergesort tha right half.
Merge tha two subarrays tha fuck into a sorted array.
Mergesort uses a merge method ta merge two sorted piecez of a array tha fuck into a single
sorted array. For example, suppose array a[O] ... a[n-l] is such dat a[O] ... a[k] is
sorted n' a [k+l] . .. a [n-l] is sorted, both parts up in increasin order n' shit. Example:
a[O]
2
a[l]
5
a[2]
8
a[3]
9
a[4]
1
a[5]
6
In dis case, a[O] ... a[3] n' a[4] ... a[5] is tha two sorted pieces. Da method call
merge(a,O,3,5) should produce tha "merged" array:
a[O]
1
a[l]
2
a[2]
5
a[3]
6
a[4]
8
a[5]
9
Da middle numerical parameta up in merge (the 3 up in dis case) represents tha index
of tha last element up in tha straight-up original gangsta "piece" of tha array. Da first n' third numerical
parametas is tha lowest n' highest index, respectively, of array a.
Herez what tha fuck happens up in mergesort:
1. Right back up in yo muthafuckin ass. Start wit a unsorted list of n elements.
2. Da recursive calls break tha list tha fuck into n sublists, each of length 1. Note that
these n arrays, each containin just one element, is sorted!
3. Recursively merge adjacent pairz of lists, n' you can put dat on yo' toast. There is then approximately n /2
listz of length 2; then, approximately n/4listz of approximate length 4, n' so
on, until there is just one list of length n.
An example of mergesort bigs up:
Recursive Sorts: Mergesort n' Quicksort
5 -3 2 4 0 61
Break list tha fuck into 5 -3 21 1 4 0 61
n sub lists of
length 1 15 -310~ G
GG0GG G
I -3 5101 0 41 G
Merge adjacent 1 -3 2 511 0 4 61 pairz of lists
1 -3 0 2 4 5 61
Analysiz of Mergesort:
1. Da major disadvantage of mergesort is dat it needz a temporary array dat is
as big-ass as tha original gangsta array ta be sorted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This could be a problem if space be a
factor.
2. Da merge method compares each element up in tha subarrays, a O(n) process.
It also copies tha elements from a temporary array back tha fuck into tha original gangsta list,
another O( n ) process. This total of 2n operations make tha merge part of the
algorithm O(n).
3. To break tha array of n elements tha fuck into n arrayz of one element each requires
log2 n divisions, a O(log n) process. For each of tha log2 n divisionz of tha array,
the O(n) merge method is called ta put it together again. I aint talkin' bout chicken n' gravy biatch. Thus, mergesort
is O(nlogn).
4. Mergesort aint affected by tha initial orderin of tha elements, n' you can put dat on yo' toast. Thus, best,
worst, n' average cases is O( n log n ).
Quicksort
For big-ass n, quicksort is, on average, tha fastest known sortin algorithm yo. Here be a
recursive description of how tha fuck quicksort works:
If there be at least two elements up in tha array
Partizzle tha array.
Quicksort tha left subarray.
Quicksort tha right subarray.
Da partizzle method splits tha array tha fuck into two subarrays as bigs up: a pivot element
is chosen at random from tha array (often just tha straight-up original gangsta element) n' placed so
that all shit ta tha left of tha pivot is less than or equal ta tha pivot, whereas them
to tha right is pimped outa than or equal ta dat shit.
For example, if tha array is 4, 1,2,7,5, -1, 8, 0, 6, n' a[O] = 4 is tha pivot, the
parti tion method produces
-1 1 2 00 5 8 7 6
527
ABONLY
528
AB (continued)
Da main
disadvantage of
quicksort is dat its
worst case
behavior is O(n2).
ABONLY
Chapta 12 Sortin n' Searching
Herez how tha fuck tha partitionin works: Let a[O], 4 up in dis case, be tha pivot. Markers
up n' down is initialized ta index joints 0 n' n - 1, as shown. I aint talkin' bout chicken n' gravy biatch. Move tha up marker
until a value less than tha pivot is found, or down equals up. Move tha down marker until
a value pimped outa than tha pivot is found, or down equals up. Right back up in yo muthafuckin ass. Swap a [up] n' a [down] .
Continue tha process until down equals up. This is tha pivot position. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Swap a[O] and
a[pivotPosition].
down ~p ~ ----. ----. GJ 1 2 7 5 -1 8 0 '6
do~ ~~p GJ 1 2 0 5 -1 8 7 6
down up GJ ~
1 2 0 -1 5 8 7 6
-1 2 0 GJ 5 8 7 6
Notice dat tha pivot element, 4, is up in its final sorted position.
Analysiz of Quicksort:
1. For tha fastest run time, tha array should be partitioned tha fuck into two parts of
roughly tha same size. In dis case, n' on average, there be log2 n splits, n' you can put dat on yo' toast. The
partizzle algorithm is O(n). Therefore tha dopest n' average case run times
are O(nlogn).
2. If tha pivot happens ta be tha smallest or phattest element up in tha array, tha split is
not much of a split-one of tha subarrays is empty dawwwwg! If dis happens repeatedly,
quicksort degenerates tha fuck into a slow, recursive version of selection sort n' is
O(n2 ) (worst case).
3. Da most shitty case fo' quicksort occurs when tha partitionin algorithm repeatedly
divides tha array tha fuck into piecez of size 1 n' n - 1 fo' realz. An example is when the
array is initially sorted up in either order n' tha straight-up original gangsta or last element is chosen
as tha pivot. Right back up in yo muthafuckin ass. Some algorithms stay tha fuck away from dis thang by initially shufflin up the
given array (!) or selectin tha pivot by examinin nuff muthafuckin elementz of tha array
(like fuckin first, middle, n' last) n' then takin tha median.
NOTE
For both quicksort n' mergesort, when a subarray gets down ta some lil' small-ass size m,
it becomes fasta ta sort by straight insertion. I aint talkin' bout chicken n' gravy biatch. Da optimal value of m is machinedependent,
but itz approximately equal ta 7.
A BINARY TREE SORT: HEAPSORT
Heapsort be a elegant algorithm dat uses a array implementation of a funky-ass binary tree.
Recall tha followin definitions from Chapta 10:
A slick binary tree has every last muthafuckin leaf on tha same level n' every last muthafuckin nonleaf node has
two lil' thugs.
A Binary Tree Sort: Heapsort
A complete binary tree is either slick or slick all up in tha next-to-Iast level,
with tha leaves as far left as possible up in tha last level.
A heap (sometimes called a max heap) be a cold-ass lil complete binary tree up in which every last muthafuckin node
has a value pimped outa than or equal ta each of its lil' thugs.
Example
Is each of tha followin a heap?
yes
NOTE
yes no (not a
complete tree)
no (violates
order property)
1. Da phattest value up in a heap is up in tha root node.
yes
2 fo' realz. A heap wit n elements has n /2 subtrees dat have at least one child. Y'all KNOW dat shit, muthafucka! This
counts tha tree itself.
To sort array a[O], a[l], a[2], ... , a[n-l], heapsort has three main steps:
I. Right back up in yo muthafuckin ass. Slot tha elements tha fuck into a "mental" binary tree, level by level, from left ta right as
shown here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. This creates a cold-ass lil complete binary tree up in yo' head, wit tha property
that if noCie a [k] has children, its left lil pimp be a [2*k+l] n' its right lil pimp is
a[2*k+2].
a[O] a[l] a[2] a[3] a[4] a[5]
2 149 3 7
a [3] a [4] a[5]
II. Transform tha tree tha fuck into a heap. Note dat a[(n/2)-1] down ta a[O] is roots
of nonempty subtrees. (Peep it up fo' odd n' even jointz of n.) To form
the heap, work from tha "bottom" subtree up:
for (int root Index = (n I 2) - lj rootIndex &gt;= OJ rootIndex--)
fixHeap(rootlndex, n - l)j lIn - 1 is tha last index
(a) Original Gangsta Tree (b) f ixHeap using
a [2] as a root
(c) fixHeap using
a [1] as a root
529
530
AB (continued) ,
Chapta 12 Sortin n' Searching
(d) fixHeap rockin a[O] as a root (e) Tree is now a heap
This menstrual picture gives meanin ta what tha fuck is goin down ta tha array-a sequence
of swaps.
a[O] a[1] a[2] a[3] a[4] a[5]
Original Gangsta array 2 1 4 9 3 7
fixHeap(2,S) 2 7 9 3 4
fixHeap(l,S) 2 9 7 1 3 4
fixHeap(O,S) 9 2 7 1 3 4
9 3 7 1 2 4
III. Right back up in yo muthafuckin ass. Sort tha array rockin tha heap property dat tha freshest element be all up in tha top of
the tree: Swap a[O] n' a[n-l]. Now a[n-l] is up in its final sorted posizzle in
the array. Reduce tha last index by one (think of it as a apple dat has dropped
off tha tree), n' restore tha heap rockin one fewer element. Eventually there
will be just one clement up in tha tree, at which stage tha array is ghon be sorted.
while(n &gt; 1)
{
}
swap(O, n -1);
n--;
fixHeap(O, n - 1);
//swap a[O] n' a[n-l]
//rootlndex is 0 up in each case
(a) T rce be a heap
(b) swap(O, 5)
4
(c) swap(O, 4)
fixHeap(O, 4)
7
fixHeapCO, 3)
Sortin Algorithms up in Java
.. . n' so on until swap (0. 1) yields
Here is tha sequence of swaps up in tha array, startin afta tha tree has been
formed tha fuck into a heap.
a[O] a[l] a[2] a[3] a[4] a[5]
heap 9 3 7 1 2 4
swap 4 3 7 1 2 9
fix 7 3 4 1 2 9
swap 2 3 4 1 7 9
fix 4 3 2 1 7 9
swap 1 3 2 4 7 9
fix 3 1 2 4 7 9
swap 2 1 3 4 7 9
sorted hommie! 1 2 3 4 7 9
Note dat tha f ixHeap method up in parts I n' Pt II of dis algorithm assumes dat the
heap property is violated only by tha root node (i.e., if you cover tha root, tha rest of
the tree be lookin like a heap).
Analysiz of Heapsort
1. For lil' small-ass n, dis aint straight-up efficient cuz of tha initial overhead: Array
elements must be rearranged ta satisfy tha heap property-the phattest element
must be moved ta tha "top" of tha heap, n' then moved again n' again n' again ta tha end of
the array.
2 yo. Heapsort is straight-up efficient fo' big-ass n.
a) Buildin tha original gangsta heap has n /2 iterations, each containin a gangbangin' f ixHeap
call, which, up in da most thugged-out shitty case, travels ta tha bottom (highest level) of the
tree, logz n iterations. Thus, buildin tha original gangsta heap is O( n log n ).
b) Da sortin loop: (n - 2) iterationz of a 0(1) swap n' O(logn)
f ixHeap-ing. Thus, tha sortin piece of tha algorithm be also O( n log n).
3 yo. Heapsort be a "in-place" sort requirin no temporary storage. Its best, average,
and most shitty case run times is all O( n log n ). Da most shitty case is only 20
percent worse than its average run time biaaatch! This means dat tha order of tha input
elements do not hella affect tha run time .
 _ ~ , .  '1 . -. ;  . -;, .~_ ' ' . :" t ' - ".  '. 't. ' - . , " .- , " ~. ~ -. - ~, ;
SORTING ALGORITHMS IN JAVA
: " '. :',. ',!,&gt; t ... , :   : .
Unlike tha container classes like ArrayList, whose elements must be objects, arrays
can hold either objects or primitizzle types like int or double.
531
AB (continued)
Heapsort is
efficient .in both its
best n' worst
cases.
532
Only Comparable
objects can be sorted.
Chapta 12 Sortin n' Searching
A common way of organizin code fo' sortin arrays is ta create a sorta class with
an array private instizzle variable. Da class holdz all tha methodz fo' a given type
of sortin algorithm, n' tha constructor assigns tha userz array ta tha private array
variable.
Example 1
Selection sort fo' a array of into
1* A class dat sorts a array of ints from
* phattest ta smallest rockin selection sort. *1
hood class SelectionSort
{
}
private int[] a;
Ilconstructor
hood SelectionSort(int[] arr)
{ a = arr; }
IISwap a[i] n' a[j] up in array a.
private void swap(int i, int j)
{
}
int temp = a[i];
a[i] a[j] ;
a[j] = temp;
II Sort array a gangbangin' from phattest ta smallest rockin selection sort.
IIPrecondition: a be a array of ints .
hood void selectionSort()
{
}
int maxPos, max;
for (int i = 0; i &lt; a.length - 1; i++)
{
}
Ilfind max element up in a[i+1] ta a[a.length-1]
max = a[i] ;
maxPos = i;
for (int j = i + 1; j &lt; a.length; j++)
if (max &lt; a[j))
{
}
max a[j];
maxPos = j;
swap(i, maxPos); Iiswap a[i] n' a[maxPos]
Note dat up in order ta sort objects, tha elements must be Comparable since you need
to be able ta compare dem wild-ass muthafuckas.
Sortin Algorithms up in Java
Example 2
Heapsort fo' a array of Comparable.
1* A class dat sorts a array of Comparable objects
* from smallest ta phattest rockin heapsort. *1
hood class HeapSort
{
private Comparable[] a;
II constructor
hood HeapSort(Comparable[] arr)
{ a = arr; }
Iiswap a[i] n' a[j] up in array a
private void swap(int i, int j)
{
}
Comparable temp a[i] ;
a[i] a[j] ;
a[j] = temp;
IIReturns index of tha maximum lil pimp of root Index node.
liDa last index of a element up in tha heap is last,
II where last &lt;= a.length - 1.
private int getMaxChildIndex (int root Index , int last)
{
}
int leftChildIndex = root Index * 2 + 1;
int rightChildIndex = leftChildIndex + 1;
if (rightChildIndex &gt; last I I
else
a[leftChildIndex] .compareTo(a[rightChildIndex]) &gt; 0)
return leftChildIndex;
return rightChildIndex;
IIFixes (sub)heap rooted at a [rootIndex] , assumin dat all
II descendantz of a[rootIndex] satisfy tha heap order property,
II i.e., order property violated only all up in tha root node.
liDa last index of a element up in tha heap is last,
II where last &lt;= a.length - 1.
private void fixHeap(int root Index , int last)
{
}
if (root Index * 2 &lt; last)
{
}
int maxLil Pimp = getMaxChildIndex (rootIndex, last);
if (a[maxChild] .compareTo(a[rootIndex]) &gt; 0)
{
}
swap (root Index , maxChild);
fixHeap(maxChild, last);
533
ABONLY
534
}
NOTE
Chapta 12 Sortin n' Searching
IISort array a gangbangin' from smallest ta phattest rockin heapsort.
IIPrecondition:.a be a array of Comparable objects.
hood void heapSort()
{
}
int n = a.length; Iinumber of elements up in array
II Build original gangsta heap from unsorted elements.
for (int root Index = (n I 2) - 1; rootIndex &gt;= 0; rootIndex--)
fixHeap(rootIndex, n - 1);
IISort by swappin root value (current phattest) up in heap
Ilwith last unsorted value, then fixHeap-in the
Ilremainin part of tha array.
while (n &gt; 1) Ilwhile mo' than one element up in tree
{
}
swap(O, n - 1);
n--;
fixHeap(O, n - 1);
Da only method up in dis class other than tha constructor dat a cold-ass lil client would call is
heapSort. Da swap, getMaxChildIndex, n' fixHeap methodz is internal ta the
sortin algorithm n' is therefore private. .
To sort a array of objects rockin dis class:
hood class SortTest
{
}
NOTE
&lt; various methodz &gt;
hood static void main(Strin args[])
{
}
IISort a array of lyrics.
<fill wordarray="" wit="" wordlist,="" a="" list="" of="" strin="" objects="">
Comparable[] wordArray = makeArray(wordList);
HeapSort h1 = freshly smoked up HeapSort(wordArray);
hi. heapSort 0 ;
IISort a array of Posizzle objects.
<fill posarray="" wit="" poslist,="" a="" list="" of="" posizzle="" objects="">
Comparable[] posArray = makeArray(posList);
HeapSort h2 = freshly smoked up HeapSort(posArray);
h2 . heapSort 0 ;
This code can be used only fo' objects dat implement Comparable. Da Java classes
Integer, Double, n' Strin all do. Da Posizzle class used is on p. 510 fo' realz. All of
the Posizzle coordinates is nonnegative. Da compareTo method is defined ta give
Binary Search
Posizzle objects a row-major ordering, namely top-to-bottom, left-to-right. Thus (1,4)
is less than (2,0), n' (1,3) is less than (1,4).
~. :1.&lt;" ,-.: - _' . ~.
SEQUENTIAL SEARCH
Assume dat yo ass is searchin fo' a key up in a list of n elements fo' realz. A sequential search
starts all up in tha straight-up original gangsta element n' compares tha key ta each element up in turn until tha key
is found or there be no mo' elements ta examine up in tha list. If tha list is sorted,
in ascendin order, say, stop searchin as soon as tha key is less than tha current list
element.
535
AB (continued)
Analysis: AB ONLY
1. Da dopest case has key up in tha straight-up original gangsta slot, n' tha search is 0(1).
2. Da most shitty case occurs if tha key is up in tha last slot or not up in tha list fo' realz. All n
elements must be examined, n' tha algorithm is O( n ).
3. On average, there is ghon be n /2 comparisons, which be also O( n ).
BINARY SEARCH
If tha elements is up in a sorted array, a gangbangin' finger-lickin' divide-and-conquer approach serves up a much
more efficient'searchin algorithm. Da followin recursive pseudo-code algorithm
shows how tha fuck tha binary search works.
Assume dat a[low] ... a[high] is sorted up in ascendin order n' dat a method
binSearch returns tha index of key. If key aint up in tha array, it returns -1.
if (low&gt; high) //Base case. No elements left up in array.
else
{
}
NOTE
return -1 j
mid = (low + high)/2j
if (key is equal ta a [mid]) / /found tha key
return mid;
else if (key isk~than a[mid]) //key up in left half of array
&lt; binSearchforkeyin a[low] ta a[mid-1] &gt;
else //key up in right half of array
&lt; binSearch fo' key up in a [mid+1] ta a [high] &gt;
When low n' high cross, there be no mo' elements ta examine, n' key aint in
the array.
Example: suppose 5 is tha key ta be found up in tha followin array:
.. , .......... ".
a[O] a[l] a[2] a[3] a [4] a[5] a[6] a[7] a[8]
1 '" ...4.. .. 5 ...... 7 9 12 15 20 .' .21 . '. . ' . . .....
. ......................... .
Binary search works
only if tha array is
sorted on tha search
key.
536
ABONLY
ABONLY
Use hash codin if
speedy insertion
and retrieval are
required.
Fi rst pass:
Secolld pass:
Third pass:
mid = (8+0)/2
mid = (0+3)/2
mid = (2+3)/2
i\naksiz of Bin,\r\' Search:
4.
1.
2.
Chapta 12 Sortin n' Searching
Peep a[4].
Peep a[l].
Peep a [2]. Yes muthafucka! Key is found.
1. 111 rhe be~t case, tha key is found on tha straight-up original gangsta try (i.e., (low + high)/2 is the
index of key.) This is 0(1).
2. In da most thugged-out shitty case, tha key aint up in tha list or be at either end of a sublist yo. Here
the n clements must be divided by 2 until there is just one element, n' then
that last clement must be tested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This equals 1 + log2 n comparisons. Thus, in
da most thugged-out shitty case, tha algorithm is O(log n) fo' realz. An easy as fuck  way ta find tha number of
comparisons up in da most thugged-out shitty case is ta round n up ta tha next juice of 2 n' take
the exponent. For example, up in tha array above, n = 9. Right back up in yo muthafuckin ass. Suppose 21 was tha key.
Round 9 up ta 16, which equals 2-1. Thus you would need four comparisons to
find dat shit. Try dat shiznit son!
3. Pt III tha average case, you need bout half tha comparisonz of da most thugged-out shitty case, so
the algorithm is still O(log 11).
HASH CODING
Description
Consider tha programmin problem of maintainin a big-ass database, like patient records
in a hospitizzle. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack yo. Hash codin be a technique fo' providin rapid access ta such recordz that
are distinguished by some key field. Y'all KNOW dat shit, muthafucka! Da codin maps each key ta a storage address,
and tha data an: stored up in a hash table. Each data entry up in tha table iz of some type
(tableElementType) n' has a associated key field of type keyType. Ideally, a hash
table should provide fo' efficient insertion n' retrieval of items.
Here i~ a simple example of hash codin fo' realz. A catalog company stores hustla orders
in a array as bigs up. Da last two digitz of tha hustlaz beeper number provide
the index up in tha array fo' dat particular hustlaz order n' shit. Thus, two hustlas with
phone numbers 257-3178 n' 253-5169 gonna git they ordaz stored up in list [78] and
list [69], respectively. In dis example, tha hash table be a array, tha key field be a
phone number, tha hash function is (phone number mod 100), n' tha hash address is
the array index.
Da simpiest implementation of ,\ hash table be a array of data items. Boy it's gettin hot, yes indeed it is. To insert
or retrieve any given item, a hash function is performed on tha key field of tha item,
which returns tha array index or hash address of dat item. This method cannot guarantee
a unique address fo' each data item.
For example, suppose a lil' small-ass bidnizz maintains hommie data up in a list called
employeeList. If tha key field is hoodSecuri tyNo n' tha hash function is
(socialSecurityNo % 100), then 567350347 n' 203479247 both hash ta tha same address:
employeeList [4 7J.
A phat hash function minimizes such collisions by spreadin dem uniformly through
the key field joints fo' realz. A commonly used hash function up in Java is
key.hashCode() % SIZE
where key. hashCode () is tha hashCode value of tha key object (see p. 227) n' SIZE is
the numher ()f slots up in tha hash table.
Hash Coding
Resolvin Collisions
HASH AND SEARCH (OR OPEN ADDRESSING WITH LINEAR
PROBING)
Store tha collidin element up in tha next available slot fo' realz. An example fo' storin data with
keyValue 556677003 is shown up in tha followin table.
employeeList
[00] empty
[01] 453614001
[02] empty
[03] 123467003
[04] 689286004
[05] empty
[99] 618272899
Da hash function yieldz hash address 03 yo, but hommieList [03] already gotz nuff
data, so we try slot [04] n' so on. I aint talkin' bout chicken n' gravy biatch. In dis example, tha freshly smoked up data item gets stored in
employeeList [05]. If tha key hashes ta tha last slot up in tha array n' is filled, treat it as
a circular structure n' go back ta tha beginnin of tha array ta search fo' a empty
slot.
In dis scheme, searchin fo' a given data item involves
1 yo. Hash n' compare.
2. If keys don't match, do a sequential search startin at dat slot up in tha array.
3. Cycle back ta tha beginnin if necessary.
REHASHING
If tha straight-up original gangsta computation causes a cold-ass lil collision, compute a freshly smoked up hash address rockin tha old
hash address as input. Repeat if necessary. Typically, a rehash function has form
(hash address + &lt; const &gt; ) % &lt; number of slots&gt;
where "const" n' "number of slots" is relatively prime (i.e., no common factors
greata than 1). This ensures dat every last muthafuckin index is ghon be covered.
For example, tha hash function fo' dis table is key % 10. The
rehash function is (hash address + 3) % 10. (Note dat 3 n' 10
are relatively prime.) Here is tha steps ta bang 26402 tha fuck into the
table:
26402 % 10 = 02
(2 + 3) % 10 = 05
(5 + 3) % 10 = 08,
(taken)
(taken)
which becomes
the hash address
of tha freshly smoked up item.
[00]
[01]
[02]
[03]
[04]
[05]
[06]
[07]
[08]
[09]
27401
68902
67905
27309
These methodz is simple ta implement but is less than ideal up in resolvin collisions.
If tha table be almost full, a insertion operation becomes O(n). What bigs up
is mo' elegant.
537
538
AD (continlletl)
A hash table do
not provide for
sortin of
elements.
Chapta 12 Sortin n' Searching
CHAINING
In chaining, tha hash address is tha index fo' a array of linked lists called buckets, n' you can put dat on yo' toast. Each
bucket be a linear linked list of data shit dat share tha same hash address.
[00]4453000
[01]4267011 H 85401 111
[02]
[03]
[04]4870041 H 656041 H 21304 1/1
[98]
[99]478699 VI
To bang a item, hash ta tha appropriate bucket n' bang all up in tha front of tha list.
Thus, insertion is 0(1). To search fo' a item, apply tha hash function n' do a
sequential search of tha appropriate list fo' realz. Assumin dat shit is uniformly distributed
in tha hash table, a search should occur up in constant time, which is O( 1).
Featurez of a Dope Hash Function
1. Well shiiiit, it distributes data shit uniformly all up in tha hash
table.
2. Well shiiiit, it serves up fo' O( 1) insertion n' searching.
NOTE ABOUT COLLECTIONS
Da Collections API serves up nuff muthafuckin efficient methodz fo' manipulatin elements, for
example sort n' binarySearch. For tha AP exam yo ass is not sposed ta fuckin know the
usage of these library methods. Yo ass are, however, sposed ta fuckin be familiar wit the
detailz of tha various sortin n' searchin algorithms discussed up in dis chapter.
Run Time of Searchin Algorithms 539
RUN TIME OF SORTING ALGORITHMS _.1Il
Assume dat tha array gotz nuff n elements, n large.
Algorithm
Selection sort
Insertion sort
Mergesort
Quicksort
Best Case Worst Case
O(n)
O(nlogn) O(nlogn)
O(nlogn)
Comment
In each case ~ n comparisons
and 1 swap up in each of n - 1
passes. O(n2)
Best: already sorted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. 1 comparison
and no data moves up in each
of n - 1 passes. O(n)
Worst: sorted up in reverse order.
Needz ~ n comparisons n' n
data moves up in each pass. O(n2)
log2 n splits gives n arrays of
1 element. n elements examined
to merge on each level.
O( n log n) irrespectizzle of data.
Best: log2 n partitionings (pivot
roughly up in middle of each subarray).
Partitionin algorithm
is O( n ), so combination is
O(nlogn).
Worst: ~ n partitionings (array
sorted n' pivot at endpoint of
each subarray), so combination
is O(n2).
--~----.-~ - ._- .. ---- ._-------._--- ~----.-------------.--------~.--- ---------
Heapsort O(nlogn) O(nlogn)
maun.III
Irrespectizzle of data: To fix heap,
examine log2 n levels. To create
original gangsta heap, nl2 passes with
log2 n levels: O( n log n). To
sort, ~ n passes makin 1 swap
and fixin heap on each level:
O(nlogn).
51
RUN TIME OF SEARCHING ALGORITHMS
]  i
Assume
 n elements up in each case, n large.
 Sorted array fo' binary search.
 Uniform distribution of hash addresses up in hash table.
ABONLY
ABONLY
540
Algorithm
Sequential search
RunTime
(Average &amp;
Worst Case)
O(n)
Chapta 12 Sortin n' Searching
Comment
Examine each element sequentially
until key found.
-------------------- -------------------
Binary search O(logn)
--- -------- ----------
Hash codin 0(1)
"Divide n' conquer." log2 n splits of
array until just 1 element ta examine.
Git hash address (1 move). Find element
(constant time).
Chapta Summary
Yo ass should not memorize any sortin code. Yo ass must, however, be familiar with
the mechanizzle used up in each of tha sortin algorithms. Boy it's gettin hot, yes indeed it is. For example, you should be able
to explain each of tha following: how tha fuck tha merge method of mergesort works; what tha fuck the
purpose of tha pivot element up in quicksort is; n' how tha fuck ta form a heap up in heapsort. You
must know tha dopest n' most shitty case thangs fo' each of tha sortin algorithms, and
the big-O run times up in each case. Quicksort n' heapsort is fo' level AB hustlas
only.
Be familiar wit tha sequential n' binary search algorithms. Boy it's gettin hot, yes indeed it is. Yo ass should know that
a binary search is mo' efficient than a sequential search. Level AB hustlas should
know tha big-O run timez of each type of search fo' realz. All hustlas should know dat a
binary search can only be used fo' a array dat is sorted on tha search key.
Level AB hustlas should know what tha fuck hash codin is, n' tha conditions dat make
a phat hash table. Know tha various steez fo' resolvin collisions, n' tha big-O
analysis fo' insertion n' lookup algorithms.
Multiple-Choice Thangs on Sortin n' Searching
MULTIPLE-CHOICE QUESTIONS ON SORTING AND
SEARCHING
-----------------------------g~--~~~~------------------
1. Da decision ta chizzle a particular sortin algorithm should be made based on
I Run-time efficiency of tha sort
II Size of tha array
m Space efficiency of tha algorithm
(A) I only
(B) Pt II only
(C) monly
(0) I n' Pt II only
(E) I, Pt II, n' m
2. Da followin code fragment do a sequential search ta determine whether a
given integer, value, is stored up in a array a[O] ... a[n-1]. .
int i = OJ
while U* boolean expression *J)
{ .
i++j
}
if (i == n)
return -1j
else
return ij
Ilvalue not found
II value found at location i
Which of tha followin should replace 1* boolean expression *1 so dat tha algorithm
works as intended?
(A) value != a[i]
(B) i &lt; n &amp;&amp; value == a[i]
(C) value != a[i] &amp;&amp; i &lt; n
(0) i &lt; n &amp;&amp; value != a[i]
(E) i &lt; n Pt II value != a[i]
3 fo' realz. A feature of data dat is used fo' a funky-ass binary search but not necessarily used fo' a
sequential search is
(A) length of list.
(B) type of data.
(C) order of data.
(0) smallest value up in tha list.
(E) median value of tha data.
541
542 Chapta 12 Sortin n' Searching
4 fo' realz. Array unsortedArr gotz nuff a unsorted list of integers fo' realz. Array sortedArr gotz nuff
a sorted list of integers. Which of tha followin operations is mo' efficient
for sortedArr than .unsortedArr, biatch? Assume da most thugged-out efficient algorithms is used.
I Insertin a freshly smoked up element
II Searchin fo' a given element
TIl Computin tha mean of tha elements
(A) I only
(B) Pt II only
(C) TIlonly
(0) I n' Pt II only
(E) I, Pt II, n' TIl
5 fo' realz. An algorithm fo' searchin a big-ass sorted array fo' a specific value x compares
every third item up in tha array ta x until it findz one dat is pimped outa than or equal
to x. When a larger value is found, tha algorithm compares x ta tha previous
two items. Boy it's gettin hot, yes indeed it is. If tha array is sorted up in increasin order, which of tha followin raps about
all cases when dis algorithm uses fewer comparisons ta find x than would
a binary search?
(A) It aint NEVER gonna use fewer comparisons.
(B) When x is up in tha middle posizzle of tha array
(C) When x is straight-up close ta tha beginnin of tha array
(0) When x is straight-up close ta tha end of tha array
(E) When x aint up in tha array
6 fo' realz. Assume dat a[O] , ... a[N-1] be a array of N positizzle integers n' dat tha following
assertion is true:
a[O] &gt; a[k] fo' all k such dat 0 &lt; k &lt; N
Which of tha followin must be true?
(A) Da array is sorted up in ascendin order n' shit. .
(B) Da array is sorted up in descendin order.
(C) All joints up in tha array is different.
(0) a[O] holdz tha smallest value up in tha array.
(E) a[O] holdz tha phattest value up in tha array.
7. Da followin code is designed ta set index ta tha location of tha straight-up original gangsta occurrence
of key up in array a n' ta set index ta -1 if key aint up in a.
index = 0;
while (a[index] != key)
index++;
if (a[index] != key)
index = -1;
In which case will dis program definitely fail ta big-ass up tha task busted lyrics about?
(A) When key is tha straight-up original gangsta element of tha array
(B) When key is tha last element of tha array
(C) When key aint up in tha array
(0) When key equals 0
(E) When key equals a [key]
Multiple-Choice Thangs on Sortin n' Searching
8. Refer ta method search.
1* Precondition: v[0] ... v[v.length-1] is initialized.
* Postcondition: Returns k such dat -1 &lt;= k &lt;= v.length-1.
* . If k &gt;= 0 then v[k] == key. If k == -1,
* then key != any of tha elements up in v. *1
hood static int search(int[] v, int key)
{
}
int index = 0;
while (index &lt; v.length &amp;t v[index] &lt; key)
index++;
if (index != v.length)
retum index;
else
retum -1;
Assumin dat tha method works as intended, which of tha followin should be
added ta tha precondizzle of search?
(A) v is sorted smallest ta phattest.
(B) v is sorted phattest ta smallest.
(C) v is unsorted.
(D) There be at least one occurrence of key up in v.
(E) key occurs no mo' than once up in v.
Thangs 9-14 is based on tha binSearch method n' tha private instizzle variable
a fo' some class:
private int[] a;
1* Do binary search fo' key up in array a[O] ... a[a.length-1],
* sorted up in ascendin order.
* Postcondition: Returns index such dat a[index]==key.
* If key not up in a, returns -1. *1
hood int binSearch(int key)
{
}
int low = 0;
int high = a.length - 1;
while (low &lt;= high)
{
}
int mid = (low + high) I 2;
if (a[mid] == key)
return mid;
else if (a[mid] &lt; key)
low" mid + 1;
else
high = mid - 1;
return -1;
A binary search is ghon be performed on tha followin list.
a[O]
4
a[1]
7
a[2]
9
a[3]
11
a[4]
20
a[5]
24
a[6]
30
a [7]
41
543
544
ABONLY
Chapta 12 Sortin n' Searching
9. To find tha key value 27, tha search interval afta tha straight-up original gangsta pass all up in tha while
loop will be
(A) a[O] ... a[7]
(B) a [5] ... a [6]
(C) a[4] ... a[7]
(0) a[2] ... a[6]
(E) a[6] ... a[7]
10 yo. How tha fuck nuff iterations is ghon be required ta determine dat 27 aint up in tha list?
(A) 1
(B) 3
(C) 8
(0) 27
(E) An infinite loop since 27 aint found
11. What tha fuck iz ghon be stored up in y afta executin tha following?
int y = binSearch(4)j
(A) 20
(B) 7
(C) 4
(0) 0
(E) -1
12. If tha test fo' tha while loop is chizzled to
while (low &lt; high)
the binSearch method do not work as intended. Y'all KNOW dat shit, muthafucka! Which value up in tha given list
will not be found?
(A) 4
(B) 7
(C) 11
(0) 24
(E) 30
13. For binSearch, which of tha followin assertions is ghon be legit followin every
iteration of tha while loop?
(A) key = a [mid] or key aint up in a.
(B) a[low] ~ key ~ a [high]
(C) low ~ mid ~ high
(0) key = a [mid], or a [low] ~ key ~ a [high]
(E) key = a [mid], or a [low] ~ key ~ a [high], or key aint up in array a.
14. Right back up in yo muthafuckin ass. Suppose n = a.length fo' realz. A loop invariant fo' tha while loop is: key aint up in array
a, or
(A) a [low] &lt; key &lt; a [high] ,
(B) a [low] ~ key ~ a [high] ,
(C) a[low] ~ key ~ a [high] ,
(0) a[low] &lt; key &lt; a[high],
(E) a [low] ~ key ~ a [high],
o ~ low~high+1 ~n
o ~ low~high+1 ~n
o ~ low~high~n
o ~ low ~ high ~ n
o ~ low ~ high ~ n-1
Multiple-Choice Thangs on Sortin n' Searching
For Thangs 15-19 refer ta tha insertionSort method n' tha private instizzle variable
a, both up in a Sorta class.
private Comparable[] a;
1* Precondition: a[O],a[l] ... a[a.length-1] be a unsorted array
* of Comparable objects.
* Postcondition: Array a is sorted up in descendin order n' shit. *1
hood void insertionSort()
{
}
for (int i = 1; i &lt; a.length; i++)
{
}
Comparable temp = a[i];
int j = i - 1;
while (j &gt;= 0 &amp;&amp; temp.compareTo(a[j]) &gt; 0)
{
}
a[j+1] = a[j];
j--;
a[j+1] = temp;
15 fo' realz. An array of Integer is ta be sorted freshest ta smallest rockin tha insertionSort
method. Y'all KNOW dat shit, muthafucka! H tha array originally gotz nuff
1 7 9 5 4 12
what will it be lookin like afta tha third pass of tha fo' loop?
(A) 9 7 1 5 4 12
(B) 9 7 5 1 4 12
(C) 12 9 7 1 5 4
(D) 12 9 7 5 4 1
(E) 9 7 12 5 4 1
16. When sorted freshest ta smallest wit insertionSort, which list will need the
fewest chizzlez of posizzle fo' individual elements?
(A) 5, 1, 2, 3, 4, 9
(B) 9,5, 1,4,3,2
(C) 9,4,2, 5, 1, 3
(D) 9, 3, 5, 1,4,2
(E) 3,2, 1,9,5,4 ,
17. When sorted freshest ta smallest wit insertionSort, which list will need the
greatest number of chizzlez up in position?
(A) 5, 1,2,3,4, 7, 6, 9
(B) 9,5, 1,4,3,2, 1, a
(C) 9,4, 6,2, 1, 5, 1,3
(D) 9,6,9,5,6,7,2,0
(E) 3,2, 1, 0, 9, 6, 5, 4
545
546 Chapta 12 Sortin n' Searching
18. While typin tha insertionSort method, a 'programmer by fuck up enters
while (temp.compareTo( a[j]) &gt; 0)
instead of
while (j &gt;= 0 &amp;t temp.compareTo( a[j]) &gt; 0)
Despite dis mistake, tha method works as intended tha last time tha programmer
entas a array ta be sorted up in descendin order n' shit. Which of tha following
could explain this?
I Da first element up in tha array was tha phattest element up in tha array.
II Da array was already sorted up in descendin order.
III Da first element was less than or equal ta all tha other elements up in tha array.
(A) I only
(B) Pt II only
(C) Pt III only
(D) I n' Pt II only
(E) Pt II n' Pt III only
19 fo' realz. A loop invariant fo' tha outa loop (the fo' loop) is
(A) a[O] ~a[l] ~ .. .~a[i-l], O~i~a.length
(B) a[O] &gt;a[l] &gt;...&gt;a[i-l], l~i~a.length
(C) a[O] ~ a[l] ~ ... ~ a[i], 0 ~:i. ~ a.length-l
(D) a[O] &gt;a[l] &gt;...&gt;a[i], l~i~a.length-l
(E) a[O] ~ a[l] ~ ... ~ a[i-l], 1 ~ i ~ a.length
Multiple-Choice Thangs on Sortin n' Searching
Consider tha followin class fo' Thangs 20 n' 21.
1* A class dat sorts a array of objects from
* phattest ta smallest rockin a selection sort. *1
hood class Sorter
{
}
20.
private Comparable[] aj
hood Sorter(Comparable[] arr)
{ a = arrj }
1* Swap a[i] n' a[j] up in array a. *1
private void swap(int i, int j)
{ 1* implementation not shown *1 }
1* Sort array a gangbangin' from phattest ta smallest rockin selection sort.
* Precondition: a be a array of Comparable objects, n' you can put dat on yo' toast. *1
hood void selectionSort()
{
}
for (int i = OJ i &lt; a.length - 1j i++)
{
}
Ilfind max element up in a[i+1] ta a[n-1]
Comparable max = a[i]j
int maxPos = ij
for (int j = i + 1j j &lt; a.lengthj j++)
if (max.compareTo(a[j]) &lt; 0) Ilmax less than a[j]
{
}
max = a[j] j
maxPos = jj
swap(i, maxPos)j Iiswap a[i] n' a[maxPos]
If a array of Integer gotz nuff tha followin elements, what tha fuck would tha array
look like afta tha third pass of selectionSort, sortin from high ta low?
89 42 -3 13 109 70 2
(A) 109 89 70 13 42 -3 2
(B) 109 89 70 42 13 2 -3
(C) 109 89 70 -3 2 13 42
(0) 89 42 13 -3 109 70 2
(E) 109 89 42 -3 13 70 2
21 fo' realz. A loop invariant fo' tha outa fo' loop of selectionSort is
(A) a[O] ~a[1] ~...~a[i-1], 0~i~a.length-1
(B) a[O] ~ a[1] ~ ... ~ a[i], 0 ~ i ~ a.length-1
(C) a[O] ~a[1] ~...~a[i-1], 0~i~a.length-2
(0) a[O] ~a[1] ~...~a[i], 0~i~a.length-2
(E) a[O] ~a[1] ~...~a[a.length-1], 0~i~a.length-1
547
ABONLY
548 Chapta 12 Sortin n' Searching
22. Da elements up in a long-ass list of integers is roughly sorted up in decreasin order n' shit. No
more than 5 cement of tha elements is outta order n' shit. Which of tha followin is
a valid reason fo' rockin a insertion sort rather than a selection sort ta sort this
list tha fuck into decreasin order?
I There is ghon be fewer comparisonz of elements fo' insertion sort.
II There is ghon be fewer chizzlez of posizzle of elements fo' insertion sort.
m There is ghon be less space required fo' insertion sort.
(A) I only
(B) Pt II only
(C) monly
(0) I n' Pt II only
(E) I, Pt II, n' m
23. Da code shown sorts array a[O] ... a[a.length-1] up in descendin order.
hood static void sort(Comparable[] a)
{
for (int i = 0; i &lt; a.length - 1; i++)
for (int j = 0; j &lt; a.length - i - 1; j++)
if (a[j] .compareTo(a[j+1]) &lt; 0)
}
This be a example of
(A) selection sort.
(B) insertion sort.
(C) mergesort.
(0) quicksort.
swap(a. j. j + 1); Pt II swap a[j] n' a[j+1]
(E) none of tha above.
24. Which of tha followin be a valid reason why mergesort be a funky-ass betta sortin algorithm
than insertion sort fo' sortin long lists?
I Mergesort requires less code than insertion sort.
II Mergesort requires less storage space than insertion sort.
III Mergesort runs fasta than insertion sort.
(A) I only
(B) Pt II only
(C) m only
(0) I n' Pt II only
(E) Pt II n' ill only
25 fo' realz. A big-ass array of lowercase charactas is ta be searched fo' tha pattern "pqrs." The
first step up in a straight-up efficient searchin algorithm is ta peep charactas wit index
(A) 0, 1, 2, ... until a "p" is encountered
(B) 0, 1, 2, ... until any letta up in "p" .,. "s" is encountered
(C) 3,7, 11, ... until a "s" is encountered
(0) 3, 7, 11, ... until any letta up in "p" ... "s" is encountered
(E) 3,7, 11, ... until any letta other than "p" ... "s" is encountered
Multiple-Choice Thangs on Sortin n' Searching
26. Da array names [0] , names [1], ... , names [9999] be a list of 10,000 name strings.
Da list is ta be searched ta determine tha location of some name X up in tha list.
Which of tha followin preconditions is necessary fo' a funky-ass binary search?
(A) There is no duplicate names up in tha list.
(B) Da number of names N up in tha list is large.
(C) Da list is up in alphabetical order.
(D) Name X is definitely up in tha list.
(E) Name X occurs near tha middle of tha list.
27. Consider tha followin method:
//Precondition: a[O],a[l] ... a[n-1] contain integers.
hood static int someMethod(int[] a, int n, int value)
{
}
if (n == 0)
return -1;
else
{
}
if (a[n-1] == value)
return n - 1;
else
return someMethod(a, n - 1, value);
Da method shown be a example of
(A) insertion sort.
(B) mergesort.
(C) selection sort.
(D) binary search.
(E) sequential search.
28. Da partizzle method fo' quicksort partitions a list as bigs up:
(i) A pivot element is selected from tha array.
(ii) Da elementz of tha list is rearranged such dat all elements ta tha left
of tha pivot is less than or equal ta it; all elements ta tha right of the
pivot is pimped outa than or equal ta dat shit.
Partitionin tha array requires which of tha following?
(A) A recursive algorithm
(B) A temporary array
(C) An external file fo' tha array
(D) A swap algorithm fo' interchangin array elements
(E) A merge method fo' mergin two sorted lists
29 fo' realz. Assume dat mergesort is ghon be used ta sort a array arr of n integers tha fuck into increasing
order n' shit. What tha fuck iz tha purpose of tha merge method up in tha mergesort algorithm?
(A) Partizzle arr tha fuck into two partz of roughly equal length, then merge these parts.
(B) Use a recursive algorithm ta sort arr tha fuck into increasin order.
(C) Divide arr tha fuck into n subarrays, each wit one element.
(D) Merge two sorted partz of arr tha fuck into a single sorted array.
(E) Merge two sorted arrays tha fuck into a temporary array dat is sorted.
549
AS'ONLY
550
ABONLY
Chapta 12 Sortin n' Searching
30 fo' realz. A binary search is ta be performed on a array wit 600 elements, n' you can put dat on yo' toast. In tha worst
case, which of tha followin dopest approximates tha number of iterationz of the
algorithm?
(A) 6
(B) 10
(C) 100
(D) 300
(E) 600
31 fo' realz. A most shitty case thang fo' insertion sort would be
I A list up in erect sorted order.
II A list sorted up in reverse order.
III A list up in random order.
(A) I only
(B) Pt II only
(C) Pt III only
(D) I n' Pt II only
(E) Pt II n' Pt III only
32. Which of tha followin represents a heap?
(A) I only
(B) Pt II only
(C) Pt III only
(D) I n' Pt III only
(E) Pt II n' Pt III only
33. Da list
I Pt II
17 9 2 7 21 18 4 5
I
III
is ta be sorted tha fuck into ascendin order rockin heapsort. What tha fuck iz tha level of tha binary
tree dat is ghon be formed, given dat tha root be at level O?
(A) 0
(B) 1
(C) 2
(D) 3
(E) 4
Multiple-Choice Thangs on Sortin n' Searching
34 fo' realz. Assume dat array a[O] ... a[6] = 6 1 5 9 8 4 7 is ta be sorted up in increasing
order rockin heapsort. Which of tha followin represents tha erect sequence of
swaps ta be made ta form tha array tha fuck into tha original gangsta heap?
(A) 6 1 7 9 8 4 5
6 9 7 1 8 4 5
9 6 7 1 8 4 5
9 8 7 1 6 4 5
(B) 6 9 5 1 8 4 7
6 9 7 1 8 4 5
9 6 7 1 8 4 5
9 8 7 1 6 4 5
(C) 6 1 7 9 8 4 5
7 1 6 9 8 4 5
7 9 6 1 8 4 5
9 7 6 1 8 4 5
9 8 6 1 7 4 5
(D) 6 9 5 1 8 4 7
9 6 5 1 8 4 7
9 6 7 1 8 4 5
9 8 7 1 6 4 5
(E) None of these sequences is erect.
35 fo' realz. An array is ta be sorted tha fuck into increasin order rockin quicksort yo. H tha array is
initially sorted up in increasin order, which of tha followin must be true?
(A) Da algorithm is ghon be O(n).
(B) Da algorithm is ghon be O(logn).
(C) Da algorithm is ghon be O(n log n).
(D) Da algorithm is ghon be O(n2).
(E) There is insufficient shiznit ta cook up a prediction bout efficiency.
36. Da efficiency of hash codin dependz on which of tha following:
I Da number of collisions dat occur
II Da size of tha data shit up in tha list
III Da method of dealin wit collisions
(A) I only
(B) Pt III only
(C) I n' Pt III only
(D) I n' Pt II only
(E) I, IT, n' m
551
AD (continued)
552 Chapta 12 Sortin n' Searching
37. Da followin key joints is ta be banged tha fuck into tha hash table shown up in tha order
gIven:
10 28 2 7 45 25 40 29
::tS-~-ee_x--+_0-t-1- ---i-r2 T3~~~~~ ~-j_-6_1-7-r8~-19 10
Da hash function is key % 11. Collisions is ghon be resolved wit tha Open Addressing
and Linear Probin ("hash-and-search") method. Y'all KNOW dat shit, muthafucka! Which array slot will
29 eventually occupy?
(A) 7
(B)- 8
(C) 9
(0) 10
(E) 0
38 fo' realz. An array gotz nuff data dat was hash coded tha fuck into it yo. How tha fuck should dis array be
searched fo' a given item?
(A) A linear search should be used on tha key data fields.
(B) If tha array is sorted on tha key fields, a funky-ass binary search should be used.
(C) Da Java % operation should be applied ta tha key of tha item ta obtain the
correct array location.
(0) Da hashCode method of tha item should be applied ta tha key ta obtain
the erect array location.
(E) Da hash function n' a cold-ass lil collision resolution algorithm should be applied to
the key ta find tha erect location.
39 fo' realz. A certain hash function h(x) on a key field places recordz wit tha followin key
fieldz tha fuck into a hash table.
62 79 81 12 54 97 34
Collisions is handled wit a rehashin function r(x), which takes as a argument
the result of applyin h(x). Da key joints is entered up in tha order shown
above ta produce tha followin table:
What is h(x) n' r(x), respectively?
(A) key % 20, (result + 13) % 20
(B) key % 20, result % 20
(C) key % 30, (result + 14) % 20
(0) key % 20, (result + 7) % 20
(E) key % 30, (result + 7) % 30
Multiple-Choice Thangs on Sortin n' Searching
Thangs 40 n' 41 is based on tha Sort intercourse n' MergeSort n' QuickSort
classes shown below.
hood intercourse Sort
{
void sort 0 ;
}
hood class MergeSort implements Sort
{
}
private Comparable[] a;
II constructor
hood MergeSort(Comparable[] arr)
{ a = arr; }
IIMerge a[lb] ta a[mi] n' a[mi+1] ta a[ub].
IIPrecondition: a[lb] ta a[mi] n' a[mi+1] ta a[ub] both
II sorted up in increasin order.
private void merge(int lb, int mi, int ub)
{ 1* Implementation not shown. I aint talkin' bout chicken n' gravy biatch. *1 }
IISort a[first] .. a [last] up in increasin order rockin mergesort.
IIPrecondition: a be a array of Comparable objects.
private void sort(int first, int last)
{
}
int mid;
if (first != last)
{
}
mid = (first + last) I 2;
sort(first, mid);
sort(mid + 1, last);
merge(first, mid, last);
IISort array a gangbangin' from smallest ta phattest rockin mergesort.
IIPrecondition: a be a array of Comparable objects.
hood void sort()
{
sort(O, a.length - 1);
}
hood class QuickSort implements Sort
{
private Co~parable[] a;
Ilconstructor
hood QuickSort(Comparable[] arr)
{ a = arr; }
IISwap a[i] n' a[j] up in array a.
private void swap(int i, int j)
{ 1* Implementation not shown. I aint talkin' bout chicken n' gravy biatch. *1 }
553
AS (continued).
554
}
Chapta 12 Sortin n' Searching
IIReturns tha index pivPos such dat a[first) ta a[last)
II is partitioned.
Ila[first .. pivPos) &lt;= a[pivPos) n' a[pivPos .. last] &gt;= a[pivPos)
private int partition(int first, int last)
{ 1* Implementation not shown. I aint talkin' bout chicken n' gravy biatch. *1 }
IISort a[first) .. a[last) up in increasin order rockin quicksort.
IIPrecondition: a be a array of Comparable objects.
private void sort(int first, int last)
{
}
if (first &lt; last)
{
}
int pivPos = partition(first, last);
sort(first, pivPos - 1);
sort(pivPos + 1, last);
IISort array a up in increasin order.
hood void sort()
{
sort(O, a.length - 1);
}
40. Notice dat tha MergeSort n' QuickSort classes both gotz a private helper
method dat implements tha recursive sort routine. For dis example, which
of tha followin aint a valid reason fo' havin a helper method?
I Da helper method hides tha implementation detailz of tha sortin algorithm
from tha user.
II A method wit additionizzle parametas is needed ta implement tha recursion.
III Providin a helper method increases tha run-time efficiency of tha sorting
algorithm.
(A) Ionly
(B) Pt II only
(C) Pt III only
(D) I n' Pt II only
(E) I, Pt II, n' Pt III
Multiple-Choice Thangs on Sortin n' Searching
41 fo' realz. A piece of code ta test tha QuickSort n' MergeSort classes be as bigs up:
IISmoke a array of Comparable joints
Comparable[] strArray = makeArray(strList)j
writeList(strArraY)j
1* mo' code *1
where make Array creates a array of Comparable from a list strList. Which
of tha followin replacements fo' 1* mo' code *1 is reasonable code ta test
QuickSort n' MergeSort, biatch? Yo ass can assume wri teList erectly writes up an
array of String.
(A) Sort q = freshly smoked up QuickSort (strArray) j
Sort m = freshly smoked up MergeSort(strArraY)j
q.sortO j
writeList(strArraY)j
m.sortO j
writeList(strArraY)j
(B) QuickSort q = freshly smoked up Sort(strArraY)j
MergeSort m = freshly smoked up Sort(strArraY)j
q.sortO j
writeList(strArraY)j
m.sortO j
writeList(strArraY)j
(C) Sort q = freshly smoked up QuickSort(strArraY)j
Sort m = freshly smoked up MergeSort(strArraY)j
Comparable[] copyArray = makeArray(strList)j
q.sort(O, strArray.length - 1)j
writeList(strArraY)j
m.sort(O, copyArray.length - 1)j
writeList(copyArraY)j
0) QuickSort q = freshly smoked up Sort(strArraY)j
Comparable[] copyArray = makeArray(strList)j
MergeSort m = freshly smoked up Sort(strArraY)j
q.sortO j
writeList(strArraY)j
m.sortO j
writeList(copyArraY)j
(E) Sort q = freshly smoked up QuickSort(strArraY)j
Comparable[] copyArray = makeArray(strList)j
Sort m = freshly smoked up MergeSort(copyArraY)j
q.sortO j
writeList(strArraY)j
m.sortO;
writeList(copyArraY)j
42. Which represents da most thugged-out shitty case performizzle of tha sequential search n' binary
search, respectively?
(A) O(n2),O(nlogn)
(B) O(n),O(nlogn)
(C) O(n),O(n)
0) O(n),O(logn)
(E) O( n2), O(log n)
555
556 Chapta 12 Sortin n' Searching
43 fo' realz. A typical algorithm ta search a ordered list of numbers has a execution time
of 0(log2 n). Which of tha followin chizzlez is closest ta tha maximum number
of times dat such a algorithm. will execute its main comparison loop when
searchin a ordered list of 1 mazillion numbers?
(A) 6
(B) 20
(C) 100
(D) 120
(E) 1000
44 fo' realz. A certain algorithm sequentially examines a list of n random integers n' then.
outputs tha number of times 8 occurs up in tha list. Usin big-O notation, this
algorithm is
(A) 0(1)
(B) O(rn)
(C) O(n)
(D) 0(n2)
(E) O(logn)
45. Which represents da most thugged-out shitty case performizzle of mergesort, quicksort, n' heapsort,
respectively?
(A) O(nlogn), O(nlogn), O(nlogn)
(B) O(nlogn), 0(n2), O(nlogn)
(C) 0(n2), 0(n2), 0(n2)
(D) O(logn), 0(n2), O(logn)
(E) 0(2n), 0(n2), O(nlogn)
46. Consider these three tasks:
I A sequential search of a array of n names
II A binary search of a array of n names up in alphabetical order
III A quicksort tha fuck into alphabetical order of a array of n names dat is initially
in random order
For big-ass n, which of tha followin lists these tasks up in order (from least ta top billin)
of they average case run times?
(A) Pt II I Pt III
(B) I Pt II Pt III
(C) Pt II Pt III I
(D) Pt III I Pt II
(E) Pt III Pt II I
Answers Explained
ANSWER KEY
1. E 17 fo' realz. A 33. D
2. D 18. D 34 fo' realz. A
3. C 19. E 35. E
4. B 20 fo' realz. A 36. C
5. C 21 fo' realz. A 37. C
6. E 22 fo' realz. A 38. E
7. C 23. E 39. D
8 fo' realz. A 24. C 40. C
9. C 25. D 41. E
10. B 26. C 42. D
11. D 27. E 43. B
12 fo' realz. A 28. D 44. C
13. E 29. D 45. B
14. B 30. B 46 fo' realz. A
15. B 31. B
16. B 32. C
.._ _. ..._ _. ..._ _. ..._ _. ..._ w_m_ ________w r~_ _~_. ____________ _
ANSWERS EXPLAINED
1. (E) Da time n' space requirementz of sortin algorithms is affected by all
three of tha given factors, so all must be considered when choosin a particular
sortin algorithm.
2. (0) Chizzle B don't make sense: Da loop is ghon be exited as soon as a value is
found dat do not equal a[i]. Eliminizzle chizzle A cuz, if value aint up in the
array, a[i] will eventually go outta bounds. Yo ass need tha i &lt; n
part of tha boolean expression ta stay tha fuck away from all dis bullshit. Da test i &lt; n, however, must precede
value ! = a [i] so dat if i &lt; n fails, tha expression is ghon be evaluated as false,
the test is ghon be short-circuited, n' a out-of-range error is ghon be avoided. Y'all KNOW dat shit, muthafucka! Chizzle
C do not stay tha fuck away from dis error. Shiiit, dis aint no joke. Chizzle E is wack cuz both partz of tha expression
must be legit up in order ta continue tha search.
3. (C) Da binary search algorithm dependz on tha array bein sorted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Right back up in yo muthafuckin ass. Sequential
search has no orderin requirement. Both depend on chizzle A, tha length of the
list, while tha other chizzlez is irrelevant ta both algorithms.
4. (B) Insertin a freshly smoked up element is quick n' easy as fuck  up in a unsorted array-just add
it ta tha end of tha list. Computin tha mean involves findin tha sum of the
elements n' dividin by n, tha number of elements, n' you can put dat on yo' toast. Da execution time is the
same whether tha list is sorted or not. Operation TI, searching, is inefficient fo' an
unsorted list, since a sequential search must be used. Y'all KNOW dat shit, muthafucka! In sorteciArr, tha efficient
binary search algorithm, which involves fewer comparisons, could be used. Y'all KNOW dat shit, muthafucka! In
fact, up in a sorted list, even a sequential search would be mo' efficient than fo' an
557
558 Chapta 12 Sortin n' Searching
unsorted list: H tha search item was not up in tha list, tha search could stop as soon
as tha list elements was pimped outa than tha search item.
5. (C) Suppose tha array has 1000 elements n' x is somewhere up in tha straight-up original gangsta 8 slots.
Da algorithm busted lyrics bout will find x rockin no mo' than five comparisons fo' realz. A
binary search, by contrast, will chop tha array up in half n' do a cold-ass lil comparison six
times before examinin elements up in tha straight-up original gangsta 15 slotz of tha array (array size after
each chop: 500, 250, 125, 62, 31, 15).
6. (E) Da assertion states dat tha straight-up original gangsta element is pimped outa than all tha other elements
in tha array. This eliminates chizzlez A n' D. Chizzlez B n' Care
incorrect cuz you have no shiznit bout tha relatizzle sizez of elements
a[1] ... a [N-1].
7. (C) When key aint up in tha array, index will eventually be big-ass enough that
a[index] will cause a ArraylndexOutOfBoundsException. I aint talkin' bout chicken n' gravy biatch. In chizzlez A n' B,
the algorithm will find key without error. Shiiit, dis aint no joke. Chizzle D won't fail if a is up in tha array.
Choice E will work if a [key] aint outta range.
8. (A) Da algorithm uses tha fact dat array v is sorted smallest ta phattest.
Da while loop terminates-which means dat tha search stops-as soon as
v[index] &gt;= key. '
9. (C) Da first pass uses tha interval a[O] ... a[7]. Right back up in yo muthafuckin ass. Since mid = (0 + 7)/2 = 3,
low gets adjusted ta mid + 1 = 4, n' tha second pass uses tha interval
a[4] ... a[7].
10. (B) First pass: compare 27 wit a [3] , since low = a high = 7 mid = (0 + 7)/2 = 3.
Second pass: compare 27 wit a [5] , since low = 4 high = 7 mid = (4 + 7)/2 = 5.
Third pass: compare 27 wit a [6], since low = 6 high = 7 mid = (6 + 7)/2 = 6.
Da fourth pass don't happen, since low = 6, high = 5, n' therefore tha test
(low &lt;= high) fails yo. Herez tha general rule fo' findin tha number of iterations
when key aint up in tha list: H n is tha number of elements, round n up ta the
nearest juice of 2, which is 8 up in dis case. 8 = 23, which implies 3 iterations of
the "divide-and-compare" loop.
11. (D) Da method returns tha index of tha key parameter, 4. Right back up in yo muthafuckin ass. Since a[O] gotz nuff
4, binSearch(4) will return O.
12. (A) Try 4 yo. Here is tha joints fo' low, high, n' mid when searchin fo' 4:
First pass: low = 0, high = 7, mid = 3
Second pass: low = 0, high = 2, mid = 1
Afta dis pass, high gets adjusted ta mid -1, which is o. Now low equals high,
and tha test fo' tha while loop fails. Da method returns -1, indicatin dat 4
wasn't found.
13. (E) When tha loop is exited, either key = a [mid] (and mid has been returned) or
key has not been found, up in which case either a [low] ~ key ~ a[high] or key is
not up in tha array. Da erect assertion must account fo' all three possibilities.
14. (B) Note dat low is initialized ta a n' high is initialized ta n - 1. Well shiiiit, it would
appear dat 0 ~ low ~ high ~ n - 1. In tha algorithm, however, if key is not
in tha array, low n' high cross, which means low &gt; high up in dat instance.
Da erect loop invariant inequalitizzle dat takes all cases tha fuck into account is, therefore,
0 ~ low ~ high + 1 ~ n, which eliminates chizzlez C, D, n' E. In tha algorithm,
the endpointz of tha freshly smoked up subarray ta be considered is adjusted ta include
Answers Explained
15.
a[mid+l] (if itz tha right half) or a[mid-l] (for tha left half). This means that
key can be at one of tha endpoints, n' you can put dat on yo' toast. Thus, a [low] ~ key ~ a[high] is tha erect
assertion.
(B) Start wit tha second element up in tha array.
Afta 1st pass: 7 1 9 5 4 12
Afta 2nd pass: 9 7 1 5 4 12
Afta 3rd pass: 9 -7 5 1 4 12
16. (B) An insertion sort compares a[l] n' a[O]. If they is not up in tha erect
order, a[O] is moved n' a[l] is banged up in its erect position. I aint talkin' bout chicken n' gravy biatch. a[2] is then
inserted up in its erect position, n' a[0] n' a[1] is moved if necessary, n' so
on. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Since B has only one element outta order, it will require tha fewest chizzles.
17. (A) This list be almost sorted up in reverse order, which is da most thugged-out shitty case fo' insertion
sort, requirin tha top billin number of comparisons n' moves.
18. (0) j &gt;= 0 be a stoppin condizzle dat prevents a element dat is larger than
all dem ta tha left of it from goin off tha left end of tha array. If no error
occurred, it means dat tha phattest element up in tha array was a [0] , which was true
in thangs I n' Pt II. Omittin tha j &gt;= 0 test will cause a run-time (out-of-range)
error whenever temp is bigger than all elements ta tha left of it (i.e., tha insertion
point is 0).
19. (E) Note dat i is initialized ta 1, n' afta tha final pass all up in tha fo' loop,
i equals a . length. Thus, 1 ~ i ~ a . length, which eliminates chizzlez A, C, and
D. Eliminizzle chizzle B since there could be duplicates up in tha array n' a [0] could
equal a[l] ....
20.
Afta initialization: i = 1 n' a[O] is sorted.
Afta first pass: i = 2 n' a[O] ~ a[l].
Afta second pass: i = 3 n' a[O] ~ a[l] ~ a[2].
In general, afta initialization n' each time
a[O] ~a[l] ~...~a[i-ll.
(A) Afta 1st pass: 109 42 -3
Afta 2nd pass: ~09 89 -3
Afta 3rd pass: 109 89 70
the fo' loop is completed,
13 89 70 2
13 42 70 2
13 42 -3 2
21. (A) i is initialized ta 0, n' afta tha final pass all up in tha fo' loop, i equals
a.length - 1. Thus, 0 ~ i ~ a.length - 1, which eliminates' chizzlez C n' D.
Choice E is wack cuz it implies dat tha whole array is sorted afta each pass
all up in tha loop.
Afta initialization: i = 0, n' no elements is sorted.
Afta first pass: i = 1, n' a [0] is sorted.
Afta second pass: i = 2, n' a[O] ~ a[l].
In general, afta initialization n' each time tha fo' loop lS completed,
a[O] ~ a[l] ~ ... ~ a[i-l]. This rulez up chizzle B.
559
AB (contimutd)
ABONLY
ABONLY
560
ABONLY
Chapta 12 Sortin n' Searching
22. (A) Look at a lil' small-ass array dat be almost sorted:
10 8 9 6 2
For insertion sort you need four passes all up in dis array.
Da first pass compares 8 n' l0-0ne comparison, no moves.
Da second pass compares 9 n' 8, then 9 n' 10. Da array becomes
10 9 8 6 2-two comparisons, two moves.
Da third n' fourth passes compare 6 n' 8, n' 2 n' 6-no moves.
In summary, there be approximately one or two comparisons per pass n' no
more than two moves per pass.
For selection sort, there be four passes too .
. Da first pass findz tha freshest element up in tha array n' swaps it tha fuck into tha first
position.
Da array is still 10 8 9 6 2-four comparisons. There is two moves if your
algorithm make tha swap up in dis case, otherwise no moves.
Da second pass findz tha freshest element from a[l] ta a[4] n' swaps it tha fuck into the
second position: 10 9 8 6 2-three comparisons, two moves.
For tha third pass there be two comparisons, n' one fo' tha fourth. There are
zero or two moves each time.
Summary: 4 + 3 + 2 + 1 total comparisons n' a possible two moves per pass.
Notice dat reason I is valid. Y'all KNOW dat shit, muthafucka! Selection sort make tha same number of comparisons
irrespectizzle of tha state of tha array. Insertion sort do far fewer comparisons
if tha array be almost sorted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Reason Pt II is invalid. Y'all KNOW dat shit, muthafucka! There is roughly
the same number of data movements fo' insertion n' selection. I aint talkin' bout chicken n' gravy biatch. Insertion may
even have mo' chizzles, dependin on how tha fuck far from they insertion points the
unsorted elements are. Reason Pt III is wack cuz insertion n' selection sorts
have tha same space requirements.
23. (E) In tha straight-up original gangsta pass all up in tha outa f or loop, tha smallest element make its
way ta tha end of tha array. In tha second pass, tha next smallest element moves
to tha second last slot, n' so on. I aint talkin' bout chicken n' gravy biatch. This is different from tha sorts up in chizzlez A
all up in D; up in fact, it aint nuthin but a funky-ass bubble sort.
24. (C) Reject reason I. Mergesort requires both a merge n' a mergeSort methodmore
code than tha relatively short n' simple code fo' insertion sort. Reject
reason Pt II. Da merge algorithm uses a temporary array, which means mo' storage
space than insertion sort. Reason Pt III is erect. For long lists, tha "divide-andconquer"
approach of mergesort gives it a gangbangin' fasta run time than insertion sort.
25. (D) Since tha search is fo' a gangbangin' four-letta sequence, tha scam up in dis algorithm is that
if you examine every last muthafuckin fourth slot, you gonna find a letta up in tha required sequence hella
quickly. When you find one of these letters, you can then examine adjacent slots
to check if you have tha required sequence. This method will, on average, result
in fewer comparisons than tha strictly sequential search algorithm up in chizzle A.
Choice B is wrong yo. H you encounta a "q," "r," or "s" without a "p" first, you
can't have found "pqrs." Chizzle C is wack cuz you may miss tha sequence
completely. Chizzle E don't make sense.
26. (C) Da main precondizzle fo' a funky-ass binary search is dat tha list is ordered.
27. (E) This algorithm is just a recursive implementation of a sequential search. It
starts by testin if tha last element up in tha array, a [n-l] , is equal ta value yo. H so, it
returns tha index n - 1. Otherwise, it calls itself wit n replaced by n - 1. The
net effect is dat it examines a [n-l] , a [n-2], .... Da base case, if (n == 0),
Answers Explained
occurs when there be no elements left ta examine. In dis case, tha method
returns -1, signifyin dat value was not up in tha array.
28. (0) Da partizzle algorithm performs a seriez of swaps until tha pivot element
is swapped tha fuck into its final sorted posizzle (see p. 527). No temporary arrays or
external filez is used, nor be a recursive algorithm invoked. Y'all KNOW dat shit, muthafucka! Da merge method is
used fo' mergesort, not quicksort.
29. (0) Recall tha mergesort algorithm:
Divide arr tha fuck into two parts.
Mergesort tha left side.
Mergesort tha right side.
Merge tha two sides tha fuck into a single sorted array.
Da merge method is used fo' tha last step of tha algorithm. Well shiiiit, it do not do any
sortin or partitionin of tha array, which eliminates chizzlez A, B, n' C. Chizzle
E is wack cuz merge starts wit a single array dat has two sorted parts.
30. (B) Round 600 up ta tha next juice of 2, which is 1024 = 210. For tha worst
case, tha array is ghon be split up in half log21024 = 10 times.
31. (B) If tha list is sorted up in reverse order, each pass all up in tha array will involve
the maximum possible number of comparisons n' tha maximum possible number
of element movements if a insertion sort is used.
32. (C) I violates tha order property of a heap. Pt II aint a cold-ass lil complete binary tree.
33. (0) Da elements is ghon be banged tha fuck into tha tree as shown, so tha level of tha tree
is 3. (Remember dat tha top level of tha tree is 0.)
In fact, you don't need tha tree or tha actual elements!
Da first element goes tha fuck into level o.
Da next two elements go tha fuck into level 1 (Total = 3).
Da next four elements go tha fuck into level 2 (Total = 7).
Da next eight elements go tha fuck into level 3 (total = 15) .
... andsoon.
Since tha given array has eight elements, you need a tree dat goes ta three levels.
(Note dat tha tree shown has not yet been formed tha fuck into a heap.)
34. (A) Assumin dat tha array gotz nuff n elements, tha piece of code dat forms
the original gangsta heap is:
for (int root Index = (n / 2) - 1; root Index &gt;= 0; rootIndex--)
fixHeap(rootIndex, n - 1);
561
ABONLY
ABONLY
562 Chapta 12 Sortin n' Searching
fixHeap(2,6) fixHeap(1,6)
fixHeap(O,6) Tree is now a heap
Da sequence of swaps is
7and5
9 n' 1
9and6
8 n' 6
This leadz ta chizzle A.
35. (E) Da efficiency of tha algorithm will depend on how tha fuck tha pivot element is
selected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Ideally up in quicksort tha pivot element should partizzle tha array into
two partz of roughly equal size. If tha array is sorted n' tha pivot element is
always tha straight-up original gangsta (or last) element up in tha array, then one section of tha array will
always be empty afta partitioning. This be a most shitty case fo' quicksort, 0(n2).
On tha other hand, if tha array is sorted n' tha pivot element is chosen near the
middle of tha array, quicksort is ghon be straight-up efficient: O(n logn).
36. (C) An efficient hash codin system must have as few collisions as possible (i.e.,
the hash addresses should be-uniformly distributed all up in tha table). When
there is collisions, tha method of allocatin a freshly smoked up hash address should, again,
distribute these addresses uniformly all up in tha table. Da size of tha data
items is irrelevant since a hash function operates just on a key field of tha data
items.
37. (C) Just before 29 is inserted, tha table is ghon be lookin like this:
array index o
key value 45
2
2
3
25
4 5 6
28
7
7
Now 29 % 11 = 7. Right back up in yo muthafuckin ass. Slots 7 n' 8 is taken, so 29 goes tha fuck into slot 9.
38. (E) Hash coded data must alway~ be searched wit a hash function applied ta the
key field, followed by a algorithm dat resolves any collisions.
39. (0) In tha rehash function, result is tha current hash address. Chizzle A works
for all numbers except 34. 34 % 20 hashes ta 14, ~hich is taken by 54. Then
(14+ 13) % 20 rehashes ta 7, which is where 34 would go if dis was tha erect
answer n' shit. Chizzle B don't successfully resolve collisions: 34 % 20 hashes ta 14,
which be already taken by 54. 14 % 20 rehashes ta 14, tha same slot. Recall that
a rehash function of tha form (result + <const» %="" <number="" of="" slots=""> must be
such dat <const> n' <number of="" slots=""> is relatively prime (i.e., no common
factors other than 1). Otherwise, tha method won't generate all tha hash table
Answers Explained
slots, n' you can put dat on yo' toast. This eliminates chizzle C. Chizzle E produces 30 slots yo, but tha table shown
has just 20 slots, n' you can put dat on yo' toast. Element 81, fo' example, has no slot under dis scheme, since
81 % 30 is 21 n' list [21] do not exist. Chizzle D successfully places all the
numbers up in tha table.
40. (C) Reason I is valid-itz always desirable ta hide implementation details from
userz of a method. Y'all KNOW dat shit, muthafucka! Reason Pt II is valid too-since QuickSort n' MergeSort implement
the Sort intercourse, they must gotz a sort method wit no parameters. But
parametas is needed ta make tha recursion work. Therefore each sort requires
a helper method wit parameters. Reason Pt III is invalid up in dis particular example
of helper methods. There is nuff examplez up in which a helper method enhances
efficiency (e.g., Example 2 on p. 344) yo, but tha sort example aint one of dem wild-ass muthafuckas.
41. (E) Since Sort be a intercourse, you can't create a instizzle of dat shit. This eliminates
choices B n' D. Da sort methodz alta tha contentz of strArray. Thus invoking
q. sort 0 followed by m. sort 0 means dat m. sort will always operate on a
sorted array, assumin quicksort works erectly dawwwwg! In order ta test both quicksort
and mergesort on unsorted arrays, you need ta cook up a cold-ass lil copy of tha original
array or create a gangbangin' finger-lickin' different array. Eliminizzle chizzle A (and B again!), which do
neither of these n' you can put dat on yo' toast. Chizzle C is wack cuz it calls tha private sort methods
of tha classes. Da Sort intercourse has just a single hood method, sort, wit no
arguments, n' you can put dat on yo' toast. Da two classes shown must provide a implementation fo' dis sort
method, n' it is dis method dat must be invoked up in tha client program.
42. (0) A sequential search, up in da most thugged-out shitty case, must examine all n elements-O(n).
In da most thugged-out shitty case, a funky-ass binary search will keep splittin tha array up in half until there
is just one element left up in tha current subarray: log2 n splits, which is O(log n ).
43. (B) 1 mazillion = 106 = (103)2 ~ (2 1°)2 = 220. Thus, there is ghon be on tha order of
20 comparisons.
44. (C) This be a sequential search dat examines each element n' counts tha number
of occurrencez of 8. Right back up in yo muthafuckin ass. Since n comparisons is made, tha algorithm is O( n ).
45. (B) Mergesort works by breakin its array of n elements tha fuck into n arrayz of one
element each, a O(log2 n) process. Then it merges adjacent pairz of arrays until
there is one sorted array, a O(n) process. For each split of tha array, the
merge method is called. Y'all KNOW dat shit, muthafucka! Thus, mergesort is O( n log n ) irrespectizzle of tha original
orderin of tha elements.
Quicksort partitions tha array tha fuck into two parts, n' you can put dat on yo' toast. Da algorithm is O( n log n)
only if tha two partz of tha array is roughly equal up in length. In da most thugged-out shitty case,
this aint true-the pivot is tha smallest or phattest element up in tha array. The
partizzle method, a O(n) process, will then be called n times, n' tha algorithm
becomes O(n2).
Da elementz of heapsort is always placed up in a funky-ass balanced binary tree, which
gives a O(log2 n) process fo' fixin tha heap. n /2 passes, each of which restores
the heap, leadz ta a O( n log n) algorithm irrespectizzle of tha original gangsta orderin of
the elements.
46. (A) A sequential search is O(n), a funky-ass binary search O(logn), n' quicksort O(n logn).
For any big-ass positizzle n, logn &lt; n &lt; n logn.
563
AB (contimled)
Da Grid W Dr ld Case CHAPTER 13
Study
564
Man is tha only critta whoz ass feels tha need
to label thangs as flowers n' weeds.
-Anonymous
Chapta Goals
 Da classes up in GridWorld:
hierarchy n' overview
 Da Playa class
 Da Location class
 Da Rock n' Flower classes
 Da Bug n' BoxBug classes
 Da Critta class and
ChameleonCri tta classes
OVERVIEW
 Da Grid intercourse
 Da AbstractGrid class
 Da BoundedGrid and
UnboundedGrid classes
 Run-time analysiz of grid
methods
Da case study be a program dat simulates actions n' interactionz of objects up in a
two-dimensionizzle grid. Y'all KNOW dat shit, muthafucka! Da "actors" up in tha grid is displayed by a GUI (graphical user
interface). Da GUI can also add freshly smoked up hustlas ta tha grid n' can invoke methodz on all
actors.
Durin a single step of tha program, every last muthafuckin occupant of tha grid gets a cold-ass lil chizzle ta act.
Each hustla acts accordin ta a cold-ass lil clearly specified set of behaviors dat can include moving,
changin color, changin direction, removin other hustlas from tha grid, depositing
new hustlas up in specified locations, n' so on.
THE CLASSES
Da followin diagram displays tha relationshizzle between tha testable classes up in tha case
study.
Da Playas
Grid
«interface»
AbstractGrid
Da diagram shows dat each of these objects, Flower, Rock, Bug, n' Critta is-an
Actor fo' realz. A BoxBug is-a Bug, n' a ChameleonCritta is-a Critter n' shiznit fo' realz. Also, AbstractGrid
is a abstract class dat implements tha Grid intercourse. Each of BoundedGrid and
UnboundedGrid is-an AbstractGrid. Y'all KNOW dat shit, muthafucka! Every Playa has-a Location n' Grid, n' a Grid
has-a Location.
NOTE
Da Location, Playa, Rock, n' Flower classes is "black box" classes whose code is
not provided. Y'all KNOW dat shit, muthafucka! Yo ass are, however, sposed ta fuckin know tha justificationz of they methods
and constants, n' you can put dat on yo' toast. Code is provided fo' all of tha other classes shown n' is testable on
the AP exam. While Level A hustlas is sposed ta fuckin be familiar wit tha method
specifications fo' tha grid classes, Level A hustlas aint gonna be tested on any of the
code fo' grid classes.
THE ACTORS
Here be a summary of what tha fuck each hustla do when it acts.
 A Rock do nothing.
 A Flower darkens its color.
 A Bug moves forward when it can. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it can move tha fuck into a empty spot or onto a
flower n' shit. When it moves, it deposits a gangbangin' flower up in its previous location. I aint talkin' bout chicken n' gravy biatch. If it moves
to a location occupied by a gangbangin' flower, dat flower is removed from tha grid. Y'all KNOW dat shit, muthafucka! A bug
cannot move if it is blocked up in front by either another (nonflower) hustla or the
edge of tha grid. Y'all KNOW dat shit, muthafucka! When a funky-ass bug is prevented from moving, it turns 45° ta tha right.
 A BoxBug moves like a Bug fo' realz. Additionally, if it encountas no obstaclez up in its path,
it traces up a square of flowers wit a given side length. If a BoxBug is blocked
from moving, it make two right turns n' starts again.
 A Critta gets a list of its adjacent neighborin actbrs n' processes dem by
"eating" each hustla dat aint a rock or another critter n' shit. Well shiiiit, it then randomly selects
one of tha empty neighborin locations n' moves there, so peek-a-boo, clear tha way, I be comin' thru fo'sho. If there be no available
empty locations, a cold-ass lil critta do not move.
 A ChameleonCri tta gets a list of its adjacent neighbors, randomly picks one of
them, n' chizzlez its color ta dat of tha selected hustla. Da Chamele~nCri tter
moves like a Critta but, additionally, it first chizzlez its direction ta grill its
new location before moving.
565
566 Chapta 13 Da GridGhetto Case Study
THE Location CLASS
Description
Da Location class
 Encapsulates row n' column joints fo' any posizzle up in tha grid.
 Provides constants fo' compass directions n' turn angles.
 Provides methodz fo' determinin relationshizzlez between locations n' compass
directions.
Da flower up in tha diagram is up in row 1, column 2, or Location (1, 2).
-
~
There is eight constants dat represent compass directions:
Constant int Value
Location. I aint talkin' bout chicken n' gravy biatch. NORTH 0
Location. I aint talkin' bout chicken n' gravy biatch. EAST 90
Location. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. SOUTH 180
Location.WEST 270
Location. I aint talkin' bout chicken n' gravy biatch. NORTHEAST 45
Location. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. SOUTHEAST 135
Location. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. SOUTHWEST 225
Location. I aint talkin' bout chicken n' gravy biatch. NORTHWEST 315
Da compass directions have integer joints startin at 0 (north) n' movin clockwise
all up in 360 (degrees). Da dotted arrow up in tha figure below represents a gangbangin' finger-lickin' direction
of 135 or Location. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. SOUTHEAST.
There is seven constants representin da most thugged-out commonly used turn angles:
THE Location CLASS 567
Constant int Value
Location. I aint talkin' bout chicken n' gravy biatch. LEFT -90
Location. I aint talkin' bout chicken n' gravy biatch. RIGHT 90
Location. I aint talkin' bout chicken n' gravy biatch yo. HALF_LEFT -45
Location.HALF_RIGHT 45
Location. I aint talkin' bout chicken n' gravy biatch. FULL_CIRCLE 360
Location. I aint talkin' bout chicken n' gravy biatch yo. HALF_CIRCLE 180
Location. I aint talkin' bout chicken n' gravy biatch fo' realz. AHEAD 0
To git a hustla ta turn all up in a given number of degrees, set its direction ta the
sum of its current direction n' tha turn angle. For example, ta cook up a hustla turn
right (all up in 90°, clockwise)
setDirection(getDirection() + Location.RIGHT);
'--v---' ' v' vf'"---'
change direction ta current direction +90.
In general, a cold-ass lil class can be represented by a funky-ass box diagram (shown below) up in which
private data n' methodz is straight-up enclosed within tha shaded region, while
hood methodz overlap tha shaded region. I aint talkin' bout chicken n' gravy biatch. 1
Da diagram below represents tha Location class, n' shows dat there is one constructor,
eight hood methods, n' two private instizzle variables.
Location
get Row
getCol
equals
hashCode
row
col
1 Da class diagrams is based on diagrams up in A Computa Science Tapestry by Owen Astrachan and
the Marine Biologizzle Case Study narratizzle by Alyce Brady.
568
Every creature up in the
grid is coded as a
subclass of Playa.
Chapta 13 Da GridGhetto Case Study
Methods
I hood Location(int r, int c) I
Constructs a location wit given row n' column.
hood int getRow()
hood int getCol()
Accessor methodz dat return tha row or column of tha Location.
hood Location getAdjacentLocation(int direction)
Returns tha adjacent location up in tha compass direction closest ta direction.
hood int getDirectionToward(Location target)
Returns tha direction, rounded ta tha nearest compass direction, from dis location
toward a target location.
I hood int hashCode 0 I
Generates n' returns a hash code fo' dis Location.
hood boolean equals(Object other)
hood int compareTo(Object other)
These methodz is used ta compare Location objects, n' you can put dat on yo' toast. Two locations is equal if they
have tha same row n' column joints fo' realz. Ascendin order fo' locations is row'major,
namely, start at (0,0) n' proceed row by row from left ta right. For example, (0, 1) is
less than (0, 2) n' (1, 8) is less than (3,0).
I hood Strin toStringO I
Returns a strang representation of dis Location up in tha form (row, col).
THE Playa CLASS
.~ ..::'. ;t. b. ~:.; . '- . . .... . . . : ' -. -. ,'
Description
Da Playa class is tha superclass fo' every last muthafuckin creature or object dat appears up in tha grid.
An Playa has a location, direction, n' color, along wit tha capacitizzle ta chizzle
each of these instizzle variables. Well shiiiit, it has access ta its grid. Y'all KNOW dat shit, muthafucka! Well shiiiit, it can put itself up in tha grid, and
also remove itself from dat shit.
Here is tha box diagram fo' tha Playa class, showin only its hood methods. (Since
Actor be a funky-ass black-box class, yo ass is not privy ta its private data n' methods, nor the
implementation of its methods.)
THE Playa CLASS
Actor
get Color
set Color
setDirection
get Grid
getLocation
moveTo
act
toString
Methods
I hood PlayaO I
Default constructor. Shiiit, dis aint no joke. Constructs a funky-ass blue hustla facin north.
hood Color getColor()
hood int getDirection()
hood Location getLocation()
Accessor methods. Return tha color, direction, or location of dis Playa. Note that
the direction returned be a int from 0 all up in 359 (degrees).
I hood Grid<actor> getGrid() I
Accessor method. Y'all KNOW dat shit, muthafucka! Returns tha grid of dis Playa, or null if tha hustla aint up in tha grid.
hood void setColor(Color newColor)
hood void setDirection(int newDirection)
Mutator methods. Chizzle tha color or direction of dis Playa ta tha freshly smoked up value speci-
569
570 Chapta 13 Da GridGhetto Case Study
fied by tha parameter.
hood void moveTo(Location newLocation)
Moves dis Playa ta a freshly smoked up location. I aint talkin' bout chicken n' gravy biatch. If tha freshly smoked up location be already occupied, tha hustla
in dat location is removed from tha grid. Y'all KNOW dat shit, muthafucka! Da moveTo method has two preconditions:
1. This Playa is up in a grid.
2. newLocation is valid up in dis Playaz grid.
hood void putSelflnGrid(Grid<actor> gr. Shiiit, dis aint no joke. Location loc)
Puts dis Playa tha fuck into tha given grid gr all up in tha specified location loco A precondizzle is
that loc is valid.
I hood void removeSelfFromGrid() I
Removes dis Playa from tha grid.
I hood void act() I
Reverses tha direction of dis hustla. (fhe method is often overridden up in sublcasses of
Actor.)
I hood Strin toString() I
Returns a strang wit tha location, direction, n' color of dis Playa.
~:.t.'':.iIi'' &lt;~.t~', ; .. -~':.' &gt;  ,': "
THE Rock AND Flower CLASSES
. ~ ' ... '. --: . .... ..-.... _ '. .. ~:.~ __ : }.. .. :-: .. .,.. ..:.:.~._ .. ,';t."""'$)"." . ______
Da Rock Class
A Rock acts by bustin nothing. Well shiiiit, it has a thugged-out default constructor dat creates a funky-ass black rock,
and a second constructor dat allows construction of a rock wit a specified color. Shiiit, dis aint no joke. The
act method is overridden-it has a empty body!
Da Flower Class
A Flower acts by darkenin its color. Shiiit, dis aint no joke. Well shiiiit, it has a thugged-out default constructor dat creates a pink
flower, n' a second constructor dat allows construction of a gangbangin' flower wit a specified
color. Shiiit, dis aint no joke. Da overridden act method darkens tha flower by reducin tha jointz of the
red, green, n' blue componentz of its color by a cold-ass lil constant factor.
THE Bug CLASS
I . ~ '. .,' ~ ........ :.'.:t~.::":,,£«,j_;-"~~""_"ILL ____ _
Description
A Bug be a Playa dat moves forward up in a straight line, turnin only when it is blocked.
A bug can be blocked by either tha edge of tha grid, or a hustla dat aint a gangbangin' flower.
THE Bug CLASS
As tha bug moves, it steps on any flower up in its path, causin tha removal of dat flower
from tha grid. Y'all KNOW dat shit, muthafucka! Afta each step, tha bug places a gangbangin' flower up in its previous location.
Here be a funky-ass box diagram fo' tha Bug class. Methodz inherited from Playa is not
shown. I aint talkin' bout chicken n' gravy biatch. Overridden methodz is indicated wit a thugged-out double frame.
Bug
Da diagram shows dat a Bug has two constructors. Da act method is overridden,
and there be three additionizzle hood methods: turn, move, n' canMove.
Don't forget dat Bug also inherits tha followin methodz from Playa: getColor,
setColor, getDirection, setDirection, getGrid, getLocation, putSelflnGrid,
removeSelfFromGrid, moveTo, n' toString.
Methods
I hood BugO I
Default constructor. Shiiit, dis aint no joke. Creates a red Bug.
I hood Bug(Color bugColor) I
Constructor. Shiiit, dis aint no joke. Creates a Bug wit tha specified color.
Note dat both of tha constructors use tha inherited setColor method.
I hood void act() I
Da Bug moves if it can; otherwise it turns.
Note dat dis is tha only method of tha Playa class dat is overridden.
I hood void turn() I
Turns dis Bug 45° ta tha right without changin its location. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it do it by adding
Location. I aint talkin' bout chicken n' gravy biatch yo. HALF _RIGHT ta tha bugz current direction.
571
572 Chapta 13 Da GridGhetto Case Study
I hood boolean canMoveO I
Returns legit if dis Bug can move, false otherwise. Da bug be able ta move if the
location directly up in front of it (a) is valid n' (b) is empty or gotz nuff a gangbangin' flower n' shiznit yo. Here
are tha steps up in tha method:
 Git tha bugz grid, n' if it is null, return false. (Note dat a funky-ass bugz grid is null
if another hustla removed tha bug.)
 Git tha adjacent location directly up in front of tha bug.
 If dis location is invalid (namely, outta tha grid), return false.
 Git tha hustla up in dis neighborin location.
 If tha hustla be a gangbangin' flower or null (i.e., no hustla there!), return true. Otherwise
return false.
I hood void moveO I
Moves dis Bug forward, placin a gangbangin' flower up in its previous location. I aint talkin' bout chicken n' gravy biatch yo. Here is tha steps:
 Git tha bugz grid, n' if it is null, exit tha method.
 Git tha bugz current location.
 Git tha adjacent location directly up in front of tha bug.
 If dis location is valid, tha bug moves there; otherwise it removes itself from the
grid. Y'all KNOW dat shit, muthafucka! (Note: If dis location is invalid, tha canMove method will return false,
and move aint gonna be called. Y'all KNOW dat shit, muthafucka! So tha test up in dis step is redundant, n' is probably
included as a extra precaution.)
 Smoke a gangbangin' flower dat is tha same ol' dirty color as tha bug.
 Place tha flower up in tha bugz previous location (which was saved up in tha second
step.)
THE BoxBug CLASS
Description
A BoxBug be a Bug dat moves up in a square pattern if it is unimpeded. Y'all KNOW dat shit, muthafucka! To create the
square, a BoxBug has two private instizzle variables: sideLength, which is tha number
of steps up in .1 side of its square, n' steps, which keeps track of where tha BoxBug is
in bustin a side. Whenever a side has been completed or tha bug must start again
because it encountered a obstacle, steps gets reset ta zero.
Here is tha box diagram fo' tha BoxBug class.
THE Critta CLASS
BoxBug
steps
sideLength
I BoxBug I

II act Pt II
Da diagram shows dat BoxBug has two private instizzle variables, one constructor,
and a overridden act method. Y'all KNOW dat shit, muthafucka! In addizzle ta inheritin all of tha hood methodz of
Actor, BoxBug inherits tha methodz turn, move, n' canMove from Bug.
Methods
I hood BoxBug(int length) I
Constructor. Shiiit, dis aint no joke. Right back up in yo muthafuckin ass. Sets sideLength ta tha specified length, n' initializes steps ta O.
I hood void act() I
This overridden method performs one step up in tha creation of tha BoxBugz square.
First, tha method tests whether tha bug is still up in tha process of bustin a side:
if (steps &lt; sideLength ...
If dis is true, n' tha bug can move, tha bug moves n' steps is incremented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If the
above piece of tha test is false, it means dat tha bug has completed tha current side, and
must turn so dat it can start a freshly smoked up side. Well shiiiit, it do dis by callin turn twice, ta create
the 90° angle all up in tha vertex of tha square. (Recall dat a single call ta turn turns the
bug all up in 45°.) Afta tha bug has completed tha 90° turn, steps is reset ta zero in
preparation fo' a freshly smoked up side. Notice dat if steps &lt; sideLength is true yo, but canMove 0
is false (BoxBug is blocked), tha same preparation fo' a freshly smoked up side must occur (turn, turn,
reset steps). If tha BoxBug is unimpeded when bustin its square, n' tha sideLength
has value k, there is ghon be k + 1 flowers on each side of tha square.
THE Critta CLASS
Description
A Critta be a Playa wit tha followin pattern of behavior.
 Git a list of neighborin hustlas.
 Process tha hustlas.
 Git a list of possible locations ta move to.
 Select a location from tha list.
 Move there.
573
574 Chapta 13 Da GridGhetto Case Study
Here is tha box diagram fo' tha Cri tta class.
act
getActors
processActors
makeMove
Da diagram shows dat tha Critta class aint gots a explicit constructor.
This means dat tha default constructor of tha Playa superclass is ghon be invoked to
create a funky-ass blue Critta facin north fo' realz. All other methodz of Playa is inherited, n' act
is overridden. I aint talkin' bout chicken n' gravy biatch. Da other five methodz is freshly smoked up methodz fo' Critter.
Methods
I hood void act() I
A Critta acts by gettin a list of its neighbors, processin them, gettin a list of
possible locations ta move to, selectin one of these, n' then movin ta tha selected
location.
hood ArrayList<actor> getActors()
Returns a list of adjacent neighborin hustlas.
hood void processActors(ArrayList<actor> hustlas)
Processes tha hustlas. Da Critta "eats" all hustlas dat is not rocks or other critters.
Da hustlas is processed by iteratin all up in tha list of hustlas. Each hustla is examined.
If it is neither a rock nor a cold-ass lil critter, tha hustla removes itself from tha grid.
hood ArrayList<location> getMoveLocations()
Returns a list of valid, adjacent, empty, neighborin locations, which is tha possible
locations fo' tha next move. Da grid method getEmptyAdjacentLocations is used,
with tha critterz current location as its parameter.
THE Chameleon Critta CLASS
hood Location selectMoveLocation(ArrayList<location> locs)
Selects tha location fo' tha next move from locs, a list of valid locations yo. Here is the
steps.
 Assign n ta be tha length of tha list.
 If n is zero, which means dat there be no available locations, return tha current
location of tha critter.
 Git a random int from 0 ta n - 1 wit tha statement
int r = (int) (Math .random() * n);
 Return tha location at index r up in tha locs ArrayList.
I hood void makeMove(Location loc) I
Moves dis Critta ta tha specified location. I aint talkin' bout chicken n' gravy biatch fo' realz. A precondizzle is dat loc is valid. Y'all KNOW dat shit, muthafucka! The
method is implemented wit tha statement
moveTo(loc) ;
Recall dat moveTo is inherited from Playa.
THE Chame1 eonCri tta CLASS
Description
A ChameleonCritta be a Critter n' shit. When it acts, a ChameleonCritta gets tha same
list of hustlas as a Critter yo, but instead of smokin them, it randomly selects one hustla
and chizzlez its color ta dat of tha selected hustla fo' realz. A ChameleonCritta moves like a
Critter, wit one difference: Before it moves, it turns ta grill its freshly smoked up location.
Here is tha box diagram fo' tha ChameleonCri tta class.
ChameleonCritter
II processActors Pt II
I
II makeMove Pt II
Notice dat there is no constructor, which means dat when a ChameleonCri tter
is pimped, tha default constructor of Playa is ghon be invoked, constructin a funky-ass blue
ChameleonCri tta facin north.
575
576
ABONLY
ABONLY
Chapta 13 Da GridGhetto Case Study
Methods
hood void processActors(ArrayList<actor> hustlas)
Randomly selects a adjacent neighbor, n' chizzlez dis ChameleonCritterz color to
that of tha selected hustla. Do not a god damn thang if there be no neighbors.
I hood void makeMove (Location loc) I
Moves like a regular Critter yo, but before it moves, it turns ta grill its freshly smoked up location. I aint talkin' bout chicken n' gravy biatch. To
change direction, tha setDirection method is used. Y'all KNOW dat shit, muthafucka! Da parameta used fo' tha call to
setDirection is tha direction from tha ChameleonCritterz current location ta loc:
getLocation().getDirectionToward(loc)
',', ,-.&gt;.:"',_.
THE Grid<e> INTERFACE
Da intercourse Grid<e> specifies methodz dat manipulate a grid of objectz of type E. In
the case study, Grid<e> is implemented by three classes, AbstractGrid<e>, BoundedGrid&lt;
E&gt;, n' UnboundedGrid<e>. When tha grid classes is used by clients, type E is
replaced by Playa.
Methods
Listed below is tha methodz up in tha intercourse. These methodz is commented and
discussed up in tha classes dat implement dem wild-ass muthafuckas.
hood intercourse Grid<e>
{
}
int getNumRows()j
int getNumCols()j
boolean isValid(Location loc)j
E put(Location loc, E obj)j
E remove(Location loc)j
E git (Location loc)j
ArrayList<location> getOccupiedLocations()j
ArrayList<location> getValidAdjacentLocations(Location loc);
ArrayList<location> getEmptyAdjacentLocations(Location loc);
ArrayList<location> getOccupiedAdjacentLocations(Location loc)j
ArrayList<e> getNeighbors(Location loc)j
THE AbstractGrid<e> CLASS
Description
Da AbstractGrid<e> class implements five methodz of tha Grid<e> intercourse dat are
common ta both tha BoundedGrid<e> n' UnboundedGrid<e> classes. While no instance
of a AbstractGrid<e> can be pimped, havin dis class avoidz repeated code.
Here is tha box diagram fo' tha AbstractGrid class.
THE AbstractGrid<e> CLASS
AbstractGrid<e>
«abstract»
I getNeighbors

I getValidAdjacentLocations

I getEmptyAdjacentLocations

J
I
I
I getOccupiedAdj acentLocations I

I toStrin I
Methods
Note dat up in every last muthafuckin method below dat has a loc parameter, there be a precondizzle that
loc is valid up in tha grid.
hood ArrayList<e> getNeighbors(Location 10c)
Returns a list of all hustlas up in locations adjacent ta loco It do dis by traversin the
locations up in getOccupiedAdjacentLocations(loc), n' addin tha hustlas up in dem locations
to a initially empty ArrayList<e>. Note dat if neighbors is tha ArrayList
of hustlas ta be returned, n' neighborLoc be a Location up in tha traversal, tha statement
neighbors.add(get(neighborLoc));
extracts tha hustla up in neighborLoc n' addz it ta tha neighbors list. Recall dat add is
an ArrayList method; but tha git method used here is tha Grid method dat returns
the object at its Location parameter.
hood ArrayList<location>
getVa1idAdjacentLocations(Location 10c)
Returns all valid locations adjacent ta loco Startin wit uptown (at 0°), n' goin up in
incrementz of 45, it gets tha adjacent location up in dat direction, and, if dat location is
in tha grid, addz it ta a initially empty ArrayList of locations. If you do tha math,
you will peep dat tha line
for (int i = 0; i &lt; Location .FULL_CIRCLE / Location. I aint talkin' bout chicken n' gravy biatch yo. HALF_RIGHT; i++)
is equivalent to
for (int i = 0; i &lt; 8; i++)
Da constants FULL_CIRCLE n' HALF _RIGHT is used cuz they is much mo' descriptive
than "8".
577
AD (continued)
578
AB (continued)
ABONLY
Both
BoundedGrid and
UnboundedGrid
extend
AbstractGrid
and implement
Grid.
Chapta 13 Da GridGhetto Case Study
hood ArrayList<location>
getEmptyAdjacentLocations(Location loc)
Returns all valid empty locations adjacent ta loco Da method traverses tha list of loc's
valid adjacent locations. If it findz a empty location (i.e., tha object up in it is nUll), it
addz it ta a initially empty ArrayList of locations.
hood ArrayList<location>
getOccupiedAdjacentLocations(Location loc)
Returns all valid occupied locations adjacent ta loco Implementation of dis method
is identical ta dat of getEmptyAdjacentLocations above, except dat it addz locations
that contain objects.
I hood Strin toStringO I
Returns a thugged-out description of dis grid up in strang form. Well shiiiit, it do dis by traversin tha occupied
locations up in tha grid, n' concatenatin each location n' occupyin object ta an
initially empty string. Da piecez of shiznit fo' each location is separated by
commas, which is tha reason fo' dis segment:
if (s.length() &gt; 1)
S += ", Pt II;
What it means is: If there be at least one grid location busted lyrics about, add a cold-ass lil comma ta the
strin before startin tha shiznit fo' tha next location. I aint talkin' bout chicken n' gravy biatch. Da test prevents the
strin from startin wit a cold-ass lil comma.
THE BoundedGrid<e> AND UnboundedGrid<e> CLASSES
Description
Da grid classes provide a environment fo' tha hustlas up in GridWorld. Y'all KNOW dat shit, muthafucka! A bounded grid
is two-dimensional, wit a gangbangin' finite number of rows n' columns. Creatures up in a funky-ass bounded
grid cannot escape its confines fo' realz. An unbounded grid be also rectangular yo, but tha number
of rows n' columns is unlimited.
Both BoundedGrid<e> n' UnboundedGrid<e> extend AbstractGrid<e> which implements
Grid<e>. This means dat both of tha grid classes inherit tha five mCfthodz of
AbstractGrid<e>, n' must implement tha remainin methodz of Grid<e>.
Both tha BoundedGrid<e> n' UnboundedGrid<e> classes is represented up in tha following
box diagram.
THE BoundedGrid<e> AND UnboundedGrid<e> CLASSES
BoundedGri d<e>
Constructor
getNumRows
occupantArray
isValid
UnboundedGrid<e> --~~--------~
getOccupiedLocations
get
put
remove
occupantMap
Da diagram shows dat each class has its own constructor, n' each class implements
the seven remainin Grid<e> methodz dat is not up in AbstractGrid<e>. The
inherited methodz of AbstractGrid<e> is not shown: getValidAdjacentLocations,
getEmptyAdjacentLocations, getOccupiedAdjacentLocations, getNeighbors, and
toString.
Da BoundedGrid<e> is implemented wit a two-dimensionizzle array of Object called
occupantArray,
private Object[] [] occupantArray;
Da element type is Object, not E, cuz Java don't allow arrayz of generic types.
Still, all elementz of occupantArray must be of type E, since tha method dat adds
elements ta dis array, put, requires a parameta of type E fo' tha object dat be added.
Da UnboundedGrid<e> is implemented wit a map called occupantMap, up in which a
key of tha map be a Location object n' tha correspondin value be a object of type E
in dat location:
private Map<location, e=""> occupantMap;
Only dem locations dat contain a hustla is keyz of tha map.
Methods
THE CONSTRUCTORS
For each class, tha constructor creates a empty grid.
579
AB (continued)
580
BoundedGrid
hood BoundedGrid(
int rows, int cols)
Constructs a empty bounded grid with
specified number of rows n' columns.
'fhrows a IllegalArgumentException
if either parameta is negative.
hood int getNumRows()
hood int getNumCols()
BoundedGrid
Returns number of rows or columns in
grid. Y'all KNOW dat shit, muthafucka! Note dat tha number of rows is
occupantArray . length n' tha number
of columns is tha length of tha Oth row,
occupantArray[O] . length.
Chapta 13 Da GridGhetto Case Study
UnboundedGrid
I hood UnboundedGrid() I
Creates a empty unbounded grid. Y'all KNOW dat shit, muthafucka! Uses
a HashMap.
UnboundedGrid
Always returns -1, since a UnboundedGrid
does not gotz a specific number of
rows or columns.
I hood boolean isValid(Location loc) I
BoundedGrid
Returns legit if loc is up in bounds, false
otherwise.
UnboundedGrid
Always returns true.
hood ArrayList<location> getOccupiedLocations()
Returns all occupied locations up in dis grid.
BoundedGrid
 A nested f or loop traverses the
rows n' columnz of tha grid.
 Creates freshly smoked up Location from current
row n' column.
 Retrieves object at dis location
(usin git (loc).
 If object aint null (i.e., loc occupied),
addz dis location ta ArrayList.
I hood E get(Location loc) I
UnboundedGrid
 'fraverses key set of occupantMap,
usin a gangbangin' for-each loop.
 Addz each location up in traversal to
ArrayList. (All tha keys is occupied
locations.)
Returns tha object at loc, or null if loc is unoccupied.
THE BoundedGrid<e> AND UnboundedGrid<e> CLASSES 581
BoundedGrid UnboundedGrid AB (continlled)
 1\n IllegalArgumentExceptionis
thrown if loc is invalid.
 1\ccesses object at loc by rockin the
expreSSlOn
occupantArray[loc.getRow()]
[loc . getCol ()]
 Before returnin dis object, cast
toE.
I hood E put(Lacatian lac, E abj) I
 1\ NullPointerException IS
thrown if loc is null.
 Accesses object at loc by rockin the
expression
occupantMap.get(loc)
where git be a Map method.
Puts obj at location loc up in dis grid, n' returns tha previous occupant of dat location.
Returns null if loc was previously unoccupied.
BoundedGrid
 An IllegalArgumentException is
thrown if loc is invalid.
 1\ NullPointerException IS
thrown if obj is null.
 Saves previous occupant at loco
 1\ddz obj ta loc using
occupantArray[loc.getRow()]
[loc.getCol()] = obj;
 Returns previous occupant.
I hood E remave(Lacatian lac) I
UnboundedGrid
 A NullPointerException is
thrown if either obj or loc is null.
 Usin tha Map method put, returns
result of
occupantMap.put(loc, obj)
(fhis creates a freshly smoked up mappin for
loc yo, but returns tha previous value
that corresponded ta IOc.)
Removes tha object at loc n' returns dat shit. Returns null if loc is unoccupied.
BoundedGrid
 An IllegalArgumentException is
thrown if loc is invalid.
 Retrieves object from loc:
E r = git Cloc) ;
(Note: git be a BoundedGrid
method.)
 Sets object up in loc ta null:
occupantArray[loc.getRow()]
[loc.getCol()] = null;
 Returns r.
UnboundedGrid
 A NullPointerException IS
thrown if loc is null.
 Usin Map method remove, removes
mappin wit loc as key,
and returns previous object corresponding
to loc:
return occupantMap.remove(loc);
582
ABONLY
Chapta 13 Da GridGhetto Case Study
' .. ~~ '.- :.
RUN-TIME ANALYSIS OF GRID METHODS
Bounded Grid
Suppose a funky-ass bounded grid has r rows, c columns, n' n occupied locations, where r, c,
and n is pimpin' fo' realz. Any algorithm dat requires a traversal of every last muthafuckin location will need r xc
"moves" n' is therefore O( rc). If you gotz a list of only dem occupied locations, (or
the hustlas up in them), processin tha hustlas is ghon be O( n) fo' realz. Accessin any given location in
the grid is O( 1) fo' realz. An algorithm dat processes adfacent neighbors fo' any location will
require no mo' than eight operations, which be a cold-ass lil constant. Therefore tha algorithm
is 0(1).
Unbounded Grid
Rows n' columns do not enta tha fuck into tha analysis fo' a unbounded grid. Y'all KNOW dat shit, muthafucka! Da map
gotz nuff only tha n locations dat is occupied; so big-O run times will all be up in terms
of n, tha number of hustlas up in tha grid.
Since keys is stored up in a HashMap, each of tha followin operations is O( 1): finding
a given location (or key), insertin a freshly smoked up hustla (or mapping), removin a hustla, retrieving
a given hustla, n' so on. I aint talkin' bout chicken n' gravy biatch. These all use tha Map methodz get, put, n' remove,
which is 0(1).
Suppose tha implementation of UnboundedGrid is chizzled so dat keys is stored in
a TreeMap. Da above Map operations now become O(log n ).
In tha followin examples, you may assume a grid wit n occupied locations, n' a
bounded grid wit r rows n' c columns.
Example 1
What tha fuck iz tha big-O run time fo' getOccupiedLocations in
(1) BoundedGrid (2) UnboundedGrid?
(1) O(rc) fo' realz. A nested loop traversal must be done, examinin every last muthafuckin location. I aint talkin' bout chicken n' gravy biatch. The
algorithm dependz only on tha number of locations up in tha grid.
(2) O( n) fo' realz. All dat is required be a simple traversal all up in tha n locations up in tha key
set of tha map.
Example 2
What tha fuck iz tha big-O run time fo' getNeighbors in
(1) BoundedGrid (2) UnboundedGrid?
(1) 0(1).
(2) 0(1).
To retrieve tha neighbors,
 Git a list of occupied adjacent locations .
 Traverse tha list ta extract tha hustlas.
In each type of grid, there be no mo' than eight adjacent locations ta be examined, a
constant number n' shit. Therefore, up in each case, tha algorithm is 0(1).
Da Case Study n' tha AP Exam
NOTE
An O( 1) operation performed eight times is still O( 1). Da assumption is dat eight is
small compared ta n.
BIG-O SUMMARY OF GRID METHODS
Da run times up in tha table below assume a grid wit n occupied locations, n' a
bounded grid wit r rows n' c columns.
Method
getNeighbors
getValidAdjacentLocations
getEmptyAdjacentLocations
getOccupiedAdjacentLocations
toString
getOccupiedLocations
get
put
remove
BoundedGrid
0(1)
0(1)
0(1)
0(1)
O(rc)
O(rc)
0(1)
0(1)
0(1)
THE CASE STUDY AND THE AP EXAM
UnboundedGrid
0(1)
0(1)
0(1)
0(1)
O(n)
O(n)
0(1)
0(1)
0(1)
Approximately one-fourth of tha AP exam is ghon be devoted ta thangs on tha case
study. (This means five ta ten multiple-choice thangs n' one free-response question.)
Both level A n' AB hustlas is ghon be tested on Chaptas 1-4 of tha case study.
Yo ass must be familiar wit tha Bug, BoxBug, Critter, n' ChameleonCri tta classes,
includin they implementations. Yo ass should also be familiar wit tha documentation
for tha Location, Playa, Rock, n' Flower classes, as well as tha Grid<e> intercourse.
On tha AP exam, all hustlas is ghon be provided wit a Quick Reference dat gotz nuff
a list of methodz fo' tha precedin classes n' intercourse. Yo ass will also receive source
code fo' tha Bug, BoxBug, Critter, n' ChameleonCritta classes.
Only level AB hustlas need ta know Chapta 5 of tha case study. This includes
the documentation n' implementation fo' tha AbstractGrid<e> abstract class, and
the BoundedGrid<e> n' UnboundedGrid<e> classes. Da Quick Reference fo' level AB
students will include tha documentation n' source code fo' all tha grid classes.
NOTE
1. Da J avadoc comments <oparam, <oreturn,="" n'="" <othrows="" is="" part="" of="" tha="" ap="" java="" subset.="" in="" dis="" book="" they="" included="" up="" case="" study="" thangs="" only="" yo.="" here="" an="" example.="" 583="" ab="" (continued)="" abonly="" 584="" chapta="" 13="" da="" gridghetto="" 1**="" *="" puts="" obj="" at="" location="" loc="" grid,="" returns="" object="" previously="" location.="" null="" if="" was="" unoccupied.="" precondition:="" aint="" null,="" valid="" grid.="" @param="" where="" ghon="" be="" placed="" ta="" @return="" all="" specified="" @throws="" illegalargumentexception="" invalid="" nullpointerexception="" *1="" hood="" e="" put="" (location="" loc,="" obj)="" this="" will="" produce="" followin="" javadoc="" output:="" the="" parameters:="" -="" returns:="" throws:="" 2.="" study,="" includin="" documentation,="" narrative,="" code,="" can="" found="" http:="" u''c.<,'7£!.="" collegeboa="" rd.="" y'all="" know="" dat="" shit,="" muthafucka!="" com="" student="" testingjap="" subjects.html.="" summary="" thoroughly="" familiar="" wit="" each="" hustlas="" ghetto.="" right="" back="" yo="" muthafuckin="" ass.="" how="" fuck="" move="" and="" act.="" particular,="" you="" must="" inheritizzle="" relcitionships="" between="" various="" actors.="" on="" exam="" ass="" likely="" axed="" write="" subclassez="" bug="" or="" cri="" tter,="" modified="" methodz="" fo'="" some="" given="" superclass.="" find="" gridworid="" quick="" reference="" guide,="" so="" become="" comfortable="" referrin="" as="" yo'="" own="" code.="" by="" time="" git="" exam,="" it="" should="" second="" nature="" use="" reference.="" level="" grid="" intercourse,="" its="" methods="" are="" implemented="" abstractgrid="" class.="" also="" able="" compare="" implementations="" boundedgrid="" unboundedgridclasses.="" now="" goes="" without="" sayin="" big-o="" run="" timez="" algorithms.="" multiple-choice="" questions="" before="" begin,="" note="" that="" ="" section="" provide="" code="" from="" study.="" gonna="" reproduced="" thangs,="" since="" big-ass="" booty="" provided="" a="" cold-ass="" lil="" copy="" tested="" .="" represented="" pictures="" shown="" below.="" hustla="" facin="" north.="" these="" almost="" certainly="" different="" dem="" used="" exam!="" actor="" flower="" rock="" critta="" chameleoncritter="" 1.="" which="" afolse="" statement="" bout="" behavior?="" (a)="" when="" acts,="" do="" nothing.="" (b)="" gangbangin'="" (c)="" never="" chizzlez="" acts.="" (d)="" (e)="" gotz="" nuff="" flower,="" disappears="" suppose="" starts="" south.="" turn="" method="" called="" bug,="" what="" resultin="" direction="" be?="" north="" northeast="" northwest="" southeast="" southwest="" 585="" 586="" 3.="" consider="" boxbug="" diagram.="" ,="" ..="" <-;~.="" i="" sidelength="" 3,="" represents="" result="" executin="" act="" 0="" once="" boxbug?="" ,,="" <.-:="" ...i="" ~="" <..="" ,="" <~="" 4.="" iz="" effect="" client="" class="" fot'="" bb="freshly" smoked="" boxbug();="" red="" uptown="" pimped,="" random="" sidelength.="" (0)="" color="" with="" compile-time="" error="" occur.="" 5.="" phat="" reason="" rockin="" constants="" compass="" directions="" commonly="" angles?="" enhizzle="" readabilitizzle="" n="" there="" no="" built-in="" degree="" type="" java.="" ill="" distinguish="" locations="" directions.="" i,="" n,="" 6.="" occupy="" afta="" acts="" once?="" (1,="" 1)="" (0,1)="" (1,2)="" (2,="" (1,0)="" o="" 2="" <r..i="" t="" 587="" 588="" 7.="" wanna="" modify="" behavior="" bigs="" up:="" every="" moves="" freshly="" location,="" drops="" rather="" than="" into="" oldschool="" modifications="" correctly="" bust="" dis?="" replace="" last="" two="" "flower"="" lines="" rock();="" rock.putselflngrid(gr,="" loc);="" ii="" gr.put(loc,="" rock);="" m="" gr[loc.getrow()]="" [loc.getcol()]="rock;" pt="" monly="" ii,="" 8.="" canmove="" return="" true?="" iii="" ,="" ';:.-.~.,="" 9.="" would="" havin="" subclass="" playa="" subactor="" not="" override="" method?="" always="" blue.="" grill="" remain="" original="" gangsta="" 589="" 590="" 10.="" 4="" x="" bounded="" (2,3)="" eastside.="" happens="" bugz="" act?="" removes="" itself="" leavin="" 3)="" empty.="" 3).="" (2,4),="" remains="" 3),="" turns="" southeast.="" 11.="" critter,="" smallcritter,="" selects="" next="" randomly="" selectin="" occupies="" adjacent="" neighboring="" talkin'="" chicken="" gravy="" biatch.="" getmovelocationz="" need="" overridden.="" justification="" overridden="" method.="" gets="" possible="" move.="" occupied="" neighborin="" locations.="" postcondition:="" smallcritter.="" ~return="" list="" arraylist<location=""> getMoveLocations()
{ 1* implementation code *1 }
Which of tha followin is erect 1* implementation code *1 dat will satisfy the
postcondition?
(A) return getGrid().getNeighbors(getLocation(»;
(B) return getGrid().getValidAdjacentLocations(getLocation(»;
(C) return getGrid().getOccupiedAdjacentLocations(getLocation(»;
(D) return getActors();
(E) return getActors().getLocations();
Multiple-Choice Thangs on tha Case Study
12. Right back up in yo muthafuckin ass. Suppose a ForvardCri tta extendz Critter, n' exists only up in a funky-ass bounded grid.
A ForvardCritta has tha followin behavior when it acts .
 It smokes all hustlas up in tha grid (except fo' rocks n' other critters) dat is up in a
straight line up in tha direction dat it is facing.
 It then moves ta a random empty location up in tha straight line up in front of dat shit.
o 2 3 4
o ,
2 , -- &lt;~,. . I 
3 'tI 4
4  For example, tha ForvardCritta at (3, 1) would smoke tha bug at (1, 3) n' the
flower at (0, 4), then it would randomly move ta either (1, 3) or (0, 4). If it were
the turn of tha ForvardCri tta at (3, 3) ta act, it would smoke tha bug at (1, 3) and
then randomly move ta (2, 3), (1, 3), or (0, 3).
In implementin tha ForvardCri tta class, which Critta methodz would
need ta be overridden?
I getActors
II processActors
III getMoveLocations
(A) I only
(B) Pt II only
(C) Pt III only
(D) I n' Pt III only
(E) I, Pt II, n' Pt III
13. Right back up in yo muthafuckin ass. Suppose tha Playa class is modified ta add a Color parameta ta its constructor. Shiiit, dis aint no joke. If
the Critta class aint chizzled, what tha fuck will happen when tha modified constructor
is called ta create a Critta up in a cold-ass lil client class?
(A) A compile-time error will occur.
(B) An exception is ghon be thrown as soon as a cold-ass lil color is selected.
(C) A blue Critta is ghon be pimped.
(D) A Critta is ghon be pimped wit tha same color as tha Playa.
(E) A dialog box will appear, allowin a Critta of any color ta be pimped.
591
592 Chapta 13 Da GridGhetto Case Study
Refer ta tha grid shown fo' Thangs 14 n' 15.
o 2 3
o ,
 2 '"
,
3 &lt;~,.,I
14. Right back up in yo muthafuckin ass. Suppose it is tha turn of tha Critta up in location (2, 1) ta act. What tha fuck iz ghon be the
value of getActors 0 . size 0 fo' dis Critter?
(A) 1
(B) 2
(C) 3
(0) 4
(E) 5
15 fo' realz. Again, suppose it is tha turn of tha Critter'in location (2, 1) ta act. What will be
the value of getMoveLocations 0 . size 0 when getMoveLocations is called by
this Critterz act method?
(A) 2
(B) 3
(C) 5
(0) 7
(E) 8
Multiple-Choice Thangs on tha Case Study
Refer ta tha grid shown fo' Thangs 16 n' 17.
o
o
2  3
Location (0, 2) gotz nuff a chronic Bug.
Location (2, 0) gotz nuff a funky-ass blue Bug.
e&amp;
'"
-,2-
,I,., &lt;~ I
Location (1, 1) gotz nuff a yellow ChameleonCritter.
Location (1, 2) gotz nuff a pink Flower.
Location (2, 2) gotz nuff a funky-ass black Rock.
Location (3, 1) gotz nuff a red Critter.
Da ChameleonCri tta be bout ta act.
3
16 fo' realz. Afta tha ChameleonCri tta has acted, its color could not be
(A) blue.
(B) green.
(C) pink.
(D) black.
(E) red.
17 fo' realz. Afta tha ChameleonCri tta has acted, its direction could not be
(A) south.
(B) southeast.
(C) north.
(D) northwest.
(E) westside.
593
594 Chapta 13 Da GridGhetto Case Study
For Thangs 18 n' 19, refer ta tha modifie~ act method of tha Critta class. The
method has been chizzled by interchangin tha lines
processActors(actors);
and
ArrayList<location> moveLocs = getMoveLocations();
Here is tha modified method:
hood void act()
{
}
if (getGrid() == null)
return;
ArrayList<actor> hustlas = getActors();
ArrayList<location> moveLocs = getMoveLocations();
processActors(actors);
Location loc = selectMoveLocation(moveLocs);
makeMove(loc);
18. Right back up in yo muthafuckin ass. Suppose dat a Critta has at least one adjacent Bug. Which of tha following
must be legit as a result of tha modified act method fo' dat Critter?
(A) Da Critta would smoke a gangbangin' finger-lickin' different crew of hustlas..
(B) Da Critta would smoke fewer hustlas.
(C) There would be fewer locations available fo' tha move.
(D) Da Critta would smoke but not move.
(E) There would be no chizzle.
19. Right back up in yo muthafuckin ass. Suppose version 1 is tha original gangsta version of act, n' version 2 is tha modified
version of act. Let listl represent tha ArrayList<location> as a result
of callin getMoveLocations 0 up in version 1, n' let list2 represent the
ArrayList<location> returned by getMoveLocations 0 up in version 2. Which of
the followin could be true, given dat not a god damn thang is known bout tha surrounding
actors fo' dis Critter?
I listl.size() == list2.size()
II list 1. size 0 &gt; list2. size 0
III listl.size() &lt; list2.size()
(A) I only
(B) Pt II only
(C) Pt III only
(D) I n' Pt II only
(E) I n' Pt III only
Multiple-Choice Thangs on tha Case Study
20. For tha 3 x 3 BoundedGrid, grid, shown, refer ta tha followin code segment.
Location loc = freshly smoked up Location(1, 2);
ArrayList<location> list = grid.getValidAdjacentLocations(loc);
System.out.println(list);
o 2
o
2
What tha fuck iz ghon be output as a result of executin dis code segment?
(A) [(0,2), (2,2), (2, 1), (1, 1), (0, 1)]
(B) [(2,2), (2, 1), (1, 1), (0, 1), (0,2)]
(C) [(1, 1), (0, 1), (0, 2), (2,2), (2, 1)]
(D) [(0,2), (0, 1), (1, 1), (2, 1), (2, 2)]
(E) [(2,2), (0,2), (0, 1), (1, 1), (2, 1)]
21 fo' realz. A method is deterministic if, given tha inputs ta it, you can tell exactly what tha fuck its
result is ghon be fo' realz. A method is probabilistic if, given tha inputs, there be various
probabilitizzlez of different thangs up in dis biatch. Which of tha followin is false?
(A) Settin tha original gangsta color of any Playa is deterministic.
(B) Da getMoveLocations method up in tha Critta class is probabilistic.
(C) Da processActors method up in tha ChameleonCritta class is probabilistic.
(D) Da getActors method up in tha Critta class is deterministic.
(E) Da process whereby a BoxBug receives its sideLength is deterministic.
22. Refer ta tha followin statements concernin a 10 x 10 bounded grid.
Location loc1 = freshly smoked up Location(1, 2);
Location loc2 = loc1.getAdjacentLocation(110);
What willloc2 contain afta executin these statements?
(A) Location.EAST
(B) Location.SOUTHEAST
(C) (1,3)
(D) (2,3)
(E) (2,2)
595
596 Chapta 13 Da GridGhetto Case Study
23. Consider tha bounded grid shown.
o 2
o , .. ~, .. , <i ",.,="" <~="" i="" '"="" ~="" 2="" ="" ,="" (f="" assume="" dat="" tha="" act="" method="" fo'="" each="" hustla="" is="" invoked="" wit="" configuration="" as="" shown.="" aint="" talkin'="" bout="" chicken="" n'="" gravy="" biatch.="" which="" of="" followin="" statements="" false?="" (a)="" da="" chameleon="" crittas="" up="" in="" locations="" (1,="" 2)="" (2,="" will="" chizzle="" color="" but="" not="" location.="" (b)="" bugs="" (0,1)="" 0)="" direction="" (c)="" critta="" location="" 1)="" (0)="" flowers="" (0,="" color.="" (e)="" rocks="" neither="" nor="" multiple-choice="" thangs="" on="" case="" study="" refer="" ta="" boundedgrid="" shown="" 24="" 25.="" o="" q:.rt",="" .,="" 24.="" chameleoncritta="" facin="" south="" realz.="" afta="" it="" acts,="" its="" could="" be="" location.south="" location.west="" location.east="" oj)="" location.southeast="" location.southwest="" right="" back="" yo="" muthafuckin="" ass.="" suppose="" diagram="" chameleoncri="" tta="" blue,="" flower="" red,="" and="" the="" rock="" black.="" what="" fuck="" iz="" legit="" acts?="" a="" random="" red="" or="" black,="" equally="" likely.="" must="" red.="" blue.="" 26.="" cri="" has="" just="" one="" empty="" adjacent="" before="" turn="" act.="" dis="" .="" ghon="" ii="" grill="" same="" faced="" acted.="" ill="" moves,="" only="" possible="" neighbors="" other="" critters.="" pt="" iii="" i,="" ii,="" 27.="" r="" rows,="" c="" cols,="" n="" occupants,="" you="" can="" put="" yo'="" toast.="" big-o="" run-time="" efficiency="" (1)="" git="" (2)="" methods?="" o(rc)="" o(n)="" 0(1)="" 597="" 598="" chapta="" 13="" gridghetto="" 28.="" data="" structure="" unboundedgrid="" was="" chizzled="" to="" treemap<location,="" e="">, instead of HashMap<location, e="">. What would be
a valid reason fo' bustin this?
(A) To improve tha run time of tha getOccupiedLocations method.
(B) To improve tha run timez of tha git n' put methods.
(C) To simplify tha traversal of tha mapz key set.
(0) To facilitate tha printin of all tha hustlas up in tha grid up in alphabetical order.
(E) To facilitate tha printin of all tha occupied locations up in tha grid up in ascending
(row-major) order.
29. In order ta bust a HashMap fo' erect storage of tha UnboundedGrid, which
methodes) must tha Location class implement?
I equals
II hashCode
III compareTo
(A) I only
(B) Pt II only
(C) Pt III only
(0) I n' Pt II only
(E) I, Pt II, n' Pt III
30. Which be a gangbangin' false statement bout tha grid classes?
(A) In tha git method of BoundedGrid, tha object returned must be cast ta E
because occupantArray gotz nuff elementz of type Object.
(B) In tha UnboundedGrid class, getNumRows n' getNumCols must be implemented
even though they is meaningless up in dis implementation.
(C) Da element returned by tha git method of UnboundedGrid aint cast ta E
because joints up in tha Map is declared ta be of type E.
(0) Da AbstractGrid class must be abstract cuz it don't define all of the
methodz specified up in tha Grid intercourse.
(E) Da occupantArray of tha BoundedGrid class gotz nuff referencez of type
Object rather than type E ta allow mo' flexibilitizzle up in tha typez of elements
that can be banged tha fuck into tha grid.
31. Which is legit bout tha BoundedGrid class?
I It be a two-dimensionizzle grid wit a gangbangin' finite number of rows n' columns.
II An occupant of tha grid can be a object of any type.
III Empty locations up in tha grid gotz a value of null.
(A) I only
(B) Pt II only
(C) Pt III only
(0) I n' Pt III only
(E) I, Pt II, n' Pt III
Multiple-Choice Thangs on tha Case Study
32. In tha BoundedGrid class, what tha fuck would it mean if tha followin test was true?
occupantArray[loc.getRow()] [loc.getCol()] == null
(A) Da occupantArray has been constructed yo, but there is no hustla in
occupantArray[loc.getRow(») [loc.getCol(»).
(B) loc be a invalid location.
(C) loc has not yet been constructed rockin new.
(0) occupantArray has not yet been constructed rockin new.
(E) An error has been made n' a exception is ghon be thrown.
33. Da isValid (loc) method of BoundedGrid returns false if
I loc is null.
II loc is outta range.
III Da grid has not been constructed.
(A) I only
(B) Pt II only
(C) Pt III only
(0) I n' Pt II only
(E) I, Pt II, n' Pt III
34. Da current implementation of tha grid classes allows fo' a given location ta have
eight adjacent neighbors: dem on all four sides, n' tha four diagonally adjacent
neighbors. Right back up in yo muthafuckin ass. Suppose tha program is ghon be chizzled so dat any given location will
have just four adjacent neighbors, dem dat is north, south, eastside, n' westside of
the given location. I aint talkin' bout chicken n' gravy biatch. Which of tha followin methodz must be chizzled up in order to
achieve tha modification busted lyrics about?
I Da constructorz of tha BoundedGrid n' UnboundEidGrid classes.
II Da isValid methodz of tha BoundedGrid n' UnboundedGrid classes.
III Da getValidAdjacentLocations method of tha AbstractGrid class.
(A) I only
(B) Pt II only
(C) Pt III only
(0) I n' Pt II only
(E) I, Pt II, n' Pt III
35. Right back up in yo muthafuckin ass. Suppose tha GridGhetto case study program is run wit N hustlas n' M steps in
the simulation, where N n' M is pimpin' fo' realz. Assume dat tha grid used is implemented
with tha UnboundedGrid class. Da run-time efficiency of M stepz of the
simulation will be
(A) O(N+M)
(B) O(NM)
(C) O(N2M)
(0) O(M)
(E) O(N)
599
600
.: .. "" .. t ... ~ ~ .:-~.~. .
'./ -~ .... :s ,,' -,~. ' .. ",
Chapta 13 Da GridGhetto Case Study
36. Right back up in yo muthafuckin ass. Suppose a TreeMap is ghon be used ta implement tha UnboundedGdd class instead of
a HashMap. Which methodes) up in UnboundedGrid will need ta be chizzled?
I tha constructor
IT getOccupiedLocations
m git n' put
(A) None
(B) I only
(C) IT only
(0) monly
(E) IT n' m only
Answers Explained
"',Q~'''''''nU¥~"1'Sj[<!-- ....
ANSWER KEY
'l'r~.'_~];,:V~:a::aww»!ii&iG
1.B 13 fo' realz. A 25. C
2. E 14. C 26. B
3 fo' realz. A 15. D 27. E
4. E 16. E 28. E
5 fo' realz. A 17. B 29. D
6 fo' realz. A 18. C 30. E
7 fo' realz. A 19. D 31. D
8. E 20 fo' realz. A 32 fo' realz. A
9. C 21. B 33. B
10. E 22. C 34. C
11. C 23. B 35. B
12. D 24. D 36. B
.. ______ .... __ ........ __ .. __________ ~am~~ __ ~ues&=L LA
ANSWERS EXPLAINED
1. (8) When a gangbangin' flower acts, its color darkens.
2. (E) When a funky-ass bug turns, its resultin direction is its current direction + 45°. In
this case:
final direction = getDirection 0 + Location. I aint talkin' bout chicken n' gravy biatch yo. HALF _RIGHT
= 180+45
=225
= Location. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. SOUTHWEST
3. (A) When act 0 is called fo' dis BoxBug, tha test
if (steps < sideLength && canMove(»
will be false, since canMove 0 is false. Thus, tha bug will execute two 45° turns,
resultin up in chizzle A. Chizzle B is wack cuz it only make one 45° turn.
Choice C is tha result when act is called twice. Chizzlez D n' E is wrong
because a funky-ass bug cannot move onto a rock.
4. (E) Da error message will be
Da constructor BoxBug() is undefined.
This is cuz tha BoxBug constructor takes a int parameta representin the
sideLength fo' tha BoxBug yo. Here is tha rulez fo' subclasses n' constructors.
 Constructors is not inherited.
 If no constructor is provided up in a subclass, tha default constructor up in the
superclass is invoked. Y'all KNOW dat shit, muthafucka! If there is no default constructor up in tha superclass,
there is ghon be a cold-ass lil compile-time error.
601
602 Chapta 13 Da GridGhetto Case Study
 If a cold-ass lil constructor wit parametas is provided up in tha subclass yo, but there is
no default constructor, as is tha case up in tha BoxBug class, you must use that
constructor wit parameters; otherwise yo big-ass booty is ghon git a cold-ass lil compile-time error.
5. (A) Da constants allow you ta visualize directions at a glance. For example,
setDirection(Location.WEST) is much clearer than setDirection(270). Reason
II is bogus: A Degree type is unnecessary. (Therez not a god damn thang wack with
representin a gangbangin' finger-lickin' direction wit a int-itz just mo' readable ta bust a cold-ass lil constant.)
Reason ill be also spurious: A location be always easy as fuck  ta recognize cuz it has
both a row n' column component. This is easy as fuck  ta distinguish from a int that
represents a gangbangin' finger-lickin' direction.
6. (A) This bug aint gonna chizzle location cuz it is blocked by a rock. Its canMove
method will return false, n' tha bug will turn instead of moving.
7. (A) Segment I is erect: A freshly smoked up rock places itself up in tha bugz oldschool location n' thugged-out shit
its location n' direction. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Segment Pt II appears ta work erectly yo. However,
if tha grid addz tha rock, tha rock do not know dat its location n' direction
have been chizzled. Y'all KNOW dat shit, muthafucka! In general, when addin or removin hustlas, do not use get
and put from tha Grid intercourse, since these methodz don't update tha location
and direction jointz of tha hustla. Right back up in yo muthafuckin ass. Segment ill is egregiously wrong: Da variable
gr aint a two-dimensionizzle array, it aint nuthin but a Grid object.
S. (E) In diagram I tha bug can't move cuz it be all up in tha edge of tha grid. Y'all KNOW dat shit, muthafucka! In
diagram Pt II tha bug moves onto tha flower n' shit. In diagram ill tha location up in front of
the bug is empty, n' tha bug will move there.
9. (C) Da act method of Playa do not chizzle tha location of tha hustla fo' realz. A
SubActor would inherit dis method n' exhibit tha same behavior. Shiiit, dis aint no joke. Chizzle Pt II is
wrong cuz a Playa chizzlez direction when it acts, n' you can put dat on yo' toast. Chizzlez I n' Pt II both
fail cuz a Playa has mutator methodz setColor n' setDirection, which
would be inherited by SubActor.
10. (E) Da thang before tha bug acts is shown. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Since tha location up in front of the
bug aint valid, tha canMove method fo' dis bug will return false, n' tha bug
will remain up in its current location yo, but turn ta grill southeast (a half-turn ta the
right).
0
I
2 ~
)
11. (C) Da method getMoveLocations returns a ArrayList of Location objects;
so eliminizzle chizzlez A n' D, which return listz of Playa objects, n' you can put dat on yo' toast. Chizzle B is
wrong cuz it will return empty as well as occupied locations, which was not
required. Y'all KNOW dat shit, muthafucka! Chizzle E is egregiously wrong: There is no getLocations method in
the ArrayList class.
12. (0) Method I: getActors must be overridden cuz yo ass is no longer getting
the hustlas up in neighborin locations. Method Pt II: processActors should not be
overridden, since once you have tha list of hustlas, tha action taken on dem is
Answers Explained
no different from tha action taken by regular crittas (namely, they git smoked if
they is not rocks or other critters). Method Ill: getMoveLocations must be
overridden since yo ass is no longer gettin adjacent locations.
13. (A) A subclass do not inherit constructors from tha superclass. If there is no
constructor provided up in tha subclass, tha compila will provide a thugged-out default constructor
that calls tha superclass default constructor. Shiiit, dis aint no joke. If tha constructor up in the
superclass (Actor up in dis case) aint a thugged-out default constructor, a cold-ass lil compile-time error
will occur when you try ta construct a subclass object. Note dat if a parameter
is added ta tha Playa constructor, Playa no longer has a thugged-out default constructor.
14. (C) Da getActors method returns a list of adjacent hustlas. For tha grid shown,
the list will contain tha flower at (2, 2), tha rock at (3, 0), n' tha bug at (1, 1).
Therefore tha size of tha list is 3.
15. (0) When tha Critta acts it "eats" tha non rock n' noncritta hustlas up in the
getActors list. Then, getMoveLocations 0 gets a list of adjacent, empty, neighboring
locations. In dis case tha list gotz nuff (1, 0), (1, 1), (1, 2), (2, 2), (3, 2),
(3,1), n' (2, O)-seven elements, n' you can put dat on yo' toast. Notice dat locations (1,1) n' (2, 2) is empty
because tha previous occupants done been eaten. I aint talkin' bout chicken n' gravy biatch. Da rock, however, is still there.
16. (E) Da hustlas processed by any Critta must be up in adjacent neighborin locations.
Since location (3, 1) do not satisfy dis condition, tha red Critta in
(3, 1) aint included up in tha ChameleonCritterz getActors list.
17. (B) Da getMoveLocationsO method fo' tha ChameleonCritta will contain
the followin locations: (2, 1), which is downtown of (1, 1); (0, 1), which is uptown of
(1, 1); (0, 0), which is northwest of (1, 1); n' (1, 0), which is westside of (1, 1). Thus,
the ChameleonCri tta will end up facin south, north, northwest, or westside. It
cannot end up facin southeast cuz it cannot move ta location (2, 2), which
is southeast of (1, 1).
18. (C) Da effect of tha chizzle is ta git tha list of empty adjacent neighboring
locations before tha "edible" neighborin hustlas done been removed. Y'all KNOW dat shit, muthafucka! There would
therefore be fewer empty locations available. Notice dat chizzle D may be true
(if all tha neighborin locations was occupied before processing) yo, but it is not
necessarily true.
19. (0) See tha explanation fo' tha previous question on tha effect of modifyin the
act method. Y'all KNOW dat shit, muthafucka! Test I would be legit if there was no adjacent hustlas ta be eaten.
Test Pt II would be legit if there was at least one adjacent hustla ta be eaten. I aint talkin' bout chicken n' gravy biatch. Test
III could never be true: Da original gangsta version of tha method creates tha freshest
possible list of available empty locations, since it removes a shitload of tha adjacent
actors before tha list is pimped.
20. (A) Da algorithm up in tha getValidAdj acentLocations method starts wit the
adjacent location uptown of loc (0°) and, ,goin up in incrementz of 45°, gets the
adjacent location up in dat direction. I aint talkin' bout chicken n' gravy biatch. If dat location is up in tha grid, it addz it ta the
list.
21. (B) There is not a god damn thang random bout how tha fuck a Critta gets its list of possible move
locations. Well shiiiit, it simply gets tha list of empty neighborin locations. Chizzlez A and
E is true: Da color n' side length joints is provided up in tha constructors.
Choice C is true: A ChameleonCri tta randomly selects a Playa whose color
it will assume. Chizzle D is true: A Critta gets tha list of hustlas dat is in
adjacent neighborin locations. There is no probabilitizzle involved.
603
604 Chapta 13 Da GridGhetto Case Study
AD,ONLY.
22. (C) Da justification fo' getAdjacentLocation is ta return tha adjacent location
that is up in tha compass direction nearest ta its parameter n' shit. Right back up in yo muthafuckin ass. Since it do not return
the nearest compass direction, reject chizzlez A n' B. Da nearest compass
direction ta 110 is 90, or eastside. Da adjacent location eastside of (1,2) is location (1, 3).
N f 10
W ..... E
s
23. (B) Da bug up in (2, 0) will move onto tha flower up in (2, 1). (Da other bug, however,
is blocked by tha critta up in (1, 1), n' will turn right.) Each of tha other chizzles
is true. Chizzle A: Da chameleon crittas have no empty adjacent locations to
move to. They will, however, randomly pick one of tha neighborin hustlas and
change color. Shiiit, dis aint no joke. Chizzle C: Da critta will smoke tha bugs up in (0, 1) n' (2, 0) and
the flowers up in (0, 0) n' (2, 1), makin they locations available. Da critta will
randomly pick one of these n' move. Chizzle D: Flowers git darker when they
act. Chizzle E: Rocks do not a god damn thang when they act.
24. (0) Da ChameleonCri tta endz up facin tha direction up in which it moved. Y'all KNOW dat shit, muthafucka! Since
it cannot move onto tha flower, it cannot end up facin southeast.
25. (C) Da only hustla up in tha ChameleonCritterz hood is tha red Flower.
Therefore tha ChameleonCri tta endz up red.
26. (B) A Critta do not chizzle direction when it acts, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Statement I is wrong
because a Critta can end up in tha location of a hustla dat it ate. Right back up in yo muthafuckin ass. Statement
III is wack cuz afta a Critta moves ta a gangbangin' finger-lickin' different location, its adjacent
neighbors is different from dem dat it had before tha move.
27. (E) Each of these methodz is given tha location dat is ghon be accessed. Y'all KNOW dat shit, muthafucka! A twodimensional
array allows O( 1) access ta any location, using
occupantArray[loc.getRow()] [loc.getCol()]
Da git method returns tha object at dat location, n' tha put method places a
new object at dat location, while returnin tha "old" object.
28. (E) A TreeMap stores tha elementz of tha key set up in a funky-ass balanced binary search tree.
To print tha keys up in ascendin order, a inorder traversal of tha binary search
tree is performed. Y'all KNOW dat shit, muthafucka! In a HashMap, tha keys is stored up in a hash table. Printin the
keys aint gonna produce dem up in any predictable order.
Note dat chizzlez A n' C is wack cuz it is equally easy as fuck -and efficientto
traverse tha key set of either a HashMap or a TreeMap. Chizzle B is wack cuz
get n' put fo' a HashMap is O( 1), while fo' a TreeMap they is O(log n ).
Choice D is wack cuz a TreeMap produces tha keys up in order, not tha corresponding
values. Besides, what tha fuck do it mean ta print tha hustlas up in alphabetical
order??
29. (0) Definin both equals n' hashCode up in any class ensures dat objectz of that
class can be stored up in a set without allowin duplicates. Da condizzle fo' obj 1
and obj2 ta be duplicates is
obj 1. equals (obj2) ==--> obj1.hashCodeO == obj2.hashCodeO
Answers Explained
If hashcode has not been defined fo' tha class, then both objl n' obj2 may
be added ta tha set (wrongly), even though you consider dem ta be equal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. In
the HashMap of tha UnboundedGrid, it is blingin dat there not be duplicate
locations up in tha key set, which is stored as a HashSet. Note dat it aint necessary
for tha objects up in a HashSet ta be Comparable (no ordering). Therefore, fo' the
HashMap implementation, Location do not need compareTo.
30. (E) Da type of elements up in tha array is Db j ect cuz Java do not allow arrays
of generic types. Da followin is illegal n' will cause a cold-ass lil compile-time error:
private E[] [] occupantArray = freshly smoked up E[rows] [cols];
31. (0) Statement Pt II is false cuz tha grid is declared as BoundedGrid<e>, which
means dat occupantz of tha grid must be objectz of type E.
32. (A) In tha constructor, tha line
occupantArray = freshly smoked up Dbject[rows] [cols];
creates a rows X cols tw<hlimensionizzle array="" of="" null="" objects,="" n'="" you="" can="" put="" dat="" on="" yo'="" toast.="" each="" slot="" represents="" an="" empty="" location.="" i="" aint="" talkin'="" bout="" chicken="" gravy="" biatch.="" notice="" up="" in="" tha="" remove="" method,="" line="" occupantarray[loc.getrow()]="" [loc.getcol()]="null;" signifies="" loc="" is="" now="" empty.="" 33.="" (8)="" da="" precondizzle="" fo'="" method="" null.="" if="" null,="" exception="" thrown.="" grid="" has="" not="" been="" constructed,="" call="" grid.="" y'all="" know="" shit,="" muthafucka!="" isvalid(loc)="" will="" throw="" a="" nullpointerexception="" before="" any="" value="" be="" returned.="" 34.="" (c)="" only="" goes="" fuck="" into="" detailz="" gettin="" adjacent="" locations="" the="" getvalidadjacentlocations="" abstractgrid="" class.="" every="" other="" uses="" some="" subset="" these="" starts="" by="" callin="" getvalidadj="" acentlocations.="" note="" constructorz="" boundedgrid="" and="" unboundedgrid="" simply="" creates="" containin="" no="" occupants.="" 35.="" for="" n="" hustlas="" ta="" act="" once="" o(n),="" since="" getting,="" putting,="" removin="" objects="" hashmap="" o(="" 1).="" thus="" hustla="" m="" times="" o(nm).="" 36.="" implementation="" constructor="" need="" chizzled="" to="" occupantmap="freshly" smoked="" treemap<location,="" e="">();
Da Map operations required fo' tha methodz up in Pt II n' Pt III is identical fo' a
TreeMap n' a HashMap, so not a god damn thang else need ta be chizzled.
605
AB (conti1Uled)
Practice
Exams
Answer Sheet: Practice Exam Three
1. ®®©®® 15. ®®©®® 29. ®®©®®
2. ®®©®® 16. ®®©®® 30. ®®©®®
3. ®®©®® 17. ®®©®® 31. ®®©®®
4. ®®©®® 18. ®®©®® 32. ®®©®®
5. ®®©®® 19. ®®©®® 33. ®®©®®
6. ®®©®® 20. ®®©®® 34. ®®©®®
7. ®®©®® 21. ®®©®® 35. ®®©®®
8. ®®©®® 22. ®®©®® 36. ®®©®®
9. ®®©®® 23. ®®©®® 37. ®®©®®
10. ®®©®® 24. ®®©®® 38. ®®©®®
11. ®®©®® 25. ®®©®® 39. ®®©®®
12. ®®©®® 26. ®®©®® 40. ®®©®®
13. ®®©®® 27. ®®©®®
14. ®®©®® 28. ®®©®®
How tha fuck ta Calculate Yo crazy-ass (Approximate) AP Score - AP Computa Science Level A
Multiple Chizzle
Number erect (out of 40)
1/4 x number wrong
Raw score = line 1 - line 2
Jacked Response
Question 1
(out of 9)
Question 2
(out of 9)
Question 3
(out of 9)
Question 4
(out of 9)
Total
Final Score
+
Multiple- Free-
Choice Response
Score Score
= Multiple-Choice Score
(Do not round. Y'all KNOW dat shit, muthafucka! If less
than zero, enta zero.)
x 1.11
Final Score
(Round ta nearest
whole number.)
Chart ta Convert ta AP Grade
Computa Science A
Final AP Grade4
_~_c~~e}~~~~~._~ _________ _
60-80
45-59
33-44
25-32
0-24
5
4
3
2
1
4Da score range correspondin to
each grade varies from exam ta exam
and be approximate.
= Free-Response Score
(Do not round.)
Practice Exam Three
Practice Exam Three
COMPUTER SCIENCE A
SECTION I
Time-1 minute n' 15 minutes
Number of thangs-40
Percent of total grade-50
Directions: Determine tha answer ta each of tha followin thangs or incomplete
statements, rockin tha available space fo' any necessary scratchwork.
Then decizzle which is tha dopest of tha chizzlez given n' fill up in tha corresponding
oval on tha answer sheet. Do not spend too much time on mah playas problem.
Notes:
 Assume dat tha classes up in tha Quick Reference done been imported where
needed.
 Assume dat variablez n' methodz is declared within tha context of an
enclosin class.
 Assume dat method calls dat have no object or class name prefixed, and
that is not shown within a cold-ass lil complete class definition, step tha fuck up within the
context of a enclosin class.
 Assume dat parametas up in method calls is not null unless otherwise
stated.
1 fo' realz. A big-ass Java program was tested extensively n' no errors was found. Y'all KNOW dat shit, muthafucka! What can
be concluded?
(A) All of tha preconditions up in tha program is erect.
(B) All of tha postconditions up in tha program is erect.
(C) Da program may have bugs.
(0) Da program has no bugs.
(E) Every method up in tha program may safely be used up in other programs.
GO ON TO THE NEXT PAGE.
609
610 Practice Exams
Thangs 2-4 refer ta tha Worker class below:
hood class Worker
{
}
private Strin myName;
private double myHourlyWage;
private boolean isUnionMember;
//constructors
hood WorkerO
{ /* implementation not shown */ }
hood Worker(Strin name, double hourlyWage, boolean union)
{ /* implementation not shown */ }
//accessors getName, getHourlyWage, getUnion~tatus not shown ...
//modifiers
//Permanently increase hourly wage by amt.
hood void incrementWage(double amt)
{ /* implementation of incrementWage */ }
//Switch value of isUnionMember from legit ta false n' vice versa.
hood void chizzleUnionStatus()
{ /* implementation of chizzleUnionStatus */ }
2. Refer ta tha increment Wage method. Y'all KNOW dat shit, muthafucka! Which of tha followin be a cold-ass lil erect
/* implementation of incrementWage */?
(A) return myHourlyWage + amt;
(B) return getHourlyWage() + amt;
(C) myHourlyWage += amt;
OJ) getHourlyWage() += amt;
(E) myHourlyWage = amt;
GO ON TO THE NEXT PAGE.
Practice Exam Three
3. Consider tha method chizzleUnionStatus. Which be a cold-ass lil erect
1* implementation of chizzleUnionStatus */?
I if (isUnionMember)
isUnionMember = false;
else
isUnionMember = true;
II isUnionMember = !isUnionMember;
III if (isUnionMember)
isUnionMember = !isUnionMember;
(A) I only
(B) Pt II only
(C) Pt III only
(0) I n' Pt II only
(E) I, Pt II, n' Pt III
4 fo' realz. A client method computePay will return a workerz pay based on tha number of
hours worked.
IIPrecondition: Worker w has hit dat shiznit tha given number of hours.
IIPostcondition: Returns amount of pay fo' Worker w.
hood static double computePay(Worker w, double hours)
{ 1* code *1 }
Which replacement fo' 1* code *1 is erect?
(A) return myHourlyWage * hours;
(B) return getHourlyWageO * hours;
(C) return w.getHourlyWage() * hours;
(0) return w.myHourlyWage * hours;
(E) return w.getHourlyWage() * w.hours;
5. Consider dis program segment. Yo ass may assume dat wordList has been declared
as ArrayList<string>.
for (Strin s : wordList)
if (s.length() &lt; 4)
System.out.println("SHORT WORD");
What tha fuck iz tha maximum number of times dat SHORT WORD can be printed?
(A) 3
(B) 4
(C) wordList.size()
(0) wordList.size() - 1
(E) s . length 0
GO ON TO THE NEXT PAGE.
611
612
6. Refer ta tha followin method.
hood static int mystery(int n)
{
}
if (n =:s 1)
return 3;
else
return 3 * mystery(n - 1);
What value do mystery (4) return?
(A) 3
(B) 9
(C) 12
(0) 27
(E) 81
7. Refer ta tha followin declarations:
Practice Exams
String[] flavas = {"red", "green", "black"};
ArrayList<string> colorList = freshly smoked up ArrayList<string>();
Which of tha followin erectly assigns tha elementz of tha flavas array to
colorList, biatch? Da final orderin of flavas up in colorList should be tha same as
in tha flavas array.
I fo' (Strin col : colors)
colorList.add(col);
II fo' (Strin col : colorList)
colors.add(col)j
III fo' (int i = colors.length - 1; i &gt;= 0; i--)
colorList.add(i, colors[i]);
(A) I only
(B) Pt II only
(C) Pt III only
(0) Pt II n' Pt III only
(E) I, Pt II, n' Pt III
GO ON TO THE NEXT PAGE.
Practice Exam Three
Thangs 8 n' 9 refer ta tha classes Address n' Hustla given below.
hood class Address
{
private Strin myStreetj
private Strin myCitYj
private Strin myStatej
private int myZipCodej
Ilconstructor
hood Address(Strin street, Strin hood, Strin state, int zipCode)
{ 1* implementation not shown *1 }
Ilaccessors
hood Strin getStreet()
{ 1* implementation not shown *1 }
hood Strin getCity()
{ 1* implementation not shown *1 }
hood Strin getState()
{ 1* implementation not shown *1 }
hood int getZipCode()
{ 1* implementation not shown *1 }
}
hood class Customer
{
}
private Strin myNamej
private Strin myPhonej
private Address myAddressj
private int my10j
Ilconstructor
hood Customer(Strin name, Strin phone, Address addr, int 10)
{ 1* implementation not shown *1 }
Ilaccessors
IIReturns address of dis hustla.
hood Address getAddress()
{ 1* implementation not shown *1 }
hood Strin get~ame()
{ 1* implementation not shown *1 }
hood Strin getPhone()
{ 1* implementation not shown *1 }
hood int get10()
{ 1* implementation not shown *1 }
GO ON TO THE NEXT PAGE.
613
614 Practice Exams
8. Which of tha followin erectly creates a Hustla object c?
I Address a = freshly smoked up Address("125 Bismark St", "Pleasantville",
"NY", 14850);
Hustla c = freshly smoked up Customer("Jack Spratt", "747-1674", a, 7008);
II Hustla c = freshly smoked up Customer("Jack Spratt", "747-1674",
"125 Bismark St, Pleasantville, NY 14850", 7008);
III Hustla c = freshly smoked up Customer("Jack Spratt", "747-1674",
new Address("125 Bismark St", "Pleasantville", "NY", 14850),
7008);
(A) I only
(B) Pt II only
(C) monly
(D) I n' Pt II only
(E) I n' m only
9. Consider a AllCustomers class dat has private instizzle variable
private Customer[] custList;
Given tha ID number of a particular hustla, a method of tha class, locate,
must find tha erect Hustla record n' return tha name of dat hustla.
Here is tha method locate:
1* Precondition: custList gotz nuff a cold-ass lil complete list of Customer
* objects, n' you can put dat on yo' toast. idNum matches tha 10 number data member
* of one of tha Hustla objects.
* Postcondition: Da name of tha hustla whose 10 number
* matches idNum is returned. Y'all KNOW dat shit, muthafucka! *1
hood Strin locate(int idNum)
{
}
for (Hustla c : custList)
if (c.get10() == idNum)
return c.getName();
return null; IlidNum not found
A mo' efficient algorithm fo' findin tha matchin Hustla object could be
used if
(A) Hustla objects was up in alphabetical order by name.
(B) Hustla objects was sorted by beeper number.
(C) Hustla objects was sorted by ID number.
(D) tha custList array had fewer elements.
(E) tha Hustla class did not have a Address data member.
GO ON TO THE NEXT PAGE.
Practice Exam Three
10. Often da most thugged-out efficient computa algorithms bust a gangbangin' finger-lickin' divide-and-conquer approach,
for example, one up in which a list is repeatedly split tha fuck into two pieces until
a desired outcome is reached. Y'all KNOW dat shit, muthafucka! Which of tha followin bust a gangbangin' finger-lickin' divide-and-conquer
approach?
I Mergesort
IT Insertion sort
m Binary search
(A) I only
(B) IT only
(C) monly
(D) I n' m only
(E) I, IT, n' m
11. In Java, a variable of type int is represented internally as a 32-bit signed integer.
Suppose dat one bit stores tha sign, n' tha other 31 bits store tha magnitude of
the number -in base 2. In dis scheme, what tha fuck is tha phattest value dat can be stored
as type int?
(A) 232
(B) 232 _1
(C) 231
(D) 231 _1
(E) 230
12. Refer ta method removeWord.
//Precondition: wordList be a ArrayList of Strin objects.
//Postcondition: All occurrencez of word done been removed from
wordList.
hood static void removeWord(ArrayList<string> wordList,
Strin word)
{
for (int i = 0; i &lt; wordList.size(); i++)
if «wordList.get(i».equals(word»
wordList.remove(i);
}
Da method do not always work as intended. Y'all KNOW dat shit, muthafucka! Consider tha method call
removeWord(wordList, "cat");
For which of tha followin lists will dis method call fail?
(A) Da pussaaaaay sat on tha mat
(B) Da pussaaaaay cat sat on tha mat mat
(C) Da pussaaaaay sat on tha cat
(D) cat
(E) Da cow sat on tha mat
GO ON TO THE NEXT PAGE.
615
616
13. What tha fuck iz ghon be output by dis code segment?
for (int i = 5; i &gt; 0; i--)
{
}
(A)
(B)
1
for (int j = 1; j &lt;= i; j++)
System.out.print(j * j + Pt II Pt II);
System.out.println();
1 4
149
1 4 9 16
1 4 9 16 25
1 4 9 16 25
1 4 9 16
149
1 4
1
(C) 25 16 9 4 1
25 16 9 4
25 16 9
25 16
25
(D) 25
25 16
25 16 9
25 16 9 4
25 16 9 4 1
(E) 1 4 9 16 25
1 4 9 16 25
1 4 9 16 25
1 4 9 16 25
1 4 9 16 25
Practice Exams
GO ON TO THE NEXT PAGE.
Practice Exam Three
14. Consider two different wayz of storin a set of nonnegatizzle integers up in which
there is no duplicates.
Method One: Store tha integers explicitly up in a array up in which tha number of
elements is known. I aint talkin' bout chicken n' gravy biatch. For example, up in dis method, tha set {6, 2, 1,8,9, O} can be
represented as bigs up:
o 123 4 5 r 6 I 2j\D19 1 0
6 elements
Method Two: Suppose dat tha range of tha integers is 0 ta MAX. Use a funky-ass boolean
array indexed from 0 ta MAX. Da index joints represent tha possible joints
in tha set. In other lyrics, each possible integer from 0 ta MAX is represented
by a gangbangin' finger-lickin' different posizzle up in tha array fo' realz. A value of legit up in tha array means dat the
correspondin integer is up in tha set, a value of false means dat tha integer aint in
the set. For example, rockin dis method fo' tha same set above, {6, 2, 1,8,9, A},
the representation would be as bigs up (f = true, F = false):
o 1 2 3 4 5 6 7 8 9 10 MAX
~[T]-----,-_f]---,--T---,--_F---,i_F_~_~p: ---I...l_Tl F l-T"TT-m I F I
Da followin operations is ta be performed on tha set of integers:
I Search fo' a target value up in tha set.
II Print all tha elementz of tha set.
ill Return tha number of elements up in tha set.
Which statement is true?
(A) Operation I is mo' efficient if tha set is stored rockin Method One.
(B) Operation Pt II is mo' efficient if tha set is stored rockin Method Two.
(C) Operation ill is mo' efficient if tha set is stored rockin Method One.
(D) Operation I is equally efficient fo' Methodz One n' Two.
(E) Operation ill is equally efficient fo' Methodz One n' Two.
15 fo' realz. An algorithm fo' findin tha average of N numbers is
sum
average=N
where N n' sum is both integers. In a program rockin dis algorithm, a programmer
forgot ta include a test dat would check fo' N equal ta zero. If N is
zero, when will tha error be detected?
(A) At compile time
(B) At edit time
(C) As soon as tha value of N is entered
(D) Durin run time
(E) When a incorrect result is output
" GO ON TO THE NEXT PAGE.
617
618
16. What tha fuck iz poppin' off wit dis intercourse?
hood intercourse Bad
{
void someMethod(Strin password)
{
Practice Exams
System.out.println("Psstl Da password is Pt II + password);
}
}
(A) A method up in a intercourse should be declared public.
(B) A method up in a intercourse should be declared abstract.
(C) There should not be a method implementation.
(0) There should be a cold-ass lil class implementation provided.
(E) There should not be any method parameters.
17. Consider a program dat deals wit various componentz of different hoopties.
Which of tha followin be a reasonable representation of tha relationshizzlez among
some classes dat may comprise tha program, biatch? Note dat a open up-arrow denotes
an inheritizzle relationshizzle n' a thugged-out down-arrow denotes a cold-ass lil composizzle relationshizzle.
(A)
(0)
(E)
GO ON TO THE NEXT PAGE.
Practice Exam Three
18. Consider tha followin program segment:
IIPrecondition: a[O] ... a[n-l] be a initialized array of
II integers, 0 &lt; n &lt;= a.length.
int c = 0;
for (int i = 0; i &lt; n; i++)
if (a[i] &gt;= 0)
{
}
n = c;
a[c] = a[i];
c++;
Which is tha dopest postcondizzle fo' tha segment?
(A) a[O] ... a[n-l] has been stripped of all positizzle integers.
(B) a[O] ... a[n-l] has been stripped of all wack integers.
(C) a [0] ... a [n-l] has been stripped of all nonnegatizzle integers.
(D) a[0] ... a[n-l] has been stripped of all occurrencez of zero.
(E) Da updated value of n is less than or equal ta tha value of n before execution
of tha segment.
19. If a, b, n' c is integers, which of tha followin conditions is sufficient ta guarantee
that tha expression
a &lt; c I I a &lt; b t&amp;: ! (a == c)
evaluates ta true?
(A) a &lt; c
(B) .a &lt; b
(C) a &gt; b
(D) a == b
(E) a == c
20 fo' realz. Airmail Express charges fo' shippin lil' small-ass packages by integer jointz of weight.
Da charges fo' a weight w up in poundz is as bigs up:
0<w~2 $4.00="" 2="" <="" w="" ~="" 5="" $8.00="" 20="" $15.00="" da="" company="" do="" not="" accept="" packages="" dat="" weigh="" mo'="" than="" pounds.="" which="" of="" tha="" followin="" represents="" dopest="" set="" data="" (weights)="" ta="" test="" a="" program="" that="" calculates="" shippin="" charges?="" (a)="" 0,="" 2,="" 5,="" (b)="" 1,4,="" 16="" (c)="" -1,="" 1,="" 3,="" 16,="" (d)="" -1,0,1,2,3,5,16,20,22="" (e)="" all="" integers="" from="" -1="" up="" in="" 22="" go="" on="" to="" the="" next="" page.="" 619="" 620="" practice="" exams="" thangs="" 21-22="" is="" based="" class="" declaration:="" hood="" autopart="" {="" private="" strin="" mydescription;="" int="" mypartnum;="" double="" myprice;="" ii="" constructor="" autopart(strin="" description,="" partnum,="" price)="" 1*="" implementation="" shown="" *1="" }="" ilaccessors="" getdescription()="" return="" getpartnum()="" getprice()="" exam="" three="" 21.="" this="" question="" refers="" findcheapest="" method="" below,="" occurs="" cold-ass="" lil="" has="" array="" as="" one="" if="" its="" fields:="" autopart[]="" allpartsj="" examines="" n'="" returns="" part="" number="" wit="" lowest="" price="" whose="" description="" matches="" partdescription="" parameter="" shit.="" for="" example,="" nuff="" muthafuckin="" elements="" may="" have="" "headlight"="" they="" field.="" y'all="" know="" shit,="" muthafucka!="" different="" headlights="" will="" differ="" both="" parameta="" "headlight",="" then="" skankyest="" headlight.="" precondition:="" allparts="" gotz="" at="" least="" element="" *="" partdescription.="" postcondition:="" i="" aint="" talkin'="" bout="" chicken="" gravy="" biatch.="" findcheapest(strin="" partdescription)="" min="LARGEVALUEj" (autopart="" p="" :="" allparts)="" code="" iiautopart="" so="" far="" illarger="" any="" valid="" replacements="" fo'="" big="" intended="" postcondizzle="" method?="" (p.getprice()="" min)="" part.getpartnum()j="" (p.getdescription().equals(partdescription»="" iii="" only="" pt="" p.getpartnum();="" (0)="" 621="" 622="" 22.="" consider="" method:="" ob1="" ob2="" distinct="" comparable="" objects.="" smalla="" ob2.="" static="" (comparable="" ob1,="" ob2)="" (ob1.compareto(ob2)="" 0)="" ob1;="" else="" ob2;="" same="" these="" declarations:="" p1="freshly" smoked="" «suitable="" joints="" »;="" p2="" -="" freshly="" (="" suitable="" joints»="" ;="" statements="" cause="" error?="" system.out.println(min(p1.getdescription(),="" p2.getdescription(»);="" it="" system.out.println(min«(string)="" p1).getdescription(),="" «string)="" p2).getdescription(»);="" system.out.println(min(p1,="" p2»;="" none="" 23.="" stra="CARROT" ,="" strb="Carrot" strc="car" given="" uppercase="" lettas="" precede="" lowercase="" when="" thankin="" alphabetical="" order,="" true?="" stra.compareto(strb)="" 0="" tt="" strb.compareto(strc)=""> 0
(B) strC.compareTo(strB) &lt; 0 tt strB.compareTo(strA) &lt; 0
(C) strB.compareTo(strC) &lt; 0 tt strB.compareTo(strA) &gt; 0
(0) !(strA.compareTo(strB) == 0) tt strB.compareTo(strA) &lt; 0
(E) !(strA.compareTo(strB) == 0) tt strC.compareTo(strB) &lt; 0
GO ON TO THE NEXT PAGE.
Practice Exam Three
Thangs 24-26 refer ta tha ThreeDigitlnteger n' ThreeDigitCode classes below.
hood class ThreeDigitlnteger
{
}
private int my8undredsDigitj
private int myTensDigitj
private int myOnesDigitj
private int myValuej
Ilconstructor
Ilvalue be a 3-digit into
hood ThreeDigitlnteger(int value)
{ 1* implementation not shown *1 }
IIReturn sum of digits fo' dis ThreeDigitlnteger.
hood int digitSum()
{ 1* implementation not shown *1 }
IIReturn sum of hundredz digit n' tens digit.
hood int twoDigitSum()
{ 1* implementation not shown *1 }
Ilother methodz not shown
hood class ThreeDigitCode extendz ThreeDigitlnteger
{
}
private boolean mylsValidj
Ilconstructor
Ilvalue isa 3-digit into
hood ThreeDigitCode(int value)
{ 1* implementation code *1 }
1* Returns legit if ThreeDigitCode is valid, false otherwise.
* ThreeDigitCode is valid if n' only if tha remainder when the
* sum of tha hundredz n' tens digits is divided by 7 equals the
* ones digit. Thus 362 is valid while 364 is not. *1
hood boolean isValid()
{ 1* implementation not shown *1 }
GO ON TO THE NEXT PAGE.
623
624 Practice Exams
24. Which be a legit statement bout tha classes shown?
(A) Da ThreeDigi tInteger class inherits tha isValid method from tha class
ThreeDigi tCode.
(B) Da ThreeDigi tCode class inherits all of tha private instizzle variablez and
hood accessor methodz from tha ThreeDigi tlnteger class.
(C) Da ThreeDigi tCode class inherits tha constructor from tha class
ThreeDigitlnteger.
(0) Da ThreeDigitCode class can directly access all tha private variablez of the
ThreeDigitlnteger class.
(E) Da ThreeDigitlnteger class can access tha myIsValid instizzle variable of
the ThreeDigi tCode class.
25. Which is erect 1* implementation code *1 fo' tha ThreeDigitCode constructor?
I super(value);
myIsValid = isValid();
n supa (value , valid);
III super(value);
myIsValid = twoDigitSum() % 7 == myOnesDigit;
(A) Ionly
(B) n only
(C) Pt IIIonly
(0) I n' Pt III only
(E) I, n, n' Pt III
26. Refer ta these declarations up in a cold-ass lil client program:
ThreeDigitlnteger code = freshly smoked up ThreeDigitCode(127);
ThreeDigitlnteger Dum = freshly smoked up ThreeDigitlnteger(456);
Which of tha followin subsequent tests aint gonna cause a error?
I if (code.isValid(»
n if (num. isValid 0 )
III if «(ThreeDigitCode) code).isValid(»
(A) I only
(B) n only
(C) Pt III only
(0) I n' n only
(E) I n' Pt III only
GO ON TO THE NEXT PAGE.
Practice Exam Three
2,7. Consider tha followin hierarchy of classes:
Assumin dat each class has a valid default constructor, which of tha following
declarations up in a cold-ass lil client program is erect?
I Bird bl = freshly smoked up Parrot();
Bird b2 = freshly smoked up Parakeet();
Bird b3 = freshly smoked up Owl();
II Parakeet p = freshly smoked up Parrot();
Owl 0 = freshly smoked up Bird();
III Parakeet p = freshly smoked up Bird();
(A) I only
(B) Pt II only
(C) Pt III only
(0) Pt II n' Pt III only
(E) I, Pt II, n' Pt III
28. Consider a array arr n' a list list dat be a ArrayList<string>. Both arr
and list is initialized wit strang joints, n' you can put dat on yo' toast. Which of tha followin code segments
correctly appendz all tha strings up in arr ta tha end of list?-
I fo' (Strin s : arr)
list.add(s);
II fo' (Strin s : arr)
list.add(list.size(), s);
III fo' (int i = 0; i &lt; arr.length; i++)
list.add(arr[i]);
(A) I only
(B) Pt II only
(C) Pt III only
(0) I n' Pt III only
(E) I, Pt II, n' Pt III
GO ON TO THE NEXT PAGE.
625
626 Practice Exams
29. Refer ta tha nextIntInRange method below:
1* Postcondition: Returns a random integer up in tha range
* low ta high, inclusive. *1
hood int nextlntlnRange(int low, int high)
{
return 1* expression *1
}
Which 1* expression *1 will always return a value dat satisfies tha postcondition?
(A) (int) (Math.randomO * high) + low;
(B) (int) (Math.random() * (high - low» + low;
(C) (int) (Math. random 0 * (high - low + 1» + low;
(D) (int) (Math.random() * (high + low» + low;
(E) (int) (Math.random() * (high + low - 1» + low;
30. Consider tha followin mergeSort method n' tha private instizzle variable a
both up in tha same Sorta class:
private Comparable[] a;
1* Sorts a[first] ta a[last] up in increasin order rockin mergesort. *1
hood void mergeSort(int first, int last)
{
}
if (first != last)
{
}
int mid = (first + last) I 2;
mergeSort(first, mid);
mergeSort(mid + 1, last);
merge (first , mid, last);
Method mergeSort calls method merge, which has dis header:
1* Merge a[lb] ta a[mi] n' a[mi+1] ta a[ub].
* Precondition: a[lb] ta a[mi] n' a[mi+1] ta a[ub] both
* sorted up in increasin order n' shit. *1
private void merge(int lb, int mi, int ub)
If tha straight-up original gangsta call ta mergeSort is mergeSort (0,3) , how tha fuck nuff further calls will there
be ta mergeSort before a array b [0] ... b [3] is sorted?
(A) 2
(B) 3
(C) 4
(D) 5
(E) 6
GO ON TO THE NEXT PAGE.
Practice Exam Three
31 fo' realz. A programmer has a gangbangin' file of names. Right back up in yo muthafuckin ass. Biatch is designin a program dat sendz junk
mail lettas ta mah playas on tha list. To make tha lettas sound underground and
friendly, dat biiiiatch will extract each personz first name from tha name string. Right back up in yo muthafuckin ass. Biatch plans
to create a parallel file of first names only. For example,
fullName
Ms fo' realz. Anjali DeSouza
Dr. Shiiit, dis aint no joke. Jizzy Roufaiel
Mrs. Mathilda Concia
firstName
Anjali
John
Mathilda
Here be a method intended ta extract tha straight-up original gangsta name from a gangbangin' full name string.
/* Precondition: fullName starts wit a title followed by a period.
* A single space separates tha title, first name,
* n' last name.
* Postcondition: Returns tha straight-up original gangsta name only. */
hood static Strin getFirstName(Strin fullName)
{
}
final Strin BLANK = ., ";
Strin temp, firstName;
/ * code ta extract first name * /
return firstName;
Which represents erect / * code ta extract first name * /?
lint k = fullName.indexOf(BLANK);
temp = fullName.substring(k + 1);
k = temp.indexOf(BLANK);
firstName = temp.substring(O, k);
IT int k = fullName.indexOf(BLANK);
firstName = fullName.substring(k + 1);
k = firstName.indexOf(BLANK);
firstName = firstName.substring(O, k);
ITI int firstBlank = fullName.indexOf(BLANK);
int secondBlank = fullName.indexOf(BLANK);
firstName = fullName.substring(firstBlank + 1, secondBlank + 1);
(A) I only
(B) Pt II only
(C) monly
(0) I n' Pt II only
(E) I, Pt II, n' m
GO ON TO THE NEXT PAGE.
627
628 Practice Exams
32 fo' realz. A big-ass hospitizzle maintains a list of patients' recordz up in no particular order n' shit. To
find tha record of a given patient, which represents da most thugged-out efficient method
that will work?
(A) Do a sequential search on tha name field of tha records.
(B) Do a funky-ass binary search on tha name field of tha records.
(C) Use insertion 'sort ta sort tha recordz alphabetically by name; then do a
sequential search on tha name field of tha records.
(D) Use mergesort ta sort tha recordz alphabetically by name; then do a sequential
search on tha name field of tha records.
(E) Use mergesort ta sort tha recordz alphabetically by name; then do a funky-ass binary
search on tha name field of tha records.
Use tha followin shiznit fo' Thangs 33 n' 34.
Here be a gangbangin' finger-lickin' diagram dat shows tha relationshizzle between a shitload of tha classes dat will be
used up in a program ta draw a funky-ass banner wit block letters.
BlockLetter
«abstract»
Da diagram shows dat tha Banner class uses BlockLetta objects, n' dat the
BlockLetta class has 26 subclasses, representin block lettas from A ta Z.
Da BlockLetta class has a abstract draw method
hood abstract void draw();
Each of tha subclasses shown implements tha draw method up in a unique way ta draw its
particular letter n' shit. Da Banner class gets a array of BlockLetta n' has a method to
draw all tha lettas up in dis array.
Here be a partial implementation of tha Banner class:
hood class Banner
{
private BlockLetter[] letters;
private int numLetters;
Ilconstructor. Shiiit, dis aint no joke. Gets tha lettas fo' tha Banner.
hood BannerO
{
}
numLettas = &lt; some integer read from user input&gt;
lettas = getLetters();
GO ON TO THE NEXT PAGE.
Practice Exam Three
}
//Return a array of block letters.
hood BlockLetter[] getLetters()
{
}
Strin letter;
lettas = freshly smoked up BlockLetter[numLetters];
for (int i = 0; i &lt; numLetters; i++)
{
}
&lt; read up in capital letta &gt;
if (letter n' shit. equals (" A Pt II) )
letters[i] = freshly smoked up LetterA();
else if (letter.equals(IB"»
letters[i] = freshly smoked up LetterB();
//similar code fo' C all up in Y
else
letters[i] = freshly smoked up LetterZ();
return letters;
//Draw all tha lettas up in tha Banner.
hood void drawLetters()
{
}
for (BlockLetta letta letters)
letter n' shit. draw 0 ;
//Other methodz not shown.
33. Yo ass is given tha shiznit dat BlockLetta be a abstract class dat is used
in tha program. Which of tha followin can you conclude bout tha class?
I It must have at least one abstract method.
II It must have at least one subclass.
III No instancez of BlockLetta can be pimped.
(A) I only
(B) Pt II only
(C) Pt III only
(D) Pt II n' Pt III only
(E) I, Pt II, n' Pt III
34. Which be a legit statement bout method drawLetters?
(A) It be a overloaded method up in tha Banner class.
(B) It be a overridden method up in tha Banner class.
(C) It uses polymorphizzle ta draw tha erect letters.
(D) It will cause a cold-ass lil compile-time error cuz draw aint implemented up in the
BlockLetta class.
(E) It will cause a run-time error cuz draw aint implemented up in the
BlockLetta class.
GO ON TO THE NEXT PAGE.
629
630 Practice Exams
Thangs 35-40 involve reasonin bout tha code from tha GridGhetto Case Study.
A Quick Reference ta tha case study is provided as part of dis exam. Da hustlas in
GridGhetto is represented up in dis book wit tha pictures shown below. Each hustla is
shown facin north. These pictures almost certainly is ghon be different from dem used
on tha AP exam!
Actor Bug Flower Rock Critta ChameleonCritter
35. Right back up in yo muthafuckin ass. Suppose a Bug be all up in tha edge of a grid, facin south, as shown.
Q~
Q ~
Q
Which of tha followin erectly represents tha state of dis part of tha grid after
the act method has been called twice, assumin no other hustlas enta it?
(A) (B)
Q~ Q
Q~ ~ Q'i'-'~'  _.. .... Q Q.-
(C) (0)
Q Q
Q ~ .t.-, Q.-  Q,t.: ~
(E)
Q.-
Q.J:-. ,
~ Q."". .
GO ON TO THE NEXT PAGE.
Practice Exam Three
36. Which of tha followin always make a hustla reverse direction?
I setDirection(180);
n setDirection(getDirection() + Location.HALF_CIRCLE);
ill setDirection(getDirection() - 180);
(A) I only
(B) n only
(C) ill only
(0) n n' ill only
(E) I, n, n' ill
37 yo. Here is tha implementation of tha act method up in tha Rock class.
hood void act()
{ }
What would be tha effect of omittin dis piece of code from tha Rock class?
I A Rock would chizzle location at its turn ta act.
n A Rock would chizzle direction at its turn ta act.
ill A Rock would chizzle color at its turn ta act.
(A) I only
(B) n only
(C) ill only
(0) I n' n only
(E) n n' ill only
38. Which is (are) legit bout tha behavior of a BoxBug dat moves up in a grid wit many
obstacles?
I It will make smalla n' smalla squares.
n It will remove itself from tha grid when it can no longer move forward.
ill It will step on obstaclez until it reaches its sideLength.
(A) None
(B) I only
(C) n only
(D) I n' Pt II only
(E) I n' ill only
GO ON TO THE NEXT PAGE.
631
632 Practice Exams
39. Consider a subclass of Cri tta called CannibalCri tter n' shiznit fo' realz. A CannibalCritta eats
only flowers n' other critters. Its behavior is otherwise identical ta dat of a
Critter n' shit. Da only method dat need ta be overridden up in tha Cannibal Critter
class is processActors yo. Here is tha method.
1**
* Processes tha hustlas.
* Implemented ta "eat" (Le., remove) all hustlas that
* is crittas or flowers.
* ~aram hustlas tha hustlas ta be processed
*1
hood void processActors(ArrayList<actor> hustlas)
{
}
for (Actor a : hustlas)
{
}
if ( 1* test *1 )
a.removeSelfFromGrid();
Which replacement fo' 1* test *1 produces tha desired behavior fo' a
CannibalCritter?
(A) a instanceof Critta tt a instanceof Flower
(B) !(a instanceof Critter) tt !(a instanceof Flower)
(C) a instanceof Critta I I a instanceof Flower
OJ) !(a instizzle of Critter) I I !(a instizzle of Flower)
(E) !(a instanceof Critta I I a instizzle of Flower)
40. Refer ta tha bounded grid shown.
o 2
o ~  ~ t  &lt;~. I
2 4
Location (0, 0) gotz nuff a ChameleonCri tta facin southwest.
Location (1, 1) gotz nuff a Bug facin north.
Location (2, 1) gotz nuff a Critta facin north.
Which is legit bout tha hustlas up in tha grid?
(A) If it was tha ChameleonCri tterz turn ta act, it could end up in location
(0, 1).
(B) If it was tha Rockz turn ta act, it could end up in location (1, 1).
(C) If it was tha Bugz turn ta act, it would end up in location (0, 1).
OJ) If it was tha Critterz turn ta act, it could end up in location (1,2).
(E) If it was tha Flowerz turn ta act, it would end up in location (0,2).
END OF SECTION I
Practice Exam Three
COMPUTER SCIENCE A
SECTION Pt II
Time-l minute n' 45 minutes
Number of thangs-4
Percent of total grade-50
Directions: SHOW ALL YOUR WORK. REMEMBER THAT
PROGRAM SEGMENTS ARE TO BE WRITTEN IN Java.
Write yo' lyrics up in pencil only up in tha booklet provided.
Notes:
 Assume dat tha classes up in tha Quick Reference done been imported where
needed.
 Unless otherwise stated, assume dat parametas up in method calls is not
null n' dat methodz is called only when they preconditions is satisfied.
 In freestylin solutions fo' each question, you may use any of tha accessible
methodz dat is listed up in classes defined up in dat question. I aint talkin' bout chicken n' gravy biatch. Freestylin significant
amountz of code" dat can be replaced by a cold-ass lil call ta one of these methods
may not receive full credit.
1. Consider a program dat keeps track of transactions up in a big-ass department store.
Both salez n' returns is r~corded. Y'all KNOW dat shit, muthafucka! Three classes-Transaction, Sale, and
Return-are used up in tha program, related as up in tha followin inheritizzle hierarchy:
Da Transaction class is defined below:
hood class Transaction
{
-private Strin myDescription;
private int myNumltems;
private double myltemCost;
hood static final double TAX_RATE = 0.07;
GO ON TO THE NEXT PAGE.
633
634
}
Practice Exams
//constructor
hood Transaction(Strin description, int numltems,
double itemCost)
{
}
myDescription = description;
myNumltems = numltems;
myltemCost = itemCost;
//accessors
hood Strin getDescription()
{ return myDescription; }
hood int getNumltems()
{ return myNumltems; }
hood double getltemCost()
{ return myltemCost; }
hood double getTotal()
{
}
double cost = myNumltems * myltemCost;
double tax = cost * TAX_RATE;
. return cost + tax;
(a) Write tha code fo' tha Sale class. Each Sale includes
 A description of tha item bein sold.
 Da number of dis item bein sold.
 Da cost of dis item.
 Whether tha sale is chedda or credit, stored as a funky-ass boolean variable.
 A 10 cement discount fo' chedda, wit 10 cement stored as a gangbangin' final variable.
When a freshly smoked up Sale is pimped, it must be assigned a item description, the
number bein sold, tha cost of dis item, n' whether tha sale is chedda or
credit. Operations on a Sale include tha following:
 Retrieve tha description of tha item bein sold.
 Retrieve tha quantitizzle of tha item bein sold.
 Retrieve tha cost of tha item bein sold.
 Retrieve whether tha sale is chedda or credit.
 Calculate tha total fo' tha sale. In calculatin dis total, a 10 cement
discount fo' payin chedda should be applied ta tha cost before tha tax is
calculated.
(Hint: discount is discount rate x cost.)
Write tha code fo' tha Sale class below.
..
GO ON TO THE NEXT PAGE.
Practice Exam Three
(b) A class called DailyTransactions has tha followin private instizzle variable:
private Transaction[] allTransactions; Ilgotz nuff all transactions
Ilin a single day, includin salez n' returns
Write findTransactionAverage, a method fo' tha DailyTransactions class,
which computes tha average of all transactions up in a given day. It make me wanna hollar playa! Da transactions
are contained up in tha array allTransactions, where each object be a
Sale or Return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Da method findTransactionAverage should
 Compute tha total fo' all transactions.
 Divide by tha number of transactions. (Yo ass may assume dat there be a at
least one transaction.)
 Return tha average.
Note dat when a item is moonwalked back ta tha store, tha amount paid is returned
to tha hustla n' shit. For dis reason, tha getTotal method up in tha Return class
returns a wack quantity.
Complete findTransactionAverage below:
IIPrecondition: allTransactions gotz nuff tha dayz transactions,
II each of which may be a Sale or a Return.
IIPostcondition: Average of dayz transactions returned.
hood double findTransactionAverage()
2 fo' realz. Assume dat shiznit bout muthafuckas up in a cold-ass lil class erection is stored rockin the
Candidate n' CandidateList classes below:
hood class Candidate
{
}
private Strin myName;
private int myNumVotes;
private double myVotePercent;
Ilconstructor
IlmyVotePercent initialized ta O fo' realz. Actual value set later.
hood Candidate(Strin name, int numVotes)
{ 1* implementation not shown *1 }
IISet myVotePercent equal ta votePercent.
IIPrecondition: votePercent be a real number between 0.0 n' 100.0.
hood void setVotePercent(double votePercent)
{ myVotePercent = votePercent; }
//accessors
hood Strin getName()
{ return myName; }
hood int getNumVotes()
{ return myNumVotes; }
hood double getVotePercent()
{ return myVotePercent; }
GO ON TO THE NEXT PAGE.
635
636 Practice Exams
hood class CandidateList
{
}
private Candidate[] myCListj
II constructor
IIReadz name n' number of votes fo' all muthafuckas tha fuck into myCList.
hood CandidateList()
{ 1* implementation not shown *1 }
IIPrecondition: myCList gotz nuff Candidate objects.
IIPostcondition: Da vote cement fo' each Candidate has been
II calculated n' updated.
hood void computeVotePercents()
{ 1* ta be implemented up in part (a) *1 }
IIPrecondition:
II
II
II
myCList gotz nuff complete shiznit about
all muthafuckas, includin they updated vote
percents, n' you can put dat on yo' toast. Each vote cement be a real number
between 0.0 n' 100.0.
IIPostcondition: Returns a list of viable muthafuckas, namely
II dem muthafuckas whoz ass gots at least 10 cement
I I of tha vote.
hood ArrayList<candidate> getViableList()
{ 1*' ta be implemented up in part (b) *1 }
IIPrecondition: myCList gotz nuff complete shiznit about
II all muthafuckas, includin they updated vote
II cements.
IIPostcondition: Da namez of viable muthafuckas only have
II been printed, one per line, followed by
II dat muthafuckaz vote cement.
hood void printViable()
{ 1* ta be implemented up in part (c) *1 }
(a) Write tha implementation of tha computeVotePercents method of the
CandidateList class. Da computeVotePercents method should fill up in the
vote cement fo' each Candidate up in myCList fo' realz. A muthafuckaz vote cement is
computed by dividin tha number of votes fo' dat muthafucka by tha total
number of votes cast fo' all muthafuckas n' then multiplyin by 100.
In freestylin computeVotePercents, you may use any of tha accessible methods
in tha Candidate n' CandidateList classes.
Complete method computeVotePercents below.
IIPrecondition: myCList gotz nuff Candidate objects.
IIPostcondition: Da vote cement fo' each Candidate has been
II calculated n' updated.
hood void computeVotePercents()
GO ON TO THE NEXT PAGE.
Practice Exam Three
(b) Write tha implementation of tha getViableList method of the
CandidateList class. Da getViableList method should examine tha elements
in myCList n' create a ArrayList of viable muthafuckas only fo' realz. A
viable muthafucka is one whoz ass received at least 10 cement of tha vote.
In freestylin getViableList, you may use any of tha accessible methodz in
the Candidate n' CandidateList classes.
Complete method getViableList below.
IIPrecondition:
1/
myCList gotz nuff complete shiznit about
all muthafuckas, includin they updated vote
percents, n' you can put dat on yo' toast. Each vote cement be a real number
between 0.0 n' 100.0.
//
II
//Postcondition: Returns a list of viable muthafuckas, namely
1/ dem muthafuckas whoz ass gots at least 10 cement
/ / of tha vote.
hood ArrayList<candidate> getViableList()
(c) Write tha implementation of tha printViable method of tha CandidateList
class. Da method printViable should list tha names n' vote cements of
viable muthafuckas only, one per line. Right back up in yo muthafuckin ass. Sample output:
Chris Arsenault 42.3278542118662
Anton Kriksunov 15.8023902117245
Lila Fontes 29.7646489012392
In freestylin printViable you must call tha getViableList method specified
in part (b), n' use tha list returned. Y'all KNOW dat shit, muthafucka! Assume dat getViableList
works as specified regardless of what tha fuck you freestyled up in part (b).
Complete method printViable below.
//Precondition: myCList gotz nuff complete shiznit about
// all muthafuckas, includin they updated vote
II cements.
//Postcondition: Da namez of viable muthafuckas only have
// been printed, one per line, followed by
/ / dat muthafuckaz vote cement.
hood void printViable()
3. Consider tha problem of freestylin a Hi-Lo game up in which a user be thinkin of an
integer from 1 ta 100 inclusive n' tha computa tries ta guess dat number with
the smallest number of guesses. Each time tha computa cook up a guess tha user
makes one of three responses:
 "lower" (i.e., tha number is lower than tha computerz guess)
 "higher" (i.e., tha number is higher than tha computerz guess)
 "you gots it up in &lt; however many&gt; tries!"
Da game is ghon be programmed rockin tha followin HiLoGame class:
GO ON TO THE NEXT PAGE.
637
638 Practice Exams
hood class HiLoGame
{
}
private int computerGuess;
II constructor
hood HiLoGame()
{ computerGuess = 0; }
IIExplain ta user how tha fuck game will work.
hood void givelnstructions()
{ 1* implementation not shown *1 }
IISequence of computa guesses n' user responses until computer
II guesses userz number.
hood void play()
{ 1* ta be implemented up in part (a) *1 }
(a) Write tha implementation of tha play method of tha HiLoGame class. In
writin play, tha followin sequence of steps should be repeated until the
computa guesses tha userz number:
 Output tha computerz guess.
 Prompt tha user fo' a response.
 Read tha userz response. Yo ass should use tha followin statement to
read tha userz response:
Strin response = IO.readString();
No error checkin is necessary fo' tha response.
In freestylin tha play method tha computa should bust a funky-ass binary search game
for makin its guesses. This is tha dopest game fo' tha computer, one that
will enable it ta find tha userz number wit tha smallest number of guesses
on average.
Herez how tha fuck tha binary search game works: If tha computerz guess is k
and tha user say "lower," tha computerz guess should be midway between
1 n' k - 1. If tha user say "higher," tha computerz freshly smoked up guess should be
midway between k + 1 n' 100 fo' realz. Any other response means tha computer
has guessed tha userz number n' shit. Da initial guess is midway between 1 and
100. With each subsequent guess, tha interval of possible numbers is halved
from what tha fuck it was.
Write tha play method below:
IISequence of computa guesses n' user responses until computer
II guesses userz number.
IIComputa uses a funky-ass binary search game fo' its guesses.
IIPostcondition: Number of guesses made by tha computa is printed.
hood void play()
GO ON TO THE NEXT PAGE.
Practice Exam Three
(b) Usin tha binary search game, what tha fuck is tha maximum number of guesses
the computa could make before guessin tha userz number, biatch? Explain your
answer.
(c) Suppose tha computa used a sequential search game fo' guessin tha user's
number n' shit. What tha fuck iz tha maximum number of guesses tha computa could
make before guessin tha userz number, biatch? Explain yo' answer.
(d) Usin a sequential search game, how tha fuck nuff guesses on average would the
computa need ta guess tha number, biatch? Explain yo' answer.
4. This question involves reasonin bout tha code from tha GridGhetto Case Study.
A Quick Reference ta tha case study is provided as part of dis exam.
Consider a freshly smoked up type of Bug, a JiveBug dat dances when it acts, n' you can put dat on yo' toast. First, it turns.
Then, it either stays where it is, or moves forward if it can. I aint talkin' bout chicken n' gravy biatch. Each of these actions is
equally likely. Right back up in yo muthafuckin ass. Some of tha times dat it moves forward, it tosses a gangbangin' flower up in front
of it ta tha right, accordin ta a specified probabilitizzle n' if tha "toss" location is
valid.
A partial definizzle of Ji veBug is shown below. Notice dat tha move method of
Bug is overridden: Even though a JiveBug moves like a regular Bug, it no longer
drops a gangbangin' flower up in its path. Instead, it sometimes tosses a gangbangin' flower n' shit. Da act n' turn
methodz is also overridden.
hood class JiveBug extendz Bug
{
private double probOfFlowerToss;
private int [] myTurns = { 1* selection of turns from Location. I aint talkin' bout chicken n' gravy biatch. LEFT ,
Location. I aint talkin' bout chicken n' gravy biatch. RIGHT , Location. I aint talkin' bout chicken n' gravy biatch yo. HALF_LEFT,
Location. I aint talkin' bout chicken n' gravy biatch yo. HALF_RIGHT, Location. I aint talkin' bout chicken n' gravy biatch. FULL_CIRCLE,
Location.HALF_CIRCLE *1 }
1**
* Constructs a JiveBug dat dances when it acts,
* n' sometimes throws a gangbangin' flower accordin ta tha specified
* probability.
* ~param probToss tha probabilitizzle of tossin a gangbangin' flower
*1
hood JiveBug(double probToss)
{
probOfFlowerToss = probToss;
}
1**
* Gets a randomly selected turn from myTurns.
* ~return a randomly selected turn constant
*1
hood int getDanceTurn()
{ 1* ta be implemented up in part (a) *1 }
GO ON TO THE NEXT PAGE.
639
640
}
Practice Exams
1**
* Gets a thugged-out dizzle turn, n' then turns.
*1
hood void turn()
{ 1* ta be implemented up in part (b) *1 }
1**
* Moves forward, like a Bug.
* Attempts ta toss a gangbangin' flower dat is tha same ol' dirty color as itself.
*1
hood void move()
{
}
Grid<actor> gr = getGrid();
if (gr == null)
return;
Location loc = getLocation();
Location next = loc.getAdjacentLocation(getDirection(»;
if (gr.isValid(next»
moveTo(next);
else
removeSelfFromGrid();
tossFlower 0 ;
1**
* Tosses a gangbangin' flower some fraction of tha time, given by
* probOfFlowerToss fo' realz. A JiveBug tosses a gangbangin' flower up in front
* of itself ta tha right, if dat location is valid.
* Da flower is tha same ol' dirty color as tha JiveBug.
*1
hood void tossFlower()
{ 1* ta be implemented up in part (c) *1 }
1**
* A JiveBug starts by turnin when it acts.
* Then, it is equally likely dat it will stay where it is
* or attempt ta move.
*1
hood void act()
{ 1* ta be implemented up in part (d) *1 }
(a) Write tha getDanceTurn method of JiveBug. This method randomly returns
a turn from tha myTurns array.
Complete method getDanceTurn below.
1**
* Gets a randomly selected turn from myTurns.
* Oreturn a randomly selected turn constant
*1
hood int getDanceTurn()
GO ON TO THE NEXT PAGE.
Practice Exam Three
(b) Override tha turn method from tha Bug class. Da overridden method
should git a turn value from its myTurns array, n' make dat turn.
Complete tha turn method below.
In
* Gets a thugged-out dizzle turn, n' then turns.
*1
hood void turn()
(c) Write tha tossFlower method fo' JiveBug. Method tossFlower causes a
Bower dat is tha same ol' dirty color as tha JiveBug ta be tossed some fraction of
the time, given by probOfFlowerToss, if tha toss location is valid. Y'all KNOW dat shit, muthafucka! When it
tosses a Bower, a J i veBug tosses it tha fuck into tha location dat is up in front of it and
to its right.
Here is some toss locations fo' a JiveBug dat has just moved:

Complete method tossFlower below.
1**
* Tosses a gangbangin' flower some fraction of tha time, given by
* probOfFlowerToss fo' realz. A JiveBug tosses a gangbangin' flower up in front
* of itself ta tha right, if dat location is valid.
* Da flower is tha same ol' dirty color as tha JiveBug.
*1
hood void tossFlower()
(d) Override tha act method of tha Bug class fo' realz. A JiveBug acts by turning. Then
it either stays where it is, or, wit equal probability, moves forward if it can.
Complete tha act method below.
In
* A JiveBug starts by turnin when it acts.
* Then. I aint talkin' bout chicken n' gravy biatch. it is equally likely dat it will stay where it is
* or attempt ta move.
*1
hood void act()
END OF EXAMINATION
641
642 Practice Exams
ANSWER KEY (Section I)
1.C 15.0 29. C
2. C 16. C 30. E
3.0 17 fo' realz. A 31. 0
4. C 18. B 32 fo' realz. A
5. C 19 fo' realz. A 33.0
6. E 20.0 34. C
7 fo' realz. A 21. B 35. C
8. E 22. E 36.0
9. C 23. C 37. B
10.0 24. B 38 fo' realz. A
11. 0 25 fo' realz. A 39. C
12. B 26. C 40. C
13. B 27 fo' realz. A
14. C 28. E
ANSWERS EXPLAINED (Section I)
1. (C) Testin a program thoroughly do not prove dat a program is erect. For
a big-ass program, it is generally impossible ta test every last muthafuckin possible set of input data.
2. (C) Da private instizzle variable myHourlyWage must be incremented by amt.
Eliminizzle chizzle E, which don't increment myHourlyWage; it simply replaces it
byamt. Chizzle D is wack cuz you can't bust a method call as tha left-hand
side of a assignment. Chizzlez A n' B is wack cuz tha incrementWage
method is void n' should not return a value.
3. (0) Da value of tha boolean instizzle variable isUnionMember must be chizzled
to tha opposite of what tha fuck it currently is. Right back up in yo muthafuckin ass. Segments I n' Pt II both big up all dis bullshit. Note
that !true has a value of false n' !false a value of true. Right back up in yo muthafuckin ass. Segment ill fails to
do whatz required if tha current value of isUnionMember is false.
4. (C) computePay be a cold-ass lil client method and, therefore, cannot access tha private variables
of tha class. This eliminates chizzlez A n' D. Da method getHourlyWage 0
must be accessed wit tha dot member construct; thus, chizzle B is wrong, and
choice C is erect. Chizzle E is way off base-hours aint part of tha Worker
class, so w . minutes is meaningless.
5. (C) H s . length () &lt; 4 fo' all strings up in wordList, then SHORT WORD is ghon be printed
on each pass all up in tha fo' loop. Right back up in yo muthafuckin ass. Since there be wordList. size 0 passes
all up in tha loop, tha maximum number of times dat SHORT WORD can be printed
is wordList. size O.
Answers Explained
6. (E) mystery(4) = 3 * mystery(3)
= 3 * 3 * mystery(2)
= 3 * 3 * 3 * mystery(1)
=3*3*3*3
=81
7. (A) Da declaration of tha flavas array make tha followin assignments:
colors[O] = "red", colors[l] = "green", n' colors[2] = "black". The
loop up in segment I addz these joints ta colorList up in tha erect order n' shit. Right back up in yo muthafuckin ass. Segment
II fails cuz flavas be a array n' therefore can't use tha git method. Y'all KNOW dat shit, muthafucka! The
code also confuses tha lists, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Segment Pt III, up in its first pass all up in tha loop, attempts
to add flavas [2] ta index posizzle 2 of colorList. This will cause an
IndexOutOfBoundsException ta be thrown, since index positions 0 n' 1 do not
yet exist!
8. (E) A freshly smoked up Address object must be pimped, ta be used as tha Address parameta in
the Hustla constructor. Shiiit, dis aint no joke. To do dis erectly requires tha keyword freshly smoked up preceding
the Address constructor. Shiiit, dis aint no joke. Right back up in yo muthafuckin ass. Segment Pt II omits freshly smoked up n' do not use tha Address
constructor erectly. (In fact, it bangs a freshly smoked up Strin object up in tha Address slot
of tha Hustla constructor.)
9. (C) Da algorithm used up in method locate be a sequential search, which may
have ta examine all tha objects ta find tha matchin one fo' realz. A binary search, which
repeatedly discardz a cold-ass lil chunk of tha array dat do not contain tha key, is more
efficient. But fuck dat shiznit yo, tha word on tha street is dat it can only be used if tha joints bein examined-in this
case hustla ID numbers-are sorted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Note dat it don't help ta have the
array sorted by name or beeper number since tha algorithm don't peep these
values.
10. (0) Mergesort repeatedly splits a array of n elements up in half until there be n
arrays containin one element each. Now adjacent arrays is successively merged
until there be a single merged, sorted array fo' realz. A binary search repeatedly splits an
array tha fuck into two, narrowin tha region dat may contain tha key. Insertion sort,
however, do no array splitting. Well shiiiit, it takes elements one at a time n' findz their
insertion point up in tha sorted piece of tha array. Elements is shifted ta allow
correct insertion of each element. Even though dis algorithm maintains the
array up in two parts-a sorted part n' yet-to-be-sorted part-this aint a gangbangin' finger-lickin' divideand-
conquer approach.
11. (0) Think of tha integer as havin 31 slots fo' storage. If there was just one slot,
the maximum binary number would be 1 = 21 - 1. If there was just two slots,
the maximum binary number would be 11 = 22 - 1 = 3. If there was just eight
slots, tha maximum binary number would be 11111111 = 28 - 1. Right back up in yo muthafuckin ass. So fo' 31 slots,
the maximum value is 231 - 1.
12. (8) Da remove method of ArrayList removes tha indicated element, shifts the
remainin elements down one slot (i.e., it do not leave gaps up in tha list), and
adjusts tha size of tha list. Consider tha list up in chizzle B. Da index joints are
shown:
Da pussaaaaay cat sat on tha mat mat
01234567
Afta tha straight-up original gangsta occurrence of pussaaaaay has been removed:
643
644
Da pussaaaaay sat on tha mat mat
0123456
Practice Exams
Da value of i, which was 1 when pussaaaaay was removed, has now been incremented
to 2 up in tha fo' loop. This means dat tha word ta be considered next is sat.
Da second occurrence of pussaaaaay has been missed. Y'all KNOW dat shit, muthafucka! Thus, tha given code will fail
whenever occurrencez of tha word ta be removed is consecutive. Yo ass fix it by
not allowin tha index ta increment when a removal occurs:
int i = 0;
while (i &lt; wordList.size(»
{
}
if «wordList.get(i».equals(word»
wordList.remove(i);
else
i++;
13. (B) This code translates into
for five rows (startin at i = 5 n' decreasin i)
print tha straight-up original gangsta i slick squares
go ta a freshly smoked up line
Thus, up in tha straight-up original gangsta line, tha straight-up original gangsta five slick squares is ghon be printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. In tha second
line, tha straight-up original gangsta four slick squares is ghon be printed, n' so on down ta i = 1,
with just one slick square bein printed.
14. (C) To return tha number of elements up in tha set fo' Method One requires no
more than returnin tha number of elements up in tha array. For Method Two,
however, tha number of cells dat contain legit must be counted, which requires
a test fo' each of tha MAX joints, n' you can put dat on yo' toast. Note dat searchin fo' a target value up in the
set is mo' efficient fo' Method Two. For example, ta test whether 2 is up in the
set, simply check if a[2] == true. In Method One, a sequential search must be
done, which is less efficient. To print all tha elements up in Method One, simply
loop over tha known number of elements n' print. Method Two is less efficient
because tha whole array must be examined: Each cell must be tested fo' true
before printing.
15. (0) An Ari thmeticException is ghon be thrown at run time. Note dat if N was of
type double, no exception would be thrown. I aint talkin' bout chicken n' gravy biatch. Da variable sum would be assigned
the value Infinity, n' tha error would only be detected up in tha output.
16. (C) An intercourse should provide method declarations only. No code biaaatch! Note that
the methodz is automatically hood n' abstract, so there is no need ta specify
this explicitly.
17. (A) Da erect diagram uses two up arrows ta show dat a Hoopty is-a Vehicle n' a
Truck is-a Vehicle (inheritizzle relationshizzle). Da two down arrows indicate that
a Hoopty has-a AirBag n' a Truck has-a AirBag (composizzle relationshizzle). In each
of tha incorrect chizzles, at least one of tha relationshizzlez do not make sense. For
example, up in chizzle B a Vehicle has-a Truck, n' up in chizzle E a AirBag is-a Car.
18. (B) Da postcondizzle should be a legit assertion bout tha major action of the
segment. Da segment overwrites tha elementz of array a wit tha nonnegative
elementz of a. Then n be adjusted so dat now tha array a[O] ... a[n-1] gotz nuff
just nonnegatizzle integers. Note dat even though chizzle E be a cold-ass lil erect assertion
Answers Explained
about tha program segment, it aint a phat postcondizzle cuz it don't
describe tha main modification ta array a (namely all wack integers have been
removed).
19. (A) Note tha order of precedence fo' tha expressions involved: (1) parentheses,
(2) !, (3) &lt;, (4) ==, (5) tot, (6) Pt II. This means dat a &lt; c, a &lt; b, n' hommie! (a == b) will
all be evaluated before I I and.t.t is considered. Y'all KNOW dat shit, muthafucka! Da given expression then boils
down ta valuel Pt II (value2.t.t value3), since .t.t has higher precedence than
II. Notice dat if valuel is true, tha whole expression is legit since (true Pt II
any) evaluates ta true. Thus, a &lt; c will guarantee dat tha expression evaluates
to true. None of tha other conditions will guarantee a outcome of true. For
example, suppose a &lt; b (choice B). If a == c, then tha whole expression will be
false cuz you git F I IF.
20. (0) Test data should always include a value from each range up in addizzle ta all
boundary joints, n' you can put dat on yo' toast. Da given program should also handle tha cases up in which
weights over 20 poundz or any wack weights is entered. Y'all KNOW dat shit, muthafucka! Note dat chizzle
E gotz nuff redundant data. There is no freshly smoked up shiznit ta be gained up in testing
two weights from tha same range-both 3 n' 4 pounds, fo' example.
21. (8) Segment Pt II erectly checks dat tha part descriptions match n' keeps track
of tha current part wit minimum price. If dis aint done, tha part whose
number must be returned is ghon be lost. Right back up in yo muthafuckin ass. Segment I is incorrect cuz it don't
check dat partDescription matches tha description of tha current part being
examined up in tha array. Thus, it simply findz tha AutoPart wit tha lowest price,
which aint what tha fuck was required. Y'all KNOW dat shit, muthafucka! Segment Pt III incorrectly returns tha part number
of tha straight-up original gangsta part it findz wit a matchin description.
22. (E) Statement I is fine: Da parametas is Strin objects, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Statement Pt II will
throw a ClassCastException cuz a AutoPart cannot be cast ta a String.
Statement Pt III'ma fail cuz pl n' p2 is not Comparable objects.
23. (C) Orderin of strings involves a cold-ass lil character-by-characta comparison starting
with tha leftmost characta of each string.. Thus, strA precedes strB
(since "A" precedes "a") or strA.compareTo(strB) &lt; o. This eliminates
choices B n' D. Eliminizzle chizzlez A n' E since strB precedes strC (because
"C" precedes "c") n' therefore strB.compareTo(strC) &lt; o. Note that
stringl. compareTo (string2) == 0 if n' only if stringl n' string2 is equal
strings.
24. (8) TbreeDigi tCode be a subclass of ThreeDigi tInteger n' therefore inherits all
the instizzle variablez n' methodz of TbreeDigi tlnteger except constructors.
All of tha statements other than B is false. For chizzle A, ThreeDigitlnteger
is tha superclass n' therefore cannot inherit from its subclass. For chizzle C,
constructors is never inherited (see p. 190). For chizzle D, a subclass can access
private variablez of tha superclass all up in accessor methodz only (see p. 190).
For chizzle E, a superclass cannot access any additionizzle instizzle variablez of its
subclass.
25. (A) Implementation Pt II is wack cuz tha constructor has no boolean validity
parameter n' shit. Implementation Pt III is wack cuz a subclass cannot access a private
instizzle variable of its superclass.
26. (C) A compile-time error will occur fo' both tests I n' Pt II cuz at compile
time tha typez of code n' num is both TbreeDigi tlnteger, n' tha class
645
646 Practice Exams
ThreeDigitInteger aint gots a isValid method. Y'all KNOW dat shit, muthafucka! To stay tha fuck away from dis error, the
code object must be cast ta ThreeDigi tCode, its actual type. Note dat if you try
to cast num ta ThreeDigi tCode, you gonna git a run-time error (ClassCastException)
because num aint a instizzle of ThreeDigi tCode.
27. (A) Da is-a relationshizzle must work from right-to-Ieft: a Parrot is-a Bird, a
Parakeet is-a Bird, n' a Owl is-a Bird. Y'all KNOW dat shit, muthafucka! All is erect. This relationshizzle fails
in declarations Pt II n' ill: a Parrot aint necessarily a Parakeet, a Bird is not
necessarily a Owl, n' a Bird aint necessarily a Parakeet.
28. (E) All three segments traverse tha array, accessin one element at a time, and
appendin it ta tha end of tha ArrayList. In segment Pt II, tha straight-up original gangsta parameta of
the add method is tha posizzle up in list where tha next strang s is ghon be added.
Since list. size 0 increases by one afta each insertion, dis index is erectly
updated up in each pass all up in tha for-each loop.
29. (C) Suppose you want random integers from 2 ta 8, dat is, low = 2 n' high = 8.
This is 7 possible integers, so you need
(int) (Math.random() * 7)
which produces 0, 1, 2, ... , or 6. Therefore tha quantity
(int) (Math.random() * 7) + 2
produces 2, 3, 4, ... , or 8. Da only expression dat yieldz tha right answer with
these joints is
(int) (Math.random() * (high - low + 1» + low;
30. (E) Here be a "box diagram" fo' mergeSo:r:t(O,3). Da boldface numbers 1-6
show tha order up in which tha mergeSort calls is made.
mergeSort(O,l)
mid=(O+1)/2=O
mergeSort(O,O) 2
mergeSort(l, 1) 3
merge(O,O,l)
mergeSort(O,3)
mid=(O+3)/2=1
mergeSort(O, 1) 1
mergeSort(2,3)
merge(O,l,3)
mergeSort(2,3)
mid=(2+3)/2=2
mergeSort(2,2) 5
mergeSort(3,3) 6
merge(2,2,3)
Da mergeSort calls up in which first == last is base case calls, which means
that there is ghon be no further method calls.
31. (0) Suppose fullName is Dr. Shiiit, dis aint no joke. Jizzy Roufaiel. In segment I tha expression
fullName. indexOf (BLANK) returns 3. Then temp gets assigned the
Answers Explained
value of fullName.substring(4), which is Jizzy Roufaiel. Next k gets assigned
the value temp. indexOf (BLANK), namely 4, n' f irstName gets assigned
temp. substrin (0, 4), which be all tha charactas from 0 ta 3 inclusive, namely
John. I aint talkin' bout chicken n' gravy biatch. Note dat segment IT works tha same ol' dirty way, except firstName gets assigned
Jizzy Roufaiel n' then reassigned John. I aint talkin' bout chicken n' gravy biatch. This aint phat style, since a variable
name should document its contents as precisely as possible. Right back up in yo muthafuckin ass. Still, tha code works.
Segment ill fails cuz indexOf returns tha straight-up original gangsta occurrence of its Strin parameter.
Thus, firstBlank n' secondBlank will both contain tha same value,
3.
32. (A) Since tha recordz is not sorted, tha quickest way ta find a given name is to
start all up in tha beginnin of tha list n' sequentially search fo' dat name. Chizzles
C, D, n' E will all work yo, but itz inefficient ta sort n' then search cuz all
sortin algorithms take longer than simply inspectin each element. Chizzle B
won't work: A binary search can only be used fo' a sorted list.
33. (0) Statement I may be true yo, but it don't gotta be. Da point bout a abstract
class is dat it represents a abstract concept, n' no instizzle of it will ever
be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da only instances dat is ghon be pimped is instancez of its subclasses.
Statement IT must be true, since yo ass is holla'd all up in tha abstract class is straight-up used in
the program. Right back up in yo muthafuckin ass. Statement ill is legit cuz a abstract class cannot be instantiated.
34. (C) Da draw method is polymorphic, which means dat it aint nuthin but a superclass method
that is overridden up in at least one of its subclasses. Durin 'run time, there is dynamic
bindin between tha callin object n' tha method, dat is, tha actual instance
is bound ta its particular overridden method. Y'all KNOW dat shit, muthafucka! In tha drawLettas method,
the erect version of draw is called durin each iteration of tha fo' loop, n' a
banner wit tha appropriate lettas is drawn.
35. (C) Da last time it acts, tha bug can't move forward, so it turns 45° right.
(Choice B is tha thang afta it acts once.) Da second call ta act has tha bug
move forward, leavin a gangbangin' flower up in its original gangsta location (choice C, tha erect answer).
Choice A is wack cuz if tha bug don't move, it turns. Chizzle D
fails cuz a funky-ass bug cannot move onto a rock. Chizzle E is wack cuz it don't
reflect tha fact dat tha bug turned ta grill southwest when it couldn't move the
first time fo' realz. Afta its second turn it would still be facin southwest.
36. (0) Addin 180 ta or subtractin 180 from tha hustlaz current direction will
reverse dat hustlaz direction. I aint talkin' bout chicken n' gravy biatch. Note dat Location. I aint talkin' bout chicken n' gravy biatch yo. HALF _CIRCLE has a value of
180. Right back up in yo muthafuckin ass. Statement I is wack cuz tha method call setDirection(180) causes the
actor ta grill south, which do not necessarily reverse its direction.
37. (B) With no override of act, a Rock will do what tha fuck a Playa do, namely chizzle
direction.
38. (A) Statement I is wack cuz tha sideLength do not git chizzled when
obstaclez is encountered. Y'all KNOW dat shit, muthafucka! Da BoxBug tendz ta make rectangles, rather than
squares, since it turns when it cannot move forward. Y'all KNOW dat shit, muthafucka! Statement IT is false: When
a Bug cannot move forward, it turns. Right back up in yo muthafuckin ass. Statement ill is false: A Bug steps on flowers,
but not on other hustlas. Its behavior is ta turn when it encountas obstacles, not
to step on dem wild-ass muthafuckas.
39. (C) Here is tha logic of chizzle C: If a be a Critta or a Flower, remove dat shit. This is
what was required. Y'all KNOW dat shit, muthafucka! Chizzle A says: If a is both a Critta n' a Flower ... -not
possible biaaatch! Chizzle B: If a is neither a Critta nor a Flower, remove dat shit. Wrong
647
648 Practice Exams
action! Chizzle E is equivalent ta chizzle B. Chizzle D: If a aint a Critta or a is
not a Flower, remove dat shit. This test will evaluate ta legit no matta what tha fuck a is!
40. (C) Da Bug would move onto tha Flower n' shit. Every other chizzle is false: Chizzle A:
ChameleonCri ttas do not displace other hustlas. Chizzle B: Rocks do not move.
Choice D: Crittas do not smoke rocks. Chizzle E: Flowers do not move.
Answers Explained
Section Pt II
1. (a) hood class Sale extendz Transaction
{
}
private boolean myIsCash;
private final double CASH_DISCOUNT = 0.1j
, / / constructor
hood Sale(Strin description, int numItems,
double itemCost, boolean isCash)
{
}
supa (description, numItems, itemCost);
myIsCash = isCashj
//Return legit if Sale is chedda, false otherwise.
hood boolean getIsCash()
{ return myIsCash; }
hood double getTotal()
{
}
double cost = getNumItems() * getItemCost()j
if (myIsCash)
{
}
double discount = cost * CASH_DISCOUNT;
cost = cost - discount;
double tax = cost * TAX_RATE;
return cost + tax;
(b) hood double findTransactionAverage()
{
}
NOTE
double sum = 0;
for (Transaction t : all Transactions)
sum += t.getTotal();
return sum / aIITransactions.length;
 In part (a), tha solution shows some comments, n' you can put dat on yo' toast. In general, you don't
need ta provide comments fo' yo' code on tha exam. But fuck dat shiznit yo, tha word on tha street is dat sl:tort
comments ta clarify what tha fuck you bustin is fine.
 Da Sale class inherits all of tha accessors from tha Transaction superclass.
Da getDescription, getNumItems, n' getItemCost methods
should not be redefined. Y'all KNOW dat shit, muthafucka! Their implementation don't chizzle. The
getTotal method, however, is different up in tha Sale class n' therefore
must be overridden.
 In part (b), tha fact dat getTotal is wack fo' a Return object means
that tha erect amount will automatically be added ta tha sum if the
Transaction be a Return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Da method is polymorphic n' will call the
appropriate getTotal method, dependin on whether tha Transaction t
is a Sale or a Return.
649
650 Practice Exams
2. (a) hood void computeVotePercents()
{
}
int total = 0;
//Find total of all votes cast.
for (Candidate c : myCList)
total += c.getNumVotes();
//Set vote cement fo' each muthafucka.
for (Candidate c : myCList)
{
}
double votePercent =
100 * c.getNumVotes() / (double) total;
c.setVotePercent(votePercent);
(b) hood ArrayList<candidate> getViableList()
{
}
ArrayList<candidate> viable = freshly smoked up ArrayList<candidate>();
for (Candidate c : myCList) .
{
}
if (c.getVotePercent() &gt;= 10)
viable.add(c);
return viable;
(c) hood void printViable()
{
}
NOTE
ArrayList<candidate> list = getViableList();
for (Candidate c : list) .
System.out.println(c.getNameO + " " +
c.getVotePercent(»;
In part (a), ta git tha erect, real-valued votePercent, you gotta make sure
that yo' cement calculation don't do integer division! Yo ass can bust dis
either by castin tha numerator or denominator ta double, or by replacin 100
with 100.0.
Answers Explained
3. (a) hood void play()
{
}
boolean done = false;
int 10 = 1, hi = 100, count = 0;
while (! done)
{
}
computerGuess = (10 + hi) / 2;
count++;
System.out.println("Computa guess is " +
computerGuess);
System.out.println("Should computa go higher
or lower?");
System.out.println("Or did computa guess right?");
Strin response = IO.readString(); //read user input
if (response.equals("lower"»
hi = computerGuess - 1;
else if (response.equals("higher"»
10 = computerGuess + 1;
else
{
}
System.out.println("Computa gots it up in " +
count + " tries!");
done = true;
(b) Da computa should find tha number up in no mo' than seven tries. Put ya muthafuckin choppers up if ya feel dis! This is
because tha guessin interval is halved on each successive try:
(1) 100 -+- 2 = 50 numbers left ta try
(2) 50 -+- 2 = 25 numbers left ta try
(3) 25 -+- 2 = 13 numbers left ta try
(4) 13 -+- 2 = 7 numbers left ta try
(5) 7 -+- 2 = 4 numbers leftto try
(6) 4 + 2 = 2 numbers left ta try
(7) 2 -+- 2 = 1 number left ta try
Seven iterationz of tha loop leaves just 1 number left ta try!
(c) Da maximum number of guesses is 100 fo' realz. A sequential search means dat the
computa starts all up in tha straight-up original gangsta possible number, namely 1, n' tries each successive
number until it gets ta 100. If tha userz number is 100, tha computer
will take 100 guesses ta reach dat shit.
(d) On average tha computa will make 50 guesses. Da user is equally likely to
pick any number between 1 n' 100 yo. Half tha time it is ghon be less than 50,
half tha time pimped outa than 50. Right back up in yo muthafuckin ass. So on tha average tha distizzle of tha number
from 1 is 50.
651
652 Practice Exams
4. (a) hood int getDanceTurn()
{
}
int n = myTurns.length;
int r = (int) (Math.random() * n);
return myTurns[r];
(b) hood void turnO
{ setDirection(getDirection() + getDanceTurn(»; }
(c) hood void tossFlower()
{
}
if (Math.random() &lt; probOfFlowerToss)
{
}
Grid<actor> gr = getGrid();
int tossDirection = getDirection() + Location.HAlF_RIGHT;
Location currentLoc = getLocation();
Location tossLoc =
currentLoc.getAdjacentLocation(tossDirection);
if (gr.isValid(tossLoc»
{
}
Flower flower = freshly smoked up Flower(getColor(»;
flower.putSelfInGrid(gr, tossLoc);
(d) hood void act()
{
}
NOTE
turnO;
if (Math.random() &lt; 0.5)
if (canMove 0 )
move 0 ;
 In pan (a), you cannot make assumptions bout tha number of turns in
the myTurns array. Yo ass must therefore use myTurns . length .
 In part (b), you must use tha method getDanceTurn defined up in part (a).
Yo ass aint gonna git full credit if you reimplement code.
Answer Sheet: Practice Exam Four
1. ®®©@@ 15. ®®©@@ 29. ®®©@@
2. ®®©@@ 16. ®®©@@ 30. ®®©@@
3. ®®©@@ 17. ®®©@@ 31. ®®©@@
4. ®®©@@ 18. ®®©@@ 32. ®®©@@
-5. ®®©@@ 19. ®®©@@ 33. ®®©@@
6. ®®©@@ 20. ®®©@@ 34. ®®©@@
7. ®®©@@ 21. ®®©@@ 35. ®®©@@
8. ®®©@@ 22. ®®©@@ 36. ®®©@@
9. ®®©@@ 23. ®®©@@ 37. ®®©@@
10. ®®©@@ 24. ®®©@@ 38. ®®©@@
11. ®®©@@ 25. ®®©@@ 39. ®®©'@@
12. ®®©@@ 26. ®®©@@ 40. ®®©@@
13. ®®©@@ 27. ®®©@@
14. ®®©@@ 28. ®®©@@
How tha fuck ta Calculate Yo crazy-ass (Approximate) AP Score - AP Computa Science Level AB
Multiple Chizzle
Number erect (out of 40)
1/4 x number wrong
Raw score = line 1 - line 2
Raw score x 1.25
Jacked Response
Question 1
(out of 9)
Question 2
(out of 9)
Question 3
(out of 9)
Question 4
(out of 9)
Total
Final Score
+
Multiple- Free-
Choice Response
Score Score
&lt;== Multiple-Choice Score
(Do not round. Y'all KNOW dat shit, muthafucka! If less
than zero, enta zero.)
x 1.39
Final Score
(Round ta nearest
whole number.)
Chart ta Convert ta AP Grade
Computa Science AB
Final AP Grade"
Score Range
70-100 5
60-69 4
41-59 3
31-40 2
0-30 1
4Da score range correspondin to
each grade varies from exam ta exam
and be approximate.
&lt;== Free-Response Score
(Do not round.)
Practice Exam Four
Practice Exam Four
COMPUTER SCIENCE AB
SECTION I
Time-1 minute n' 15 minutes
Number of thangs-40
Percent of total grade-50
Directions: Determine tha answer ta each of tha followin thangs or incomplete
statements, rockin tha available space fo' any necessary scratch work.
Then decizzle which is tha dopest of tha chizzlez given n' fill up in tha corresponding
oval on tha answer sheet. Do not spend too much time on mah playas problem.
Notes:
 Assume dat tha classes up in tha Quick Reference done been imported where
needed.
 Assume dat tha implementation classes ListNode n' TreeNode up in the
Quick Reference is used fo' any thangs referrin ta linked lists or
trees, unless otherwise stated.
 ListNode n' TreeNode parametas may be null. Otherwise, unless noted
in tha question, assume dat parametas up in method calls is not null, and
that methodz is called only when they preconditions is satisfied.
 Assume dat variablez n' methodz is declared up in tha context of a enclosing
class.
 Assume dat method calls dat have no object or class name prefixed, and
that is not shown within a cold-ass lil complete class definition, step tha fuck up within the
context of a enclosin class.
1. Which of tha followin will evaluate ta legit only if boolean expressions A, B. and
c is all false?
(A) ! A &amp;&amp;: ! (B "" ! C)
(B) ! A I I ! B I I ! C
(C) ! (A I I B I I C)
(D) !(A "" B "" C)
(E) ! A I I ! (B I I ! C)
GO ON TO THE NEXT PAGE.
655
656 Practice Exams
2. Da database fo' a big-ass bookstore has a list of Book objects maintained up in sorted
order by title. Da followin operations is performed on dis list:
I Addin a freshly smoked up book.
II Uppimpin shiznit fo' a individual book.
III Removin a funky-ass book from tha list.
Assumin dat da most thugged-out efficient algorithms is used ta big-ass up tha operations,
which of tha followin be a legit statement bout rockin a ArrayList versus a
LinkedList ta store tha database, biatch? (Assertions bout run time up in tha chizzlez below
should be considered up in termz of big-O efficiency.)
(A) Operation I has approximately tha same run-time efficiency fo' a
LinkedList as fo' a ArrayList.
(B) Operation Pt II has fasta run-time efficiency fo' a LinkedList than an
ArrayList.
(C) Operation Pt III has fasta run-time efficiency fo' a ArrayList than a
LinkedList.
(0) If a freshly smoked up book whose title starts wit tha letta "N' is ta be banged into
the list, insertin tha fuck into a ArrayList gonna git fasta run time than inserting
into a LinkedList.
(E) If tha last book up in tha list must be removed, tha run time is ghon be fasta fo' a
LinkedList than a ArrayList ..
GO ON TO THE NEXT PAGE.
Practice Exam Four
Thangs 3-5 is based on tha three classes below:
hood class Employee
{
}
private Strin myName;
private int myEmployeeNum;
private double mySalary, myTaxWithheld;
hood Employee(Strin name, int empNum, double salary,
double taxWithheld)
{ 1* implementation not shown *1 }
IIReturns pre-tax salary
hood double getSalary()
{ return mySalary; }
hood Strin getName()
{ return myName; }
hood int getEmployeeNum()
{ return myEmployeeNum; }
hood double getTax()
{ return myTaxWithheld; }
hood double computePay()
{ return mySalary - myTaxWithheld; }
hood class PartTimeEmployee extendz Employee
{
}
private double myPayFraction;
hood PartTimeEmployee(Strin name, int empNum, double salary,
double taxWithheld, double payFraction)
{ 1* implementation not shown *1 }
hood double getPayFraction()
{ return myPayFraction; }
hood double computePay()
{ return getSalary() * myPayFraction - getTax();}
hood class Consultant extendz Employee
{
}
private static final double BONUS = 5000;
hood Consultant(Strin name, int empNum, double salary,
double taxWithheld)
{ 1* implementation not shown *1 }
hood double computePay()
{ 1* implementation code *1 }
GO ON TO THE NEXT PAGE.
657
658 - Practice Exams
3. Da computePay method up in tha Consultant class redefines tha computePay
method of tha Employee class ta add a funky-ass bonus ta tha salary afta subtractin the
tax withheld. Y'all KNOW dat shit, muthafucka! Which represents erect 1* implementation code *1 of computePay
for Consultant?
I return super.computePay() + BONUS;
IT super.computePay();
return getSalary() + BONUS;
m return getSalaryO - getTaxO + BONUS;
(A) I only
(B) IT only
(C) monly
(0) I n' m only
(E) I n' IT only
GO ON TO THE NEXT PAGE.
Practice Exam Four 659
4. Consider these valid declarations up in a cold-ass lil client program: _
Employee e = freshly smoked up Employee("Noreen Rizvi", 304, 65000, 10000);
Employee p = freshly smoked up PartTimeEmployee("Rafael Frongillo", 287, 40000,
7000, 0.8);
Employee c = freshly smoked up Consultant("Don Juan Lepage", 694, 55000, 8500);
Which of tha followin method calls will cause a error?
(A) double x = e.computePayO;
(B) double y = p.computePay();
(C) Strin n = c.getName();
0) int num = p.getEmployeeNum();
(E) double g = p.getPayFraction();
5. Consider tha wri tePaylnfo method:
//Writes Employee name n' pay on one line.
hood static void writePaylnfo(Employee e)
{ System.out.println(e.getNameO + " " + e.computePayO); .}
Da followin piece of code invokes dis method:
Employee[] empList = freshly smoked up Employee[3];
empList[O] = freshly smoked up Employee("Lila Fontes", 1, 10000, 850);
empLili\t[l] = freshly smoked up Consultant("Momo Liu", 2, 50000, 8000);
empList[2] = freshly smoked up PartTimeEmployee("Moses Wilks", 3, 25000, 3750,
0.6);
for (Employee e : empList)
writePaylnfo(e);
What will happen when dis code is executed?
(A) A list of hommies' names n' correspondin pay is ghon be freestyled ta the
screen.
(B) A NullPointerException is ghon be thrown.
(C) A ClassCastException is ghon be thrown.
0) A compile-time error will occur, wit tha message dat tha getName method
is not up in tha Consultant class.
(E) A compile-time error will occur, wit tha message dat a instizzle of an
Employee object cannot be pimped.
GO ON TO THE NEXT PAGE.
660
Refer ta tha classes below fo' Thangs 6 n' 7.
hood class ClassA
{
//default constructor not shown ...
hood void methodi()
{ /* implementation of methodi */ }
}
hood class ClassB extendz ClassA
{
//default constructor not shown
hood void methodi()
Practice Exams
{ /* different implementation from methodi up in ClassA*/ }
hood void method2()
{ /* implementation of method2 */ }
}
6. Da methodi method up in ClassB be a example of
(A) method overloading.
(B) method overriding.
(C) polymorphism.
(D) shiznit hiding.
(E) procedural abstraction.
7. Consider tha followin declarations up in a cold-ass lil client class.
ClassA obi = freshly smoked up ClassA();
ClassA ob2 = freshly smoked up ClassB();
Which of tha followin method calls will cause a error?
I obi.method2();
II ob2.method2();
III «ClassB) obi).method2();
(A) I only
(B) Pt II only
(C) Pt III only
(D) I n' Pt III only
(E) I, Pt II, n' Pt III
GO ON TO THE NEXT PAGE.
Practice Exam Four
8. Quicksort is performed on tha followin array, ta sort it up in increasin order:
45 40 77 20 65 52 90 15 95 79
Da first element, 45, is used as tha pivot fo' realz. Afta one iteration of quicksort (i.e.,
afta tha straight-up original gangsta partitioning), which must be true?
I 45 is ghon be tha fourth element of tha array.
II All elements ta tha left of 45 is ghon be sorted.
III All elements ta tha right of 45 is ghon be pimped outa than or equal ta 45.
(A) I only
(B) Pt II only
(C) Pt III only
(0) I n' Pt III only
(E) Pt II n' Pt III only
9 fo' realz. A list of number~ up in unknown order is banged tha fuck into a funky-ass binary search tree. Which
of tha followin is true?
(A) H tha tree produced is reasonably balanced, tha run time ta create tha tree
is O(logn).
(B) H tha tree is balanced, tha run time ta search fo' a given element is
O(nlogn).
(C) Da most shitty case run time ta bang a freshly smoked up element tha fuck into tha tree is O(n2).
(0) A postorder traversal of tha tree will produce tha elements up in ascending
order.
(E) Da run time ta print up tha elements sorted up in ascendin order is O( n ).
10. Consider tha followin class declaration:
hood abstract class AClass
{
}
private int v1;
private double v2;
//methodz of tha class
Which is legit bout AClass?
(A) Any program rockin dis class gonna git a error: An abstract class cannot
contain private instizzle variables.
(B) AClass must gotz a cold-ass lil constructor wit two parametas up in order ta initialize
v1 n' v2.
(C) At least one method of AClass must be abstract.
(0) A client program dat uses AClass must have another class dat be a subclass
of AClass.
(E) In a cold-ass lil client program, mo' than one instizzle of AClass can be pimped.
GO ON TO THE NEXT PAGE.
661
A ALSO
662 Practice Exams
11. Consider tha ObjectList class n' removeObject method below.
hood class ObjectList
{
private LinkedList<type> objList;
Ilconstructor n' other methodz not shown
IIPrecondition: objList be a LinkedList of Type objects.
IIPostcondition: All occurrencez of obj done been removed
}
II from objList.
hood void removeObject(Type obj)
{
I * implementation *1
}
Which 1* implementation *1 will produce tha required postcondition?
I fo' (Type t : objList)
{
}
if (t.equals(obj»
objList.remove(obj);
IT fo' (Iterator<type> itr = objList.iterator(); itr.hasNext();)
{
}
if (itr.next().equals(obj»
objList.remove(obj);
UU Iterator<type> itr - objList.iterator();
while (itr.hasNext(»
{
}
if (itr.next().equals(obj»
itr.removeO;
(A) I only
(B) IT only
(C) monly
(0) IT n' m only
(E) I, IT, n' m
GO ON TO THE NEXT PAGE.
Practice Exam Four
Thangs 12 n' 13 refer ta tha ElapsedTime class below:
hood class ElapsedTime implements Comparable
{
}
private int myHours, myMins, mySecs; 110 &lt;= mySecs &lt; 60,
110 &lt;= myMins &lt; 60
II constructors
hood ElapsedTime()
{ myHours = 0; myMins = 0; mySecs = 0; }
hood ElapsedTime(int h, int m, int s)
{ myHours = h; myMins = m; mySecs = s; }
hood ElapsedTime(int numSecs) IlnumSecs is total number of
{ 1* implementation not shown */} Pt II secondz of elapsed time
IIReturns number of secondz up in ElapsedTime.
hood int convertToSeconds()
{ 1* implementation not shown *1 }
IIReturns a wack integer if dis object is less than obj, 0 if
II dis object is equal ta obj, n' a positizzle integer if this
II object is pimped outa than obj.
hood int compareTo(Object obj)
{ 1* implementation *1 }
Ilaccessors getHours, getMins, n' getSecs not shown ...
GO ON TO THE NEXT PAGE.
663
664 - Practice Exams
12. Consider tha implementation of tha compareTo method fo' tha ElapsedTime
class:
IIReturns a wack integer if dis object is less than obj. 0 if
II dis object is equal ta obj. n' a positizzle integer if this
II object is pimped outa than obj.
hood int compareTo(Object obj)
{
ElapsedTime rhs = (ElapsedTime) obj;
1* mo' code *1
}
Which be a cold-ass lil erect replacement fo' 1* mo' code */?
I if (myHours &lt; rhs.myHours it myMins &lt; rhs.myMins it
mySecs &lt; rhs.mySecs)
return -1;
else if (myHours &gt; rhs.myHours it myMins &gt; rhs.myMins it
mySecs &gt; rhs.mySecs)
return 1;
else
return 0;
IT if (myHours &lt; rhs.myHours)
return -1;
else if (myHours &gt; rhs.myHours)
return 1;
else
{
}
if (myMins &lt; rhs.myMins)
return -1;
else if (myMins &gt; rhs.myMins)
return 1;
else
return mySecs - rhs.mySecs;
III int sees = this.convertToSeconds();
int rhsSecs = rhs.convertToSeconds();
return sees - rhsSecs;
(A) I only
(B) IT only
(C) Pt III only
(0) I n' IT only
(E) IT n' Pt III only
GO ON TO THE NEXT PAGE.
Practice Exam Four
1.3 fo' realz. A client method timeSum will find tha sum of two ElapsedTime objects.
/ /Returns sum of t 1 n' t2.
hood ElapsedTime timeSum(ElapsedTime tl, ElapsedTime t2)
{ / * implementation code * / }
Which is erect /* implementation code */?
lint sl = tl.convertToSeconds();
int s2 = t2.convertToSeconds();
return new ElapsedTime(sl + s2);
IT return new ElapsedTime(tl + t2);
III int totalSecs = tl.getSecs() + t2.getSecs();
int secondz = totalSecs Y. 60;
int totalMins = tl.getMins() + t2.getMin~() + totalSecs / 60:
int minutes = totalMins Y. 60:
int minutes = t 1. getHours 0 + t2. getHours 0 + totalMins / 60:
return new ElapsedTime(hours, minutes, seconds):
(A) I only
(B) IT only
(C) Pt III only
(D) I n' 1lI only
(E) I, IT, n' Pt III
14 fo' realz. A program dat keeps track of tha inventory shit fo' a lil' small-ass store maintains the
items up in a HashMap data structure. Da keys is inventory items, where each item
is a string, n' tha correspondin joints is quantitizzlez of dat item dat is on
the shelf. Thus, some entries up in tha map could be
Campbells Clam Chowder Soup 11
Kleenex Tissues 35
Extra-strength Bufferin 20
Inventory shit is added ta n' removed from tha HashMap as needed. Y'all KNOW dat shit, muthafucka! When a
listin of all inventory shit is required, all shit of tha HashMap is banged into
a TreeMap, whose keySet is then printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Usin tha HashMap n' TreeMap data
structures as busted lyrics bout supports which of tha following?
(A) Listin of all current shit up in alphabetical order, O(log n) insertion of new
items, n' O(log n) retrieval of existin items.
(B) Listin of all current shit up in alphabetical order, O( 1) insertion of new
items, n' O( 1) retrieval of existin items.
(C) Listin of all current shit up in no particular order, 0(1) insertion of new
items, n' 0(1) retrieval of existin items.
(D) Listin of all current shit up in increasin order of quantities, o (log n) insertion
of freshly smoked up items, n' O(log n) retrieval of existin items.
(E) Listin of all current shit up in alphabetical order, 0(1) insertion of new
items, O(log n) retrieval of existin items.
GO ON TO THE NEXT PAGE.
665
666 Practice Exams
15 fo' realz. A big-ass sorted array containin bout 30,000 elements is ta be searched fo' a value
key rockin a iteratizzle binary search algorithm fo' realz. Assumin dat key is up in tha array,
which of tha followin is closest ta tha smallest number of iterations dat will
guarantee dat key is found, biatch? Note: 1 03 ~ 210
(A) 15
(B) 30
(C) 100
(0) 300
(E) 3000
16. Consider tha method searchAndStack.
IIPrecondition: v [0] ... v[v.length-1] initialized wit int joints.
II Stack s is empty. value mayor may not be up in v.
hood static void searchAndStack(int[] v, Stack<integer> s,
{
}
for (int i = 0; i &lt; v.length; i++)
{
}
if (v[i] &gt; value Y. 2)
s.push(new Integer(v[i]»;
else
{
Integer x = s.pop();
}
int value)
Suppose v initially gotz nuff 2 1 6 5 0 9, n' searchAndStack (v, s, 5)
is invoked. Y'all KNOW dat shit, muthafucka! Which of tha followin is ghon be legit afta execution of tha method?
(A) Da stack is ghon be empty.
(B) Da stack will contain three elements wit s.peekTopO equal ta 9.
(C) Da stack will contain two elements wit s . peekTop () equal ta 9.
(0) Da stack will contain two elements wit s.peekTopO equal ta 6.
(E) An EmptyStackException gonna git been thrown.
17. Refer ta tha followin code segment:
int n = &lt; some positizzle integer &gt;
for (int i = n; i &gt;= 1; i 1= 2)
{
process(i);
}
Given dat process (i) has a run time of 0(1), what tha fuck is tha run time of tha algorithm
shown?
(A) 0(1)
(B) O(n)
(C) 0(n2)
(0) 0(n/2)
(E) O(logn)
GO ON TO THE NEXT PAGE.
Practice Exam Four
18 fo' realz. Assume dat linear linked lists is implemented rockin tha ListNode class provided.
Refer ta method mystery below.
IIPrecondition: firstNode refers ta tha straight-up original gangsta node up in a linear
II linked list.
hood static ListNode mystery(ListNode firstNode)
{
}
if (firstNode == null)
return null;
else
{
}
ListNode p = freshly smoked up ListNode(firstNode.getValue(),
mystery(firstNode.getNext(»):
return p:
What do method mystery do?
(A) It creates a exact copy of tha linear linked list referred ta by firstNode and
returns a reference ta dis newly pimped list.
(B) It creates a cold-ass lil copy up in reverse order of tha linear linked list referred ta by
firstNode n' returns a reference ta dis newly pimped list.
(C) It reverses tha pointaz of tha linear linked list referred ta by firstNode and
returns a reference ta tha original gangsta list, which is now up in reverse order.
(0) It leaves tha original gangsta list unchanged n' returns a reference ta tha original
list.
(E) It causes a NullPointerException ta be thrown.
19. Right back up in yo muthafuckin ass. Suppose a queue is implemented wit a cold-ass lil circular linked list dat has just one private
instizzle variable, lastNode, dat refers ta tha last element of tha list:
lastNode cp
cS 1 1  1..-1 --II~I ---.. ... .1 k!b
----------------------------
In tha diagram, f n' b indicate tha front n' back of tha queue. Which of the
followin erectly gives tha run time of (1) add n' (2) remove up in dis implementation?
(A) (l)O(n) (2) 0(1)
(B) (1) 0(1) (2) O(n)
(C) (1) O(n) (2) O(n)
(0) (1) 0(1) (2) 0(n2)
(E) (1) 0(1) (2) 0(1)
GO ON TO THE NEXT PAGE.
667
868 Practice Exams
20. Let list be a ArrayList<string> dat gotz nuff strings soned up in alphabetical
order n' shit. Which of tha followin code segments erectly lists tha duplicate joints
of list up in alphabetical order, biatch? Each duplicate value should be listed just once.
Yo ass may assume dat list gotz nuff at least one duplicate value, n' dat tha line
of code
Set <string> set - freshly smoked up TreeSet</string><string>(list)j
works erectly as specified.
I //Copy elementz of list tha fuck into a freshly smoked up TreeSet.
Set</string><string> set - freshly smoked up TreeSet</string><string>(list)j
System.out.println(set)j
IT Set </string><string> hSet = freshly smoked up HashSet</string><string>()j
Set </string><string> kSet = freshly smoked up TreeSet</string><string>()j
for (Strin str: list)
if (!hSet.add(str»
kSet.add(str)j
System.out.println(kSet)j
1lI //Copy elementz of list tha fuck into a freshly smoked up TreeSet.
Set</string><string> set - freshly smoked up TreeSet</string><string>(list)j
for (Strin str: set)
{
}
int count = -1 j
for (Strin s: list)
{
}
if (str.equals(s»
count++j
if (count &gt; 0)
System.out.print(str + Pt II Pt II);
(A) I only
(B) IT only
(C) monly
(0) IT n' m only
(E) I, IT, n' m
GO ON TO THE NEXT PAGE.
Practice Exam Four
21 fo' realz. A binary expression tree be a funky-ass binary tree dat stores a expression as bigs up. The
root gotz nuff a operator dat is ghon be applied ta tha thangs up in dis biatch of evaluatin expressions
in tha left n' right subtrees, each of which be a funky-ass binary expression tree. The
prefix form of tha expression can be generated by a preorder traversal of tha binary
expression tree dat gotz nuff tha expression. I aint talkin' bout chicken n' gravy biatch. What tha fuck iz tha prefix form of the
expression up in tha binary expression tree shown?
(A) +- /23*456
(B) +*-/23456
(C) +-*2/3456
(D) 23/45*-6+
(E) 23/4-5*6+
22 fo' realz. An algorithm ta convert a funky-ass base-l0 integer n ta base b, where b &lt; 10, uses repeated
division by b until tha quotient is O. Da remaindaz is stored n' then
concatenated ta form a string, startin wit da most thugged-out recent remainder n' shit. This
strin represents n up in base b. For example, ta convert 29 ta base 3:
'3 29
rn 3 9 rem
3 3 rem
3 1 rem
0 rem
29 up in base 3 is 1002
To convert 53 ta base 4:
4~ rn 4 13 rem
4 3 rem
o rem
53 up in base 4 is 311
Which data structure is most suitable fo' storin tha remaindaz durin tha algorithm?
(A) A String
(B) An array
(C) A stack
(D) Aqueue
(E) A prioritizzle queue
GO ON TO THE NEXT PAGE.
669
670 Practice Exams
23. Refer ta tha LinearLinkedList class shown below.
hood class LinearLinkedList
{
}
private ListNode firstNode;
//Construct a empty list.
hood LinearLinkedList()
{ firstNode - null; }
//Return legit if list is empty, false otherwise.
hood boolean isEmpty()
{ return firstNode == null; }
//Return reference ta tha straight-up original gangsta node.
hood ListNode getFirstNode()
{ return firstNode; }
//Change first node of list ta newNode.
hood void setFirstNode(ListNode newNode)
{ firstNode - newNode; }
//other methodz not shown ...
Two freshly smoked up methodz is added ta tha class, a hood method n' a private recursive
helper method.
hood void method1()
{
if (!isEmpty() tt firstNode.getNext() != null)
method2(null, firstNode);
}
//Recursive helper method
private void method2(ListNode prev, ListNode cur)
{
}
if (cur.getNext() -= null)
{
setFirstNode(cur);
}
else
{
method2(cur, cur.getNext(»;
}
cur.setNext(prev);
GO ON TO THE NEXT PAGE.
Practice Exam Four
Suppose a LinearLinkedList object, list, be as bigs up:
firstNode e--I 2 k,j-I 3 '.+-I 4 1+-1 6 [~H-I 6 EgJ
What will list be as a result of tha call list . methodl O?
(A) firstNode B-1 2 I +-1 3 1'+-1 4 It-I 6 1;,+-1 6 f2J
(B) fir~Nte ,I 3 1+-1 2 '.+-I 4 '.,+-I 6 [s+-I 6 flJ
(C) fij:tNte ,I 6 1+-1 4 '+-I 2 1+-1 6 1:.'1--1 3 l%J
(0) firtNt
e ,I 6 (:+-1 6 I. +-1 4 1+-1 3 rt-I 2 tI
(E) fiytNte ,I 6 I +-1 6 121 I 4 I +-1 3 JZJ 2 J2l1
GO ON TO THE NEXT PAGE.
671
672 Practice Exams
24. Consider a cold-ass lil class MatrixStuff dat has a private instizzle variable:
private int[] [] mat;
Refer ta method alta below dat occurs up in tha MatrixStuff class. (Da lines are
numbered fo' reference.)
1 Pt IIPrecondition: mat is initialized wit integers.
2 Pt IIPostcondition: column c has been removed n' tha last column
3 Pt II is filled wit zeros.
4 hood void alter(int[][] mat, int c)
5 {
6 fo' (int i = 0; i &lt; mat. length; i++)
7 fo' (int j = C; j &lt; mat[O].length; j++)
8 mat [i] [j] .. mat [i] [j+1] ;
9 Ilcode ta bang zeros up in rightmost column
10
11 }
Da intent of tha method alta is ta remove column c. Thus, if tha input matrix
mat is
268 9
1 543
o 7 3 2
the method call alta (mat, 1) should chizzle mat to
2 890
143 0
032 0
Da method do not work as intended. Y'all KNOW dat shit, muthafucka! Which of tha followin chizzlez will
correct tha problem?
I Chizzle line 7 to
for (int j = c; j &lt; mat [0] . length - 1; j++)
and make no other chizzles.
II Chizzle lines 7 n' 8 to
for (int j - c + 1; j &lt; mat[O].length; j++)
mat [i] [j-1] = mat [i] [j] ;
and make no other chizzles.
III Chizzle lines 7 n' 8 to
for (int j - mat[O].length - 1; j &gt; c; j--)
mat [i] [j-1] = mat [i] [j] ;
and make no other chizzles.
(A) I only
(B) Pt II only
(C) Pt IIIonly
(D) I n' Pt II only
(E) I, Pt II, n' Pt III
GO ON TO THE NEXT PAGE.
Practice Exam Four
25 fo' realz. A slick binary tree is one wit every last muthafuckin leaf on tha same level; n' every last muthafuckin nonleaf
node has two lil' thugs. N integers is ta be banged tha fuck into tha l~avez of a perfect
binary tree. Da final value of level up in tha followin code segment gives the
lowest level of tree needed ta accommodate all N elements up in its leaves. Which
replacement fo' 1* boolean expression *1 leadz ta tha erect value of level, biatch? Note:
Start countin levels all up in tha root, which is level O.
int level = 0;
while (/* boolean expression */)
level++;
(A) N &lt; Math.pow(2, level)
(B) N &gt;= Math.pow(2, level) tt N &lt; Math.pow(2, level + 1)
(C) N &gt; Math.pow(2, level)
0) N &gt; Math.pow(2, level+1)
(E) N &gt;= Math.pow(2, level)
26 fo' realz. A common use of hexadecimal numerals is ta specify flavas on wizzy pages. Every
color has a red, green, n' blue component. In decimal notation, these are
denoted wit a ordered triple (x,y,z), where x, y, n' z is tha three components,
each a int from 0 ta 255. For example, a cold-ass lil certain shade of red, whose red,
green, n' blue components is 238,9, n' 63, is represented as (238,9,63).
In hexadecimal, a cold-ass lil color is represented up in tha format #RRGGBB, where RR,
GG, n' BB is hex joints fo' tha red, green, n' blue. Usin dis notation, the
color (238,9,63) would be coded as #EE093F.
Which of tha followin hex codes represents tha color (14,20,255)?
(A) #1418FE
(B) #OE20FE
(C) #OE14FF
0) #OFE5FE
(E) #OD14FF
GO ON TO THE NEXT PAGE.
673
674 Practice Exams
27 fo' realz. A big-ass club has a membershizzle list of n names n' beeper numbers stored up in a
text file up in random order, as shown:
RABKIN ARI 694-8176
HUBBARD JUDITH 583-2199
GOLD JONAH 394-5142
Da text file is edited by hand ta add freshly smoked up thugz ta tha end of tha list n' to
delete thugz whoz ass leave tha club.
A programmer is ta write a program dat accesses tha text file n' prints a list
of names/phone numbers up in alphabetical order n' shit. Three methodz is considered:
I Read each line of tha file tha fuck into a strang n' bang it tha fuck into a funky-ass binary search tree.
Print tha list wit a inorder traversal of tha tree.
II Read tha linez of tha file tha fuck into a array of strings. Right back up in yo muthafuckin ass. Sort tha array wit a
selection sort. Print tha list.
ill Read each line of tha file tha fuck into a strang n' bang it tha fuck into its erect sorted
posizzle up in a linear linked list of strings. Thus, tha list remains sorted after
each insertion. I aint talkin' bout chicken n' gravy biatch. Print tha list.
Which be a gangbangin' false statement?
(A) . Each of methodz I, Pt II, n' ill, if implemented erectly, will work.
(B) Method ill, on average, has O( n) run time.
(C) If tha names up in tha text file is approximately up in alphabetical order, methods
I, Pt II, n' ill gonna git tha same big-O run times.
(0) If tha names up in tha text file is randomly ordered, method I has tha fastest
run time.
(E) Da part of tha algorithm dat prints tha list of names is O( n ) up in each of the
three methods.
For Thangs 28 n' 29 refer ta hustla ordaz as busted lyrics bout below:
Hustla ordaz fo' a cold-ass lil catalog company is stored up in a TreeMap t, which is declared as
bigs up:
private TreeMap</string><integer, customerorder=""> t;
Da Integer key be a invoice number n' CustomerOrder is tha correspondin value
in tha map. Each CustomerOrder object gotz nuff tha hustlaz name, address, phone
number, a list of shit purchased, n' tha total cost.
28. What will tha followin code segment do?
for (Integer n : t.keySet(»
System.out.println(n);
(A) List tha invoice numbers up in no particular order.
(B) List tha invoice numbers up in increasin order.
(C) List tha hustla names up in alphabetical order.
(0) List tha CustomerOrder objects up in increasin order by invoice number.
(E) List tha Integer/CustomerOrder pairs up in increasin order by invoice number.
GO ON TO THE NEXT PAGE.
Practice Exam Four
29. Instead of a invoice number, tha programmer considaz rockin tha hustla's
name as tha key n' tha CustomerOrder as tha correspondin value, as before.
Why is dis a gangbangin' finger-lickin' dirty-ass shitty-ass idea?
I It aint possible ta store two or mo' hustlas wit tha same name in
mapt.
II It aint possible fo' two or mo' hustlas ta order tha same item.
m It aint possible fo' a given hustla ta have mo' than one order.
(A) I only
(B) Pt II only
(C) monly
(D) I n' m only
(E) I, Pt II, n' m
30 fo' realz. A class of 30 hustlas rated they computa science mackdaddy on a scale of 1 ta 10
(1 means wack n' 10 means outstanding). Da responses array be a 3O-element
integer array of tha hustla responses fo' realz. An l1-element array freq will count the
number of occurrencez of each response. For example, freq[6] will count the
number of stud~nts whoz ass responded 6. Da quantitizzle freq[O] aint gonna be used.
Here be a program dat counts tha hustlas' responses n' outputs tha thangs up in dis biatch.
hood class StudentEvaluations
{
}
hood static void main(Strin args[])
{
}
int[] responses = {6,6,7,8,10,1,5,4,6,7,
5,4,3,4,4,9,8,6,7,10,
6,7,8,8,9,6,7,8,9,2};
int[] freq = freshly smoked up int[ll];
for (int i = 0; i &lt; responses. length; i++)
freq[responses[i]]++;
//output thangs up in dis biatch
System.out.print("rating\tfrequency\n");
for (int ratin = 1; ratin &lt; freq.length; rating++)
System.out.print(ratin + "\t" +
freq[rating] + "\n");
Suppose tha last entry up in tha initializer list fo' tha responses array was incorrectly
typed as 12 instead of 2. What would be tha result of hustlin tha program?
(A) A ratin of 12 would be listed wit a gangbangin' frequency of 1 up in tha output table.
(B) A ratin of 1 would be listed wit a gangbangin' frequency of 12 up in tha output table.
(C) An ArraylndexOutOfBoundsException would be thrown.
(D) A StringlndexOutOfBoundsException would be thrown.
(E) A NullPointerException would be thrown.
GO ON TO THE NEXT PAGE.
675
676 Practice Exams
31. Consider tha followin method:
hood static void sketch(int xl, int yl, int x2, int y2, int n)
{
}
if (n &lt;= 0)
else
{
}
drawLine(xl, yl, x2, y2);
int xm = (xl + x2 + y1 - y2) / 2;
int ym = (y1 + y2 + x2 - xl) / 2;
sketch(xl, yl, xm, ym, n - 1);
sketch(xm, ym, x2, y2, n - 1);
Assume dat tha screen be lookin like a Cartesian coordinate
system wit tha origin all up in tha center, n' dat drawLine
connects (xl,yl) ta (x2,y2) fo' realz. Assume also dat xl, yl, x2,
and y2 is never too big-ass or too lil' small-ass ta cause errors.
Which picture dopest represents tha sketch drawn by the
method call
sketch(a, 0, -a, 0, 2)
where a be a positizzle integer?
(A) y (B)
a
-a
-a a x
-a
(C) y (D)
a
-a a x -a
-a
(E) y
a
-a x
y
y
a
a
x
-a
y
a
a x
-a
x
GO ON TO THE NEXT PAGE.
Practice Exam Four
32. Consider tha followin methods. (Yo ass may assume dat tha SOOleType class has a
default constructor.)
hood List</integer,><sometype> methodl(int n)
{
LinkedList</sometype><sometype> list = freshly smoked up LinkedList</sometype><sometype>()j
for (int i = OJ i &lt; nj i++)
list.addFirst(new SomeType(»j
return listj
}
hood List</sometype><sometype> method2(int n)
{
LinkedList</sometype><sometype> list = freshly smoked up LinkedList</sometype><sometype>()j
for (int i = OJ i &lt; nj i++)
list.addLast(new SomeType(»j
return listj
}
Which of tha followin dopest raps bout tha hustlin time of
(1) methodl n' (2) method2?
(A) (1) 0(1)
(B) (1) O(n)
(C) (1) 0(n2)
(D) (I)O(n)
(E) (1) 0(1)
(2) 0(1)
(2) O(n)
(2) 0(n2)
(2) 0(n2)
(2) O(n)
For Thangs 33-35, assume dat binary trees is implemented wit tha TreeNode
class provided.
33. Consider method printStuff:
//Precondition: tree refers ta tha root of a funky-ass binary tree.
hood static void printStuff(TreeNode tree)
{
}
if (tree != null)
{
}
if (tree.getLeft() != null)
System.out.println(tree.getLeft().getValue(»j
printStuff(tree.getLeft(»j
printStuff(tree.getRight(»j
Which dopest raps bout what tha fuck method printStuff do?
(A) Prints every last muthafuckin element up in tree except tha element up in tha root node.
(B) Prints every last muthafuckin element up in tree.
(C) Prints tha element up in tha left lil pimp of every last muthafuckin node up in tree.
(D) Prints every last muthafuckin element up in tha left subtree of tree.
(E) Prints tha element up in tha root node as well as every last muthafuckin element up in tha left subtree
of tree.
GO ON TO THE NEXT PAGE.
677
678 Practice Exams
For Thangs 34 n' 35 consider tha BinaryTree n' BinarySearchTree classes below:
hood abstract class BinaryTree
{
}
private TreeNode root;
hood BinaryTree()
{ root = null; }
hood TreeNode getRoot()
{ return root; }
hood void setRoot(TreeNode theNewNode)
{ root = theNewNode; }
hood boolean isEmpty()
{ return root == null; }
hood abstract void insert(Comparable item);
hood abstract TreeNode find(TreeNode p. Comparable key);
hood class BinarySearchTree extendz BinaryTree
{
}
IIInsert item up in BinarySearchTree.
hood void insert(Comparable item)
{ 1* implementation not shown *1 }
IIPrecondition: Binary search tree rooted at p.
IIReturns TreeNode dat gotz nuff key.
IIIf key not up in tree. returns null.
hood TreeNode find(TreeNode p. Comparable key)
{ 1* implementation code *1 }
34. Which be afalse statement bout these classes?
(A) Da compila will provide tha followin default constructor fo' the
BinarySearchTree class:
hood BinarySearchTree()
{ supa 0 ; }
(B) Da bang n' find methodz up in tha BinaryTree class is abstract cuz
their implementation dependz on tha type of binary tree.
(C) Da item n' key parametaz of bang n' find need ta be Comparable
since tha methodz require you ta compare objects.
(D) Da private instizzle variable root of tha superclass cannot be altered by the
BinarySearchTree class.
(E) Da followin statement up in a cold-ass lil client program will cause a error:
BinaryTree tree = freshly smoked up BinarySearchTree(new String("A"»;
GO ON TO THE NEXT PAGE.
Practice Exam Four
35. Which is erect 1* implementation code *1 fo' tha find method?
I if (p -= null)
return null;
else if (key.compareTo(p.getValue(» == 0)
return p;
else if (key.compareTo(p.getValue(» &lt; 0)
return find(getRoot().getLeft(), key);
else
return find(getRoot().getRight(), key);
.11 if (p == null)
return null;
else if (key.compareTo(p.getValue(» == 0)
return p;
else if (key.compareTo(p.getValue(» &lt; 0)
return find(p.getLeft(), key);
else
return find(p.getRight(), key);
lIT while (p != null tt key.compareTo(p.getValue(»!= 0)
{
if (key.compareTo(p.getValue(» &lt; 0)
p = p.getLeft();
else
p = p.getRight();
}
return p;
(A) I only
(B) IT only
(C) monly
(0) IT n' m only
(E) I, IT, n' m
GO ON TO THE NEXT PAGE.
679
680
-
Practice Exams
Thangs 36-40 involve reasonin bout tha code from tha GridWorid Case Study.
A Quick Reference ta tha case study is provided as part of dis exam. Da hustlas in
GridWorid is represented up in dis book wit tha pictures shown below. Each hustla is
shown facin north. These pictures almost certainly is ghon be different from dem used
on tha AP exam!
Actor Bug Flower Rock Critta ChameleonCritter
36. Which of tha followin has exactly one possible freshly smoked up location dat tha Critta in
(0,0) could move to, assumin dat it is dat Critterz turn ta act?
I °
° '"
,
~ &lt;~.~i
2
II °
o ~ </sometype><r~.~i ="" t~="" ...="" <r="" i="" 2="" ill="" ....--...:..o_.---="-----." (a)="" only="" (b)="" pt="" ii="" (c)="" illonly="" (0)="" n'="" (e)="" i,="" ii,="" go="" on="" to="" the="" next="" page.="" practice="" exam="" four="" 37.="" refer="" ta="" tha="" followin="" statements.="" location="" locl="freshly" smoked="" up="" location(l,="" 3);="" loc2="freshly" location(2,="" 1);="" loc3="" z="" freshly="" location(3,="" 2);="" loc4="loc1.getAdjacentLocation(40);" loc5="loc2.getAdjacentLocation(200);" which="" is="" (are)="" true?="" loc2.="" getdirectiontoward(loc3)="" returns="" 135.="" 11="" loc1.compareto(loc5)="=" 0="" iii="" loc4.getadjacentlocation(230).equals(loc1)="" monly="" (d)="" m="" 1,11,="" 38.="" da="" behavior="" of="" a="" bug="" be="" modified="" as="" bigs="" up:="" every="" time="" it="" moves="" new="" location,="" will="" drop="" critta="" fuck="" into="" its="" oldschool="" instead="" flower="" shit.="" in="" order="" bust="" dis="" chizzle,="" programmer="" modifies="" move="" method="" class="" up.="" chizzlez="" boldface.="" hood="" void="" move()="" {="" grid<actor=""> gr = getGrid();
if (gr == null)
return;
Location loc = getLocation();
Location next = loc.getAdjacentLocation(getDirection(»;
if (gr.isValid(next»
}
moveTo(next);
else
removeSelfFromGrid();
Critta critta  freshly smoked up Critter();
gr.put(loc. critter);
Da program appears ta work as intended. Y'all KNOW dat shit, muthafucka! But fuck dat shiznit yo, tha word on tha street is dat afta all dem steps, tha programmer
notices dat tha Critta objects is not behavin properly. Flowers
and bugs up in they hoodz is not bein "eaten" as specified. Y'all KNOW dat shit, muthafucka! Nor is the
crittas movin as they should. Y'all KNOW dat shit, muthafucka! Which of tha followin is tha erect reason for
this errant behavior?
(A) Da act method of Bug is bein called fo' each critta dat is dropped by a
bug.
(B) Da Playa class aint bein erectly accessed by Critta objects.
(C) Da Critta class was not imported tha fuck into tha programmerz project.
(D) Each critta bein dropped by a funky-ass bug has no reference ta tha grid. Y'all KNOW dat shit, muthafucka! Therefore,
its location aint bein updated.
(E) Da driver class fo' tha program, a cold-ass lil class like BugRunner, aint uppimpin the
location of each critta dropped by a funky-ass bug.
GO ON TO THE NEXT PAGE.
681
..- ",,'~. ........'
682 Practice Exams
39. Da getValidAdjacentLocations method of tha AbstractGrid class is modified
as shown below. Chizzlez is up in boldface.
hood ArrayList</r~.~i><location> getValidAdjacentLocations(Location loc)
{
}
ArrayList</location><location> locs = freshly smoked up ArrayList</location><location>();
int d = Location.NORTH;
for (int i = 0; i &lt; Location.FULL_CIRCLE / Location.HALF_RIGHT; i++)
{
}
if (i X 2  1)
{
}
Location neighborLoc = loc.getAdjacentLocation(d);
if (isValid(neighborLoc»
locs.add(neighborLoc);
d = d + Location. I aint talkin' bout chicken n' gravy biatch yo. HALF_RIGHT;
return locs;
What tha fuck iz tha effect of dis chizzle?
(A) Da method returns all valid locations whose direction from loc be a odd
number.
(B) Da method returns all valid locations whose direction from loc be a even
number.
(C) Da method returns all valid adjacent locations dat share a side wit loco .
(D) Da method returns all valid adjacent locations dat share a cold-ass lil corner point,
but not a side, wit loco
(E) Da method is equivalent ta tha original, n' returns all valid locations that
are adjacent ta loco
40. Consider a large, roughly square grid whose dimensions is approximately n x n.
Da grid is sparsely populated wit hustlas-approximately one hustla per row.
What tha fuck iz tha big-O performizzle of tha getOccupiedLocations method if tha grid
IS a
(1) BoundedGrid
(A) (1) 0(n2)
(B) (1) 0(n2)
(C) (1) O(n)
(0) (1) 0(n2)
(E) (1) O(n)
(2)UnboundedGrid?
(2) O(n2)
(2) O(n)
(2) O(n)
(2) 0(1)
(2) 0(1)
END OF SECTION I
Practice Exam Four
COMPUTER SCIENCE AB
SECTION Pt II
Time-l minute n' 45 minutes
Number of thangs-4
Percent of total grade-50
Directions: SHOW ALL YOUR WORK. REMEMBER THAT
PROGRAM SEGMENTS ARE TO BE WRITTEN IN Java.
Write yo' lyrics up in pencil only up in tha booklet provided.
Notes:
 Assume dat tha classes up in tha Quick Reference done been imported where
needed.
 Assume dat tha implementation classes ListNode n' TreeNode is used
for any thangs referrin ta linked lists or trees, unless otherwise specified.
 ListNode n' TreeNode parametas may be null. Otherwise, unless noted
in tha question, assume dat parametas up in method calls is not null, and
that methodz is called only when they preconditions is satisfied.
 In freestylin solutions fo' each question, you may use any of tha accessible
methodz dat is listed up in classes defined up in dat question. I aint talkin' bout chicken n' gravy biatch. Freestylin significant
amountz of code dat can be replaced by a cold-ass lil call ta one of these methods
may not receive full credit.
1. Da followin class, Digi talClock, is designed ta display n' manipulate a gangbangin' finger-lickin' digital
clock. Da incomplete class declaration is shown below. Yo ass is ghon be axed to
write tha declaration fo' a cold-ass lil class dat stores n' manipulates a list of digital clocks.
hood class DigitalClock
{
Ilprivate instizzle variablez ta represent hours, minutes, n' a
II display strang is not shown ...
IIConstructs a DigitalClock set at 12:00.
hood DigitalClock()
{ 1* implementation not shown *1 }
IIConstructs a DigitalClock set all up in tha specified minute n' minute.
hood DigitalClock(int hour, int minute)
{ 1* implementation not shown *1 }
GO ON TO THE NEXT PAGE.
683
684 Practice Exams
//Advances tha time on tha DigitalClock by one minute.
hood void advanceTime()
}
{ /* implementation not shown */ }
//Returns legit if dis DigitalClock is defective, false otherwise.
hood boolean isDefective()
{ /* implementation not shown */ }
//other methodz not shown ...
Write a cold-ass lil complete declaration, includin implementation of all methods, fo' a
class called AllClocks. This class stores n' manipulates a list of Digi talClock
objects, n' you can put dat on yo' toast. Da AllClocks class must gotz a private instizzle variable
ArrayList</location><digitaiclock> clocks
and a cold-ass lil constructor dat creates a empty list of Digi talClock objects (i.e., initializes
clocks ta empty).
Da AllClocks class should have methodz dat do each of tha following:
 Add a freshly smoked up Digi talClock, set at 12:00, ta clocks.
 Advizzle tha time by one minute on all tha clocks.
 Remove all defectizzle clocks.
 Replace all defectizzle clocks wit a freshly smoked up clock set at 12:30 (hours 12, minutes
30).
Complete tha class declaration fo' AllClocks started below:
hood class AIIClocks
{
private ArrayList</digitaiclock><digitalclock> clocks;
2 fo' realz. A color grid is defined as a two-dimensionizzle array whose elements is character
strings havin joints "b" (blue), "r" (red), "g" (green), or -"y" (yellow). The
elements is called pixels cuz they represent pixel locations on a cold-ass lil computer
screen. I aint talkin' bout chicken n' gravy biatch. For example,
b b g r
g r g r
r r r r r
y g r
b y g
g r b
b b g
A connected region fo' any pixel is tha set of all pixelz of tha same color dat can
be reached all up in a gangbangin' finger-lickin' direct path along horizontal or vertical moves startin at
that pixel fo' realz. A connected region can consist of just a single pixel or tha entire color
grid. Y'all KNOW dat shit, muthafucka! For example, if tha two-dimensionizzle array is called pixels, tha connected
region fo' pixels [lJ [OJ be as shown here fo' three different arrays.
b b g r
g r g r
y g r b
ggyg
b g r g
GO ON TO THE NEXT PAGE.
Practice Exam Four
Da class ColorGrid, whose declaration is shown below, is used fo' storing, displaying,
and changin tha flavas up in a cold-ass lil color grid.
hood class ColorGrid
{
}
private String[] [] myPixels;
private int myRows;
private int myCols;
1* constructor
* Creates numRows X numCols ColorGrid from Strin s. *1
hood ColorGrid(Strin s, int numRows, int numCols)
{ 1* ta be implemented up in part (a) *1 }
1* Precondition: myPixels[row] [col] is oldColor, one of "r",
* "b" ,"g", or "y".
* newColor is one of "r", "b", "g", or "y".
* Postcondition: if 0 &lt;= row &lt; myRows n' 0 &lt;= col &lt; myCols,
* paints tha connected region of
* myPixels[row] [col] tha newColor.
* Do not a god damn thang if oldColor is tha same ol' dirty as
* newColor. Shiiit, dis aint no joke. *1
hood void paintRegion(int row, int col, Strin newColor,
Strin oldColor)
{ 1* ta be implemented up in part (b) *1 }
Ilother methodz not shown
(a) Write tha implementation code fo' tha ColorGrid constructor. Shiiit, dis aint no joke. Da constructor
should initialize tha myPixels matrix of tha ColorGrid as bigs up:
Da dimensionz of myPixels is numRows X numCols. Right back up in yo muthafuckin ass. Strin s gotz nuff
numRows X numCols characters, where each characta is one of tha flavas of
the grid-"r", "g", "b", or "y". Da charactas is contained up in s row by
row from top ta bottom n' left ta right. For example, given dat numRows
is 3, n' numCols is 4, if s is "brrygrggyyyr", myPixels should be initialized
to be
b r r y
g r g g
y y y r
Complete tha constructor below:
1* constructor
* Creates numRows X numCols ColorGrid from Strin s. *1
hood ColorGrid(Strin s, int numRows, int numCols)
GO ON TO THE NEXT PAGE.
685
686 Practice Exams
(b) Write tha implementation of tha paintRegion method as started below.
Note: Yo ass must write a recursive solution. I aint talkin' bout chicken n' gravy biatch. Da paintRegion paints
the connected region of tha given pixel, specified by row n' col, a gangbangin' finger-lickin' different
color specified by tha newColor parameter n' shit. If newColor is tha same ol' dirty as oldColor,
the color of tha given pixel, paintRegion do nothing. To visualize
what paintRegion do, imagine dat tha different flavas surroundin the
connected region of a given pixel form a funky-ass boundary. When paint is poured
onto tha given pixel, tha freshly smoked up color will fill tha connected region up ta the
boundary.
For example, tha effect of tha method call c.paintRegion(2, 3, "b", "r")
on tha ColorGrid c is shown here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. (fhe startin pixel is shown up in a gangbangin' frame,
and its connected region is shaded.)
before after
rrb g yy
brb y rr
ggr0 rb
yrr y rb
r r b g Y Y
brbybb
ggbbbb
ybbybb
Complete tha method paintRegion below. Note: Only a recursive solution
will be accepted.
/* Precondition: myPixels[row] [col] is oldColor, one of "r",
* "b" , "g", or "y".
* newColor is one of "r", "b" , "g", or "y".
* Postcondition: if 0 &lt;= row &lt; myRows n' 0 &lt;= col &lt; myCols,
* paints tha connected region of
* myPixels[row] [col] tha newColor.
* Do not a god damn thang if oldColor is tha same ol' dirty as
* newColor. Shiiit, dis aint no joke. */
hood void paintRegion(int row, int col, Strin newColor,
Strin oldColor)
3 fo' realz. A school newspaper has nuff muthafuckin hustlas whoz ass have each applied ta fill at least one
of tha followin editorial positions: Hype, Arts, Sports, Features, n' Photos.
For example
Student
Mary
Joe
Jill
Kay
Tim
Jan
~ __ P?~~~i~l!~~~I?p!i~~_Fo~ _ ~ __
Hype, Features, Sports
Arts, Photos
Hype, Arts, Features
Photos
Arts, Hype, Sports, Photos
News
GO ON TO THE NEXT PAGE.
Practice Exam Four
Da followin class, NewspaperPositions, manipulates n' stores tha data busted lyrics about
in tha table. Da class gotz nuff two maps fo' storin data:
 requestMap, whose keys is hustla names, n' correspondin joints are
the setz of positions axed by each hustla .
 positionFreqMap, whose keys is positions, n' correspondin joints are
the numberz of hustlas whoz ass axed each position.
hood class NewspaperPositions
{
}
private Map</digitalclock><string, set<string»="" requestmap;="" private="" map<string,="" integer=""> positionFreqMap;
IIPostcondition:
II
II
requestMap gotz nuff hustlas n' positions
they requested.
positionFreqMap has been pimped.
public
{
NewspaperPositions()
}
requestMap = loadRequestMap();
positionFreqMap = createFreqMap();
IIPostcondition: Returns map wit hustla names and
II correspondin setz of axed positions.
private Map</string,><string, set="" <string»="" loadrequestmap()="" {="" 1*="" implementation="" not="" shown="" *="" }="" iipostcondition:="" returns="" map="" wit="" positions="" and="" ii="" correspondin="" frequenciez="" of="" requests.="" private="" map<string,="" integer=""> createFreqMap()
{ 1* ta be implemented up in part (b) */}
IIPrecondition: hustla be a key up in requestMap.
IIPostcondition: Returns legit if hustla axed the
II specified position, false otherwise.
hood boolean didRequest(Strin hustla, Strin position)
{ 1* ta be implemented up in part (a) */}
Ilother methodz not shown ...
(a) Write tha NewspaperPositions method didRequest. Method didRequest
determines whether a given hustla axed a specified position. I aint talkin' bout chicken n' gravy biatch. For example,
usin tha data up in tha table on tha previous page:
didRequest("Tim", "Features")
didRequest("Kay", "Photos")
Complete method didRequest below.
will return false
will return true
IIPrecondition: hustla be a key up in requestMap.
IIPostcondition: Returns legit if hustla axed the
II specified position, false otherwise.
hood boolean didRequest(Strin hustla, Strin position)
GO ON TO THE NEXT PAGE.
687
688 Practice Exams
(b) Write tha NewspaperPositions method createFreqMap. This method creates
a frequency map of positions n' tha correspondin number of requests.
For example, if tha table shown on p. 686 represents requestMap,
the statement
positionFreqMap = createFreqMap();
should create tha followin mapping.
Position
News
Features
Sports
Arts
Photos
Number of Requests
"-- - . ----~ -- ------ -"--
Complete method createFreqMap below.
4
2
2
3
3
IIPostcondition: Returns map wit positions and
II correspondin frequenciez of requests.
private Map</string,><string. integer=""> createFreqMap()
(c) Suppose yo ass is given tha followin shiznit:
 requestMap be a HashMap.
 Da joints up in requestMap is HashSets.
 There is n hustlas up in requestMap.
 There be a maximum of c positions bein requested.
In termz of nand c, what tha fuck is tha big-O hustlin time of tha didRequest
method, assumin dat da most thugged-out efficient algorithm was used?
4. This question involves reasonin bout tha code from tha GridGhetto Case Study.
A Quick Reference ta tha case study is provided as part of dis exam.
In dis question yo big-ass booty is ghon write two of tha BoundedGrid</string.><e> methodz rockin a
linked list implementation of tha BoundedGrid</e><e> class. Da current version of
BoundedGrid</e><e> implements tha grid as a two- dimensionizzle array of Object. Consider
a one-dimensionizzle array of linked lists, where each linked list represents one
row of tha grid. Y'all KNOW dat shit, muthafucka! Thus, each element of tha array be a linked list, or null if that
row is empty. Each index of tha array represents a row number.
Each node up in each of tha linked lists be a GridNode, which holdz a grid occupant,
the location of dat occupant, n' a link ta another GridNode. Da GridNode class
is shown below:
GO ON TO THE NEXT PAGE.
Practice Exam Four
hood class GridNode
{
}
private Object occupant;
private GridNode next;
private Location myLoc;
hood GridNode(Object initOccupant, GridNode initNext,
Location initLoc)
{
}
occupant = initOccupant;
next = initNext;
myLoc = initLoc;
hood Object getOccupant()
{return occupant;}
hood GridNode getNext()
{return next;}
hood Location getLoc()
{return myLoc;}
hood void setOccupant(Object theNewOccupant)
{occupant = theNewOccupant;}
hood void setNext(GridNode theNewNext)
{next = theNewNext;}
Da example below shows how tha fuck tha 4 x 4 BoundedGrid shown would be represented
in tha freshly smoked up implementation. I aint talkin' bout chicken n' gravy biatch. Notice dat up in each linked list, tha locations
are maintained up in increasin order.
o 2 3
o , &lt;'I!... ...I 
occupantArray[O] _I ' 1 ~~
D (0,1) ~
occupantArrayU] ~
D -~
occupant Array [2]
2 D .. '" 3
occupantArray[3] _1*1 ~r;&amp;;Ti1
D (3,1) l§JLJ
Here is tha private instizzle variablez up in tha modified implementation of
BoundedGrid</e><e> .
private GridNode[] occupantArray;
private int myNumCols;
GO ON TO THE NEXT PAGE.
689
690 Practice Exams
(a) Write tha getOccupiedLocations method fo' tha linked list implementation
of tha BoundedGrid</e><e> class. Da method returns all occupied locations
in tha grid.
Complete method getOccupiedLocations below.
1**
* Gets all occupied locations up in dis grid.
* Greturn a list of occupied locations
*1
hood ArrayList</e><location> getOccupiedLocations()
(b) Write tha put method fo' tha linked list implementation of the
BoundedGrid</location><e> class. Method put bangs object obj at location loc up in the
grid, n' returns tha object dat was previously at loc, or null if dat location
was unoccupied. Y'all KNOW dat shit, muthafucka! Recall dat afta you have banged obj, tha locations
in its row must still be up in increasin order.
Complete method put below.
1**
* Puts obj at location loc up in dis grid, n' returns
* tha object previously at dat location.
* Returns null if loc was previously unoccupied.
* Precondition: obj aint null, n' loc is valid up in dis grid.
* Gparam loc tha location where tha Object is ghon be placed
* Gparam obj tha object ta be placed
* Greturn tha object previously all up in tha specified location
* Gthrows IllegalArgumentException if tha location is invalid
* Gthrows NullPointerException if tha object is null
*1
hood E put (Location loc, E obj)
{
if (lisValid(loc»
throw new IllegalArgumentException("Location " + loc
+ " aint valid");
if (obj == null)
throw new NullPointerException("obj == null");
(c) Suppose dat tha grid gotz nuff r rows, c columns, n' n occupants, where
r, c, n' n is all large. What tha fuck iz tha big-O run time fo' tha put method
algorithm dat you freestyled up in part (b), up in termz of r, c, n' n?
END OF EXAMINATION
Answers Explained
ANSWER KEY (Section I)
._. I 
I.C 15 fo' realz. A 29. D
2 fo' realz. A 16. C 30. C
3. D 17. E 31. B
4. E 18 fo' realz. A 32. B
5 fo' realz. A 19. E 33. C
6. B 20. D 34. D
7. E 21 fo' realz. A 35. D
8. D 22. C 36. D
9. E 23. D 37. D
10. D 24. D 38. D
1l.C 25. C 39. D
12. E 26. C 40. B
13.D 27. B
14. B 28. B
-
ANSWERS EXPLAINED (Section I)
1. (C) In order fo' ! (A I I B I I C) ta be true, (A I I B I I C) must evaluate to
false. This will happen only if A, B, n' C is all false. Chizzle A evaluates ta true
when A n' B is false n' C is true. In chizzle B, if mah playaz of A, B, or C is false,
the boolean expression evaluates ta true. In chizzle D, if mah playaz of A, B, or C is
false, tha boolean expression evaluates ta legit since our crazy asses have biaaatch! (false) fo' realz. All that's
required fo' chizzle E ta evaluate ta legit is fo' A ta be false. Right back up in yo muthafuckin ass. Since legit Pt II (any)
evaluates ta true, both B n' C can be either legit or false.
2. (A) For addin a funky-ass book ta a ArrayList: Findin tha insertion point is O(log n)
(binary search). Insertion is O(n) (requires movement of elements). Overall:
O(n). For a LinkedList: Findin tha insertion point is O(n). Insertion is 0(1).
Overall: O(n). Chizzle B is false: Findin a given book up in tha ArrayList, which
is sorted by title, is O(log n) (binary search) yo, but O(n) fo' a LinkedList. Chizzle
C is false: To remove a funky-ass book requires findin tha book n' then removin dat shit. For
an ArrayList, tha search is O(logn) (binary search) n' removal is O(n). On
balance,O(n). For a LinkedList, tha search is O(n) n' removal is 0(1). On
balance, O(n). Chizzle D is false: For a ArrayList, findin tha insertion point is
O(log n) (binary search). Insertion, however, requires movement of just bout all
the elements, O( n). In tha LinkedList, tha sequential search ta find tha insertion
point is ghon be O(n); insertion itself, 0(1). Right back up in yo muthafuckin ass. So both list implementations will be
O(n). Note dat knowin dat tha title begins wit "A" don't chizzle tha runtime
efficiency estimate: Yo ass don't give a fuck where up in tha Az tha title appears, and
there is O(n) titlez beginnin wit "A" since you can't assume anythang special
about tha distribution of titlez among lettaz of tha alphabet. Chizzle E is false: To
remove tha last book from both a ArrayList n' a LinkedList is O( 1). (Recall
691
692 Practice Exams
that a LinkedList is implemented wit a thugged-out doubly linked list wit access at both
ends.)
3. (0) Implementation I calls super.computePayO, which is equivalent ta the
computePay method up in tha Employee superclass. Da method returns tha quantity
mySalary - myTaxWi thheld. Y'all KNOW dat shit, muthafucka! Da BONUS is then erectly added ta dis expression,
as required. Y'all KNOW dat shit, muthafucka! Implementation Pt III erectly uses tha hood accessor methods
get Salary n' getTax dat tha Consultant class has inherited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Note dat the
Consultant class aint gots access ta tha private instizzle variablez mySalary
and myTaxWi thheld even though it inherits dem from tha Employee class. Implementation
II incorrectly returns tha salary plus BONUS-there is no tax withheld.
Da expression supa n' shit. computePayO returns a value equal ta salary minus tax.
But dis is neither stored nor included up in tha return statement.
4. (E) Note dat p is declared ta be of type Employee, n' tha Employee class
does not gotz a getPayFraction method. Y'all KNOW dat shit, muthafucka! To stay tha fuck away from tha error, p must be cast
to PartTimeEmployee as bigs up:
double g = «PartTimeEmployee) p).getPayFraction()j
5. (A) Da code do exactly what tha fuck it be lookin like it should. Y'all KNOW dat shit, muthafucka! Da wri tePaylnfo parameter
iz of type Employee n' each element of tha empList array is.a Employee
and therefore do not need ta be downcast ta its actual instizzle type. There is
no ClassCastException (choice C) since nowhere is there a attempt made to
~ast a object ta a cold-ass lil class of which it aint a instance. None of tha array elements
is null; therefore, there is no NullPointerException (choice B). Chizzle D
won't happen cuz tha getName method is inherited by both tha Consultant
and PartTimeEmployee classes. Chizzle E would occur if tha Employee superclass
were abstract yo, but itz not.
6. (8) Method overridin occurs whenever a method up in a superclass is redefined in
a subclass. Method overloadin be a method up in tha same class dat has tha same
name but different parameta types. Polymorphizzle is when tha erect overridden
method is called fo' a particular subclass object durin run time. Information
hidin is tha use of private ta restrict access. Procedural abstraction is tha use of
helper methods.
7. (E) All will cause a error!
I: An object of a superclass aint gots access ta a freshly smoked up method of its subclass.
II: ob2 is declared ta be of type ClassA, so a cold-ass lil compile-time error will occur with
a message indicatin dat there is no method2 up in ClassA. Castin ob2 ta ClassB
would erect tha problem.
III: A ClassCastException is ghon be thrown, since ob1 iz of type ClassA, n' therefore
cannot be cast ta ClassB.
8. (0) Durin partitionin tha array be lookin like this:
~ --+- +-- +--
~ 40 77 20 65 52 90 15 95 79
~ --+- +-- +-- +-- +--
40 15 20 65 52 90 77 95 79
20 40 15 ~ 65 52 90 77 95 79
Answers Explained
Note dat 45, tha pivot, is up in its final sorted position, tha fourth element up in the
array fo' realz. All elements ta tha left of 45 is less than 45 but is not sorted wit respect
to each other n' shit. Right back up in yo muthafuckin ass. Similarly, all elements ta tha right of tha pivot is pimped outa than or
equal ta it but is unsorted.
9. (E) An inorder traversal of tha tree will produce tha elements up in ascendin order.
Whether tha tree is balanced or not, each of tha n nodes is ghon be hit up once during
the traversal, which is O(n). Each of tha other chizzlez is incorrect. In chizzle
A, each of tha n elements may require a log2 n search ta find its slot, so bustin
the tree is O( n log n). In chizzle B, ta find a single element up in a funky-ass balanced tree requires
no mo' than one comparison on each of log2 n levels. This is O(log n ).
In chizzle C, even if tha tree is straight-up unbalanced n' consistz of one long
linked list (worst case), there is ghon be no mo' than n comparisons ta bang one
element. This is O( n). In chizzle D, a postorder traversal fo' tha binary search
tree shown below produces 1,7,6, which aint up in ascendin order n' shit. In a funky-ass binary
search tree, tha order property causes tha leftmost elements ta be tha smallest and
the rightmost. tha phattest. Thus, a inorder traversal will produce tha elements
sorted up in ascendin order.
10. (0) A program dat uses a abstract class must have at least one subclass dat is
not abstract, since instancez of abstract classes cannot be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Thus, chizzle E
is false. Chizzle A is false: An abstract class can contain any number of private
instizzle variables, each of which is inherited by a subclass of AClass. Chizzle
B is wrong-for example vi n' v2 could be initialized up in a thugged-out default constructor
(constructor wit no parameters). Chizzle C is incorrect: Da point of a abstract
class is dat no instancez of it is ghon be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da class do not need ta contain
any abstract methods.
11. (C) When a iterator is used ta traverse a list, only tha methodz of Iterator
may be used. Y'all KNOW dat shit, muthafucka! Implementation Pt II would be erect if tha last line was chizzled to
i tr . remove () ;. Implementation I fails cuz a gangbangin' for-each loop cannot be used to
remove a object from a cold-ass lil collection Yo ass must use a iterator.
12. (E) Implementation I uses faulty logic. For example, it treats a ElapsedTime of
5 minutes 12 minutes 30 secondz as equal ta 12 minutes 6 minutes 20 seconds.
13. (0) Segment Pt II is wack cuz you can't use simple addizzle ta add two objects:
Da code must be explicitly written. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Segment I works cuz you addin two
int joints n' then invokin tha constructor whose argument is tha total number
of seconds. Right back up in yo muthafuckin ass. Segment Pt III works by a funky-ass brute force computation of hours, minutes,
and seconds.
14. (B) A HasbMap stores its elements up in a hash table. Therefore, it serves up 0(1) run
times fo' its git n' put operations. Da key set aint stored up in any particular
order n' shit. Constructin a TreeMap wit tha inventory elements places dem up in a
binary search tree n' allows printin of tha key set up in ascendin order (which is
alphabetic order fo' Strin objects).
693
694 Practice Exams
15. (A) 30,000 = 1000 x 30 ~ 210 X 25 = 215. Right back up in yo muthafuckin ass. Since a successful binary search in
da most thugged-out shitty case requires log2 n iterations, 15 iterations will guarantee dat key is
found. Y'all KNOW dat shit, muthafucka! (Note dat 30,000 &lt; 210 X 25 = 32,768.)
16. (C) Since value 5 is odd, value % 2 is 1 fo' realz. Array v is examined sequentially. Each
time a element pimped outa than 1 is encountered, it is pushed onto tha stack. Each
time a element less than or equal ta 1 is encountered, tha stack is popped. Y'all KNOW dat shit, muthafucka! Thus
the followin sequence of actions will occur: push 2, pop, push 6, push 5, pop,
push 9. Four pushes n' two pops leave tha stack wit 2 elements, n' 9 on top.
Note dat a EmptyStackException is thrown if a attempt is made ta pop an
empty stack.
17. (E) Da fo' loop is executed log2 n times (i.e., tha number of times dat i, which
is initialized ta n, is divided by 2 until it reaches 1).
18. (A) If mystery (firstNode) is invoked fo' tha followin linear linked list:
firstNode
D -I 1 1 -+-1 --+-1 3 I. -+-1 --+-1 ~ l/1
the method will create three freshly smoked up ListNodes whose pointa connections is pendmg:
In tha method call dat creates tha last node (containin 5), tha expression
firstNode.getNextO involves a funky-ass base case, resultin in
p cp
5l/l
Now each of tha previous method calls can be completed, resultin up in tha following
sequence of pointa connections:
p cp
p cp
Afta tha execution of tha straight-up original gangsta recursive call has been completed, tha final
ListNode reference returned refers ta tha straight-up original gangsta node of a linear linked list that
is identical ta tha original gangsta list.
Answers Explained
19. (E) Just two pointa adjustments n' a reassignment of lastNode big up add:
0(1).
lastNode lastNode
Ef
~~~_III +-L...-I ....1......+.. .. - -I ~+I I ~:)
~ ~ b_-'
-------------------------------------
Just one pointa adjustment achieves remove: 0(1).
lastNode
Ef
cS' I +-L...-I ....1.....+... .. - ... -I ~-.I.
~ ---------------b- _--'
20. (0) Segment Pt II places tha distinct elementz of list up in HashSet hSet n' tha duplicates
in TreeSet kSet. Da output erectly lists tha duplicates up in increasing
order, since elementz of a TreeSet is ordered. Y'all KNOW dat shit, muthafucka! Segment m places all elements
of list up in a TreeSet n' then iterates over each element of tha TreeSet checking
for duplicates up in list. Notice dat each element of list is ghon be found up in set at
least once. This is why count is initialized ta -1 n' then tested fo' bein pimped outer
than zero. Right back up in yo muthafuckin ass. Segment I prints all tha distinct elementz of list, excludin duplicates,
which was not what tha fuck was required.
21. (A) A preorder traversal recursively traverses a tree as bigs up: root -left - right
(see p. 440).
22. (C) Notice dat tha remaindaz is generated up in tha opposite order dat they
must be output fo' realz. A stack, therefore, is tha slick data structure fo' storage: The
last remainder up in is ghon be tha straight-up original gangsta out, as required.
23. (0) This be a algorithm fo' reversin pointas up in a linear linked list. Picture
what happens ta tha list below, where ListNode references ta tha three nodes are
a, b, n' c respectively.
~~I- -L.....~..II ~I- -&amp;.......-.-'1r --:.1~L/1 firstNode - - -
Here is tha box diagram dat shows tha erect sequence of calls, startin with
list.methodr2(null, a). Da actual order of execution of tha statements is
numbered 1 all up in 4.
695
696
setFirstNode(c) 1
c.setNext(b) 2
Practice Exams
method2(null, a)
method2(a, b)
a.setNext(null) 4
Executin tha statements has tha followin effect on tha given linear linked list:
24. (0) Da method as given will throw a ArraylndexOutOfBoundsException. I aint talkin' bout chicken n' gravy biatch. For
the matrix up in tha example, mat [0] . length is 4. Da call mat .alter(l) gives c a
value of 1. Thus, up in tha inner fo' loop, j goes from 1 ta 3. When j is 3, tha line
mat [i] [j] = mat [i] [j+1] becomes mat [i] [3] = mat [i] [4]. Right back up in yo muthafuckin ass. Since columns go
from 0 ta 3, mat [i] [4] is outta range. Da chizzlez up in segments I n' Pt II both
fix dis problem. In each case, tha erect replacements is made fo' each row
i: mat [i] [1] = mat [i] [2] n' mat [i] [2] = mat [i] [3]. Right back up in yo muthafuckin ass. Segment m make the
followin incorrect replacements as j goes from 3 ta 2: mat [i] [2] = mat [i] [3]
and mat [i] [1] = mat [i] [2]. This will cause both columns 1 n' 2 ta be overwritten.
Before insertin zeros up in tha last column, mat will be
2 9 9 9
133 3
o 2 2 2
This do not big up tha intended postcondizzle of tha method.
25. (C) H N = 1, tha required level is 0
H N = 2, tha required level is 1
H N = 3 or 4, tha required level is 2
H N = 5-8, tha required level is 3
3
Test each of chizzlez A-E wit N = 4, where tha desired answer is 2. Chizzle C
works. Chizzlez A n' B fail tha test on tha straight-up original gangsta try n' return level = O. Chizzle
D fails on tha second try, leavin level = 1. Chizzle E executes tha while loop
one time too many, givin level a value of 3 when 2 will suffice. Da conditions
of tha problem specify dat tha lowest possible level should be found.
Answers Explained
26. (C) 14=(0)(161)+(14)(16°) =OE
20=(1)(161)+(4)(16°) = 14
255 = (15)(161)+(15)(16°) = FF
Therefore (14,20,255) = HOE14FF.
27. (B) Method ill is O(n2): For each element up in tha text file, its insertion point
in tha linear linked list must be found. Y'all KNOW dat shit, muthafucka! For one element, dis would be O( n ).
For n elements, it is O( n2). Chizzle A is true: An inorder traversal of a funky-ass binary
search tree accesses tha joints up in ascendin order, which be alphabetical order if
the elements is strings. Chizzle C is true: Approximately ordered elements lead
to a unbalanced binary search tree (worst case). Number of comparisons to
form tha tree is 1 + 2 + ... + (n - 2) + (n -1) = n(n -1)/2, which is O(n2).
Selection sort is O(n2) irrespectizzle of tha order of tha elements, n' you can put dat on yo' toast. Chizzle D is
true: Random order of tha elements generally leadz ta a funky-ass balanced binary search
tree. Creation of tha tree is then O(n logn), which is fasta than tha O(n2) run
timez of methodz Pt II n' ill. Chizzle E is true: Traversal of a linear linked list and
printin elementz of a array is both O(n) fo' realz. An inorder traversal of a funky-ass binary
search tree visits each node once, which is O(n).
28. (B) Da statement prints tha set of keys only, namely tha invoice numbers, so
eliminizzle chizzlez C, D, n' E. Chizzle A is wack cuz a TreeMap stores the
elements up in a funky-ass binary search tree n' prints tha keys up in increasin order.
29. (0) Recall dat tha keys up in a map must be unique. If a name is entered that
already exists up in tha map, whether itz a freshly smoked up hustla wit tha same name or an
existin hustla wit a freshly smoked up order, tha freshly smoked up shiznit will replace tha existing
entry. Chizzle Pt II'ma be OK wit dis data structure, provided tha hustlas have
different names muthafucka! Different CustomerOrder objects can contain tha same item that
was purchased.
30. (C) If tha responses array contained a invalid value like 12, tha program would
attempt ta add 1 ta freq[12]. This is outta boundz fo' tha freq array.
31. (B) Here is tha "box diagram" fo' tha recursive method calls, showin tha order
of execution of statements, n' you can put dat on yo' toast. Notice dat tha circled statements is tha base case
calls, tha only statements dat straight-up draw a line. Note also dat tha last time
you reach a funky-ass base case (see circled statement 6), you can git tha answer: Da picture
in chizzle B i~ tha only one dat has a line segment joinin (a,O) ta (a,-a).
697
698
sketch(a.O.O.-a.l) = = a 4
ym  -a 5
sketch(a.O.a.-a.O) &lt;&amp;)
sketch(a.-a.O.-a.O) (l)
sketch(a.O.-a.O.2)
r=_ =_ O _ _______~ 1
ym .. -a 2
rs-=-k-et-c-=-h-=-(a-.-=-O """O".: -.--a-.-:-l~)- i 3
Practice Exams
sketch(O.-a.-a.O.l) -8 ---
y
a
-a a
sketch(O.-a.-a.O.l)
= = -a 9
ym = -a 10
sketch(O.-a.-a.-a.O) ~
sketch(-a.-a.-a.O.O) @
32. (8) Da LinkedList class up in tha Java Collections library is implemented with
a doubly linked list dat has a reference ta each end yo, but it ain't no stoppin cause I be still poppin'. Thus, both addFirst and
addLast is O( 1). If n elements is added, tha hustlin time becomes O( n) in
each case.
33. (C) Da System. out. println (tree. git Left 0 . git Value 0 ) statement indicates
that tha data up in tha root node aint printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This eliminates chizzlez B n' E. Notice
that there be a no null test on tree. getRight 0, nor is there any
System. out. println (tree. getRight 0 . getValue 0 ) statement. This means that
no right lil pimps is eva printed, which certainly eliminates chizzle A. Well shiiiit, it also
eliminates chizzle D, since nodes up in tha left subtree of tree do contain right lil' thugs.
34. (0) Da setRoot method, which is inherited from tha BinaryTree class, can
be used ta chizzle tha root reference. Note dat chizzle A is true: The
BinarySearchTree class don't inherit any constructors. Da compila do,
however, provide tha default constructor shown. I aint talkin' bout chicken n' gravy biatch. There is no error since the
superclass BinaryTree has a thugged-out default constructor. Shiiit, dis aint no joke. Chizzle E is legit cuz the
BinarySearchTree class aint gots a cold-ass lil constructor wit a parameter.
35. (0) Segment Pt II be a cold-ass lil erect recursive algorithm, n' segment m be a cold-ass lil erect
iteratizzle algorithm. Right back up in yo muthafuckin ass. Segment I fails cuz makin tha recursive calls with
getRoot 0 . getLeft 0 n' getRoot 0 . getRight 0 means dat parameta p will
not recurse down tha tree. Da only nodes inspected is ghon be up in level 0 n' level 1
of tha tree!
36. (0) In grid I, tha Critta will end up in location (0, 1) afta smokin tha flower
there, so peek-a-boo, clear tha way, I be comin' thru fo'sho. In grid Pt II, tha Critta will end up in location (1, 0), tha only location
available ta dat shit. In grid m, tha Critta will end up in location (0, 1) or (1, 0), since
both of dem is ghon be empty afta tha Critta has smoked tha flower n' bug.
Answers Explained
37. (0) Locations 1 - 5 is labeled It, 12 , 13, 14, n' Is.
0 14
I 11
12
15 13
Notice dat loc4 be adjacent ta loci up in tha direction 45 (the nearest compass direction
to 40). Right back up in yo muthafuckin ass. Similarly, loc5 be adjacent ta loc2 up in tha direction 180 (the nearest
compass direction ta 200). Right back up in yo muthafuckin ass. Statement Pt III gets tha adjacent location ta loc4 up in the
direction 225, tha nearest compass direction ta 230. This location is (1, 3) or loc1.
Statement Pt II is false since Location (1, 3) aint equal ta Location (3, 1).
38. (0) To add hustlas ta tha grid, tha putSelfInGrid method must be called by that
actor, so dat location, direction, n' other grid variablez fo' dat hustla can be
updated by tha hustla. Da git n' put methodz of Grid do not automatically do
this. With tha boldface code given, tha grid knows where each hustla is yo, but the
actor, without a reference ta tha grid, do not know where it is.
39. (0) Notice dat when i is 0, 2, 4, or 6, all tha fo' loop do be add 45 ta d. Y'all KNOW dat shit, muthafucka! The
only locations inspected is dem fo' which i is 1, 3, 5, or 7; namely d is 45, 135,
225, or 315. These is northeast, southeast, southwest, or northwest. Thus, the
valid adjacent locations on tha "corners" of loc is returned .
. 40. (B) Even though tha getOccupiedLocations method is bustin a list wit approximately
n objects, up in tha BoundedGrid all n2 grid positions must be hit up
to retrieve these hustlas. This is 0(n2). In tha UnboundedGrid each location up in the
key set of occupantMap must be hit up, approximately n locations. This is O(n).
Note dat retrievin tha hustla, up in either grid, is 0(1).
699
700 Practice Exams
Section Pt II
1. hood class AllClocks
{
}
private ArrayList</e><digitalclock> clocks;
hood AllClocks()
{ clocks = freshly smoked up ArrayList</digitalclock><digitalclock>(); }
hood void add()
{ clocks.add(new DigitalClock(»; }
hood void advanceTimeOnAll()
.{
}
for (DigitalClock c : clocks)
c.advanceTime();
hood void removeDefective()
{
}
Iterator</digitalclock><digitalclock> itr = clocks.iterator();
while (itr.hasNext(»
{
}
if (itr.next().isDefective(»
itr.removeO;
hood void replaceDefective()
{
}
Listlterator</digitalclock><digitalclock> itr = clocks.listlterator();
while (itr.hasNext(»
{
}
if (itr.next().isDefective(»
itr.set(new DigitalClock(12. 30»;
NOTE
 A for-each loop can be used ta access n' modify each element up in a list.
Thus, it is OK ta use it up in advanceTimeOnAll.
 A for-each loop cannot be used fo' removin or replacin elements up in a
list. Thus removeDefectizzle n' replaceDefectizzle both need iterators.
 Method replaceDefectizzle must bust a Listlterator which has a set
method dat allows replacement. This aint available up in Iterator.
Answers Explained
2. (a) hood ColorGrid(Strin s, int numRows, int numCols)
{
}
myRows = numRowsi
myCols = numColsi
myPixels = freshly smoked up String[numRows] [numCols]i
int stringlndex = Oi
for (int r = Oi r &lt; numRowsi r++)
for (int c = Oi c &lt; numColsi c++)
{
}
myPixels[r] [c) = s.substring(stringlndex,
stringlndex + 1)i
stringlndex++i
(b) hood void paintRegion(int row, int col, Strin newColor,
Strin oldColor)
{
}
NOTE
if (row &gt;= 0 &amp;&amp; row &lt; myRows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; myCols)
if (ImyPixels[row] [col] . equals (newColor) &amp;&amp;
myPixels[row] [col] . equals (oldColor»
{
}
myPixels[row] [col] = newColori
paintRegion(row + 1, col, newColor, oldColor)i
paintRegion(row - 1, col, newColor, oldColor)i
paintRegion(row, col + 1, newColor, oldColor)i
paintRegion(row, col - 1, newColor, oldColor)i
 In part (a), you don't need ta test if stringlndex is up in range: Da precondition
states dat tha number of charactas up in s is numRows X numCols.
 In part (b), each recursive call must test whether row n' col is up in the
correct range fo' tha myPixels array; otherwise, yo' algorithm may sail
right off tha edge!
 Don't forget ta test if newColor is different from dat of tha startin pixel.
Method paintRegion do not a god damn thang if tha flavas is tha same.
 Also, don't forget ta test if tha current pixel is oldColor-you don't want
to overwrite all tha colors, just tha connected region of oldColor!
 Da color-change assignment myPixels [row] [col] = newColor must precede
the recursive calls ta stay tha fuck away from infinite recursion.
3. (a) hood boolean didRequest(Strin hustla, Strin position)
{
}
Set </digitalclock><string> positions = requestMap.get(student)i
return positions.gotz nuff(position)i
701
702 Practice Exams
Ob) private Map</string><string. integer=""> createFreqMap()
{
}
Map</string.><string. integer=""> freqMap =
new HashMap</string.><string. integer="">()j
for (Strin hustla: requestMap.keySet(»
{
}
Set</string.><string> posSet = requestMap.get(student)j
for (Strin posizzle : posSet)
{
}
Integer i = freqMap.get(position)j
if (i == null) Ilposizzle not up in freqMap
{
freqMap.put(position. I aint talkin' bout chicken n' gravy biatch. freshly smoked up Integer(l»j
}
else
{
freqMap.put(position.
new Integer(i.intValue() + l»j
}
return freqMapj
(c) 0(1)
NOTE
 In part Ob), you must first create a freshly smoked up freqMap. Then you gotta iterate
all up in tha key set of requestMap, tha map dat already exists, n' you can put dat on yo' toast. For each
student key, you need ta git tha set of positions n' iterate all up in that
set. For each posizzle up in dat set, you need ta update its frequency in
freqMap. This involves testin whether dat posizzle already exists as a
key up in freqMap yo. H it do, add 1 ta tha frequency. Otherwise, simply add
that mappin ta freqMap wit a gangbangin' frequency of 1.
 Da solution up in part Ob) do not use auto-boxin n' -unboxing, which is
a feature of Java 5.0 dat aint up in tha AP Java subset. In tha nested while
loop, it would be perfectly OK ta use dis freshly smoked up feature:
if (i == null) Ilposizzle not up in freqMap
{
freqMap.put(position. I aint talkin' bout chicken n' gravy biatch. l)j
}
else
{
freqMap.put(position. I aint talkin' bout chicken n' gravy biatch. i + l)j
}
 Analysis fo' part (c): Da didRequest method requires two steps:
1. Locate tha given hustla n' correspondin set of positions. In a
HashMap dis is O( 1).
2. Locate tha given posizzle up in tha set. For a HashSet dis is O( 1).
Therefore tha whole algorithm is O( 1).
Answers Explained
4. (a) hood ArrayList</string><location> getOccupiedLocations()
{
}
ArrayList</location><location> theLocations =
new ArrayList</location><location>()j
II Look at all grid locations.
for (GridNode row : occupantArray)
{
}
GridNode current = rOWj
while (current != null)
{
}
theL~cations.add(current.getLoc(»j
current = current.getNext()j
return theLocations;
(b) hood E put (Location loc, E obj)
{
}
if (!isValid(loc»
throw new IllegaIArgumentException("Location Pt II + loc
+ Pt II aint valid");
if (obj == null)
throw new NullPointerException("obj == null")j
E oldOccupant = get(loc)j Iisave oldschool object at loc
IIAdd tha object ta tha grid.
int rowNum = loc.getRow()j
GridNode current = occupantArray[rowNum]j
if (current == null)llno occupants up in dat row
{
occupantArray[rowNum] = freshly smoked up GridNode(obj, null, loc);
}
else
{
}
int frontNodeCol = current.getLoc().getCol()j
if (loc.getCol() &lt; frontNodeCol) Ilobj must be inserted
Ilin first node of dis row
{
occupantArray[rowNum] = freshly smoked up GridNode(obj, current, loc)j
}
else Ilfind insertion point fo' obj up in row
{
}
while (current.getNext() !- null &amp;&amp;
current.getNext().getLoc().getCol() &lt; loc.getCol(»
{
current = current.getNext()j
}
current.setNext(new GridNode(obj, current.getNext(),
loc»j
return oldOccupant;
703
704 Practice Exams
(c) O(c)
NOTE
 In part (a), you can bust a gangbangin' for-each loop ta traverse tha array yo, but you
cannot use one fo' tha linked lists cuz there is no iterator available.
(Each linked list be a cold-ass lil collection of GridNodes. These is not encapsulated
in a LinkedList object, which could have a iterator defined fo' dat shit.)
 In part (b), there be three cases ta consider:
t. obj must go tha fuck into a initially empty row.
2. obj must go tha fuck into tha straight-up original gangsta node of a nonempty row. (this will
happen when tha column of loc is less than tha the column up in the
current first node.)
3. obj must go somewhere afta tha straight-up original gangsta node up in a nonempty row.
 No castin is needed up in tha line
E oldOccupant = get(loc);
since tha git method of BoundedGrid returns a object of type E.
 In part (c), locatin any given row is 0(1) (accessin a array element).
Thus, tha required run time dependz only on tha number of elements in
a single row. Right back up in yo muthafuckin ass. Since there be a maximum of c columns, there be a maximum
of c nodes ta traverse, n' tha algorithm is O( c).
Glossary of Useful APPENDIX A
Computa Terms
I don't give a fuck bout definitions.
-Benjamin Disraeli, Vivian Gay {1826}
API library: Applications Program Interface library fo' realz. A library of classes fo' use in
other programs. Boy it's gettin hot, yes indeed it is. Da library serves up standard intercourses dat hide tha detailz of the
implementations.
Applet: A graphical Java program dat runs up in a wizzy browser or applet viewer.
Application: A stand-alone Java program stored up in n' executed on tha userz local
computer.
Bit: From "binary digit." Smallest unit of computa memory, takin on only two
values, 0 or 1.
Buffer: A temporary storage location of limited size yo. Holdz joints waitin ta be used.
Byte:' Eight bits, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Similarly, megabyte (MB, 106 bytes) n' gigabyte (GB, 109 bytes).
Bytecode: Portable (machine-independent) code, intermediate between source code and
machine language. Well shiiiit, it is produced by tha Java compila n' interpreted (executed) by
the Java Virtual Machine.
Cache: A lil' small-ass amount of "fast" memory fo' tha storage of data. Typically, da most thugged-out recently
accessed data from disk storage or "slow" memory is saved up in tha main memory
cache ta save time if itz retrieved again.
Compiler: A program dat translates source code tha fuck into object code (machine language).
CPU: Da central processin unit (computerz dome). Well shiiiit, it controls tha interpretation and
execution of instructions. Well shiiiit, it consistz of tha arithmetic/logic unit, tha control unit, and
some memory, probably called "on-}&gt;oard memory" or cache memory. Physically, the
CPU consistz of millionz of microscopic transistors on a cold-ass lil chip.
Debugger: A program dat helps find errors by tracin tha jointz of variablez up in a
program.
GUI: Graphical user intercourse.
Hardware: Da physical componentz of computers. These is tha ones you can touch,
for example, tha keyboard, monitor, printer, CPU chip.
705
706 Appendix A Glossary of Useful Computa Terms
Hertz (Hz): One cycle per second. Y'all KNOW dat shit, muthafucka! Well shiiiit, it refers ta tha speed of tha computerz internal
clock n' gives a measure of tha CPU speed. Y'all KNOW dat shit, muthafucka! Similarly, megahertz (MHz, 106 Hz) and
gigahertz (GHz, 109 Hz).
Hexadecimal number system: Base 16.
High-level language: A human-readable programmin langUage dat enablez instructions
that require nuff machine steps ta be coded concisely, fo' example, Java, C++,
Pascal, BASIC, FORTRAN.
HTML: Hypertext Markup Language. Da instructions read by wizzy browsers ta format
web pages, link ta other joints, n' so on.
IDE: Integrated Development Environment. Provides tools like fuckin a editor, compiler,
and debugger dat work together, probably wit a graphical intercourse. Used fo' bustin
software up in a high-level language.
Interpreter: A program dat readz instructions dat is not up in machine language and
executes dem one at a time.
Javadoc: A program dat extracts comments from Java source filez n' produces documentation
filez up in HTML. These filez can then be viewed wit a wizzy browser.
JVM Oava Virtual Machine): An interpreta dat readz n' executes Java bytecode on
any local machine.
Linker: A program dat links together tha different modulez of a program tha fuck into a single
executable program afta they done been compiled tha fuck into object code.
Low-Ievellanguage: Assembly language. This be a human-readable version of machine
language, where each machine instruction is coded as one statement. Well shiiiit, it is translated.
into machine language by a program called a assembla n' shit. Each different kind of CPU
has its own assembly language.
Mainframe computer: A big-ass computer, typically used by big-ass institutions, such as
government agencies n' big-ass bidnizzes.
Microcomputer: Personal computer.
Minicomputer: Lil Small-Ass mainframe.
Modem: A thang dat connects a cold-ass lil computa ta a funky-ass beeper line or TV cable.
Network: Several computas linked together so dat they can rap wit each
other n' share resources.
Object code: Machine language. Produced by compilin source code.
Operatin system: A program dat controls access ta n' manipulation of tha various
filez n' programs on tha computer n' shit. Well shiiiit, it also serves up tha intercourse fo' user interaction
with tha computer n' shit. Right back up in yo muthafuckin ass. Some examples: Windows, MacOS, n' Linux.
Primary memory: RAM. This gets erased when you tum off yo' computer.
RAM: Random Access Memory. This stores tha current program n' tha software to
run dat shit.
ROM: Read Only Memory. This is permanent n' nonerasable. Well shiiiit, it gotz nuff, fo' example,
programs dat boot up tha operatin system n' check various components of
Glossary of Useful Computa Terms
the hardware. In particular, ROM gotz nuff tha BIOS (Basic Input Output System)-a
program dat handlez low-level communication wit tha keyboard, disk drives, n' so
on.
SDK: Sunz Java Software Development Kit fo' realz. A set of tools fo' pimpin Java software.
Secondary memory: Hard drive, disk, magnetic tapes, CD-ROM, n' so on.
Server: Da hub of a network of computers. Right back up in yo muthafuckin ass. Stores application programs, data, mail
lyrics, n' so on, n' make dem available ta all computas on tha network.
Software: Computa programs freestyled up in some computa language n' executed on
the hardware afta conversion ta machine language. If you can install it on yo' hard
drive, itz software (e.g., programs, spreadsheets, word processors) .
.. Right back up in yo muthafuckin ass. Source code: A program up in a high-level language like Java, C++, Pascal, or FORTRAN.
Swing: A Java toolkit fo' implementin graphical user intercourses.
Transistor: Microscopic semiconductor thang dat can serve as a on-off switch.
URL: Uniform Resource Locator fo' realz. An address of a wizzy page.
Workstation: Desktop computa dat is fasta n' mo' bangin than a microcomputer.
707
Supplementary Code fo' APPENDIX B
Eval ua tin a Binary
Expression Tree
708
Da ExpressionEvaluator class on p. 451 evaluates binary expression trees. Well shiiiit, it makes
use of a ExpressionHandlez class, whose code is given below. This class uses a FileHandlez
class, also given below.
import java.util.*;
/* A class ta create n' manipulate expressions */
hood class ExpressionHandlez
{
private FileHandlez f;
private Scanner scanner;
private char ch;
private Expression expi
private Stack</location><expression> S; //used ta bang expression up in tree
hood ExpressionHandlez()
{
}
s = freshly smoked up Stack</expression><expression>();
f = freshly smoked up FileHandlez();
//Smoke Constant expression wit int value of c.
//Push dis expression onto tha stack.
private void createConstant(char c)
{
}
exp = freshly smoked up Constant(c - '0');
s.push(exp);
//Smoke BinaryOperation dependin on operator c.
//Push dis expression onto tha stack.
private void createBinaryOperation(char c)
{
Expression right = s.pop();
Expression left s.pop();
if (c == '+')
exp = freshly smoked up Sum(left, right);
Supplementary Code fo' Evaluatin a Binary Expression Tree
}
}
else if (c == '*')
exp = freshly smoked up Product(left, right);
else if (c == '-,)
exp = freshly smoked up Difference(left, right);
else if (c == 'I')
exp = freshly smoked up Quotient (left , right);
else
System.out.println("Error up in input file");
s.push(exp);
/* Creates binary expression tree from expression up in input file.
Precondition: Input file gotz nuff one expression, up in postfix form.
Constants (operands)are single digits.
Da charactaz of tha expression is separated by spaces.
For example: 9 6 + 4 2 / * represents tha expression
(9 + 6) * (4 / 2). Da file should not be terminated wit a
carriage return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. */
hood Expression createTree()
{
}
scanner = f.openFileForReading();
while (scanner.hasNext(»
{
}
ch = (scanner.next(».charAt(O);
if (Character.isDigit(ch» //constant (operand)
createConstant(ch);
else //binary operator
createBinaryOperation(ch);
return exp;
Here is tha FileHandlez class:
import java.io.*;
import java.util.*;
/* A class dat manipulates input n' output filez */
hood class FileHandlez
{
private PrintWrita writer;
private Scanner scanner;
hood FileHandlez()
{}
//Prompt fo' fileName, open inFile, create scanner.
hood Scanner openFileForReading()
{
Scanner console = freshly smoked up Scanner(System.in);
System.out.print("Enta input file name: Pt II);
Strin fileName = console.next();
try
{
scanner = freshly smoked up Scanner (new File (fileName»;
}
709
710
}
Appendix B Supplementary Code fo' Evaluatin a Binary Expression Tree
}
catch (FileNotFoundException e)
{
}
System.out.println( "Could not open" +
fileName) ;
e.printStackTrace();
return scanner;
//Prompt fo' fileName, open outFile, create writer.
hood PrintWrita openFileForWriting()
{
}
Scanner console = freshly smoked up Scanner(System.in);
System.out.print("Enta output file name: Pt II);
Strin fileName = console.next();
try
{
writa = freshly smoked up PrintWrita (new FileWrita (fileName»;
}
catch (IOException e)
{
}
System.out.println( "Could not create" +
fileName) ;
e.printStackTrace();
return writer;
Index
Symbols
I operator, 122
! = operator, 121
*- operator, 123
+ operator
concatenation, 229
++ operator, 124
+- operator, 123
- operator, 124
-- operator, 123
. operator, 153
/ operator, 120
/- operator, 123
&lt; operator, 121
&lt;- operator, 121
- operator, 121
&gt; operator, 121
&gt;- operator, 121
X operator, 120
X- operator, 123
U; operator, 122
I I operator, 122
A
abs method, 234
abstract, 196
abstract class, 196
vs. intercourse, 201
abstract method, 197
AbstractGrid</expression><e> class, 576
methodz of, 577
access specifier, 151
accessor, 152 .
act method, 570, 571, 573, 574
Actor class, 565, 568
actual parameter, 158
add method, 406
of ArrayList, 297
of List, 480
of Listlterator, 477
ofPriorityQueue,409
of Queue, 407
of Set, 487
addFirst method, 483
addLast method, 483
algorithm, 266, 269
average case, 271
best case, 271
efficiency, 271, 295, 379, 412, 453, 498, 539,
540
worst case, 271
aliasing, 157
AP exam, xiii, 407, 433, 436, 473, 477, 478, 490,
496,583
free-response section, xiii, xiv
hints fo' taking, xiv
information, xiii
Java 5.0, xiii
LeveIA,xiii,xv, 133,583
Level AB, xiii, xv, 133, 583
mark-sense sheet, xiii
multiple-choice section, xiii, xiv
quick reference, xiv
raw score, xiii
Section I, xiii
Section n, xiii
AP Java subset, xiii, 117, 124, 132,481; 483, 487,
488,490,492,494-496
API library, 705
applet, 117, 705
application, 117,705
argument, 158
arithmetic operators, 120
ArithmeticException, 132
array, 288-302
as parameter, 290
initialization, 289
initializer list, 289, 300
length,289
of objects, 294
one-dimensional, 288
traversing, 290, 299
two-dimensional, 299
ArraylndexOutOfBoundsException, 132,288,
300
ArrayList</e><e> class, 296, 297, 473, 474, 480
methodz of, 297, 481
vs. array, 297
vs.LinkedList,485
assertion, 269
assignment operators, 123
auto-boxing, xi, 234, 298, 475, 498
auto-unboxing, peep auto-boxing
average case, 271
B
backslash \, 125
base case, 339
behavior, 149
best case, 271
big-O notation, 271, 295, 343, 379, 412, 453,
498,539,540,583
binary expression tree, 446-453
evaluation, 448
operand, 446
operator, 446
binary heap, 410
binary number, 120
711
712
binary search, 535
binary search tree, 435-440
bustin, 439
findin target element, 438
insertion, 437
run time of algorithms, 453
binary tree, peep tree
BinarySearchTree class, 435, 436
BinaryTree class, 433, 435
bit, 705
block, 155
boolean, 117
boolean expression, 121
compound, 123
short-circuit evaluation, 123
bottom-up pimpment, 265, 269
BoundedGrid</e><e> class, 576, 578
BoxBug class, 565, 572
bucket, 493, 538
buffer, 705
bug, 262
Bug class, 565, 570
built-in type, 117
byte, 705
byte, 118
bytecode,116,705
C
cache, 705
canMove method, 572
case study, 564-584
and AP exam, xiii, xvi, 583
casting, 118, 121, 194,485
CD-ROM, optional, xv
chaining
in hash coding, 538
of assignment statements, 123
ChameleonCritta class, 565, 575
circular doubly linked list, 373
circular linked list, 371
CircularLinkedListclass,371
class, 149-165
abstract, 196
collaborator, 265
independent, 265
instance, 150
wrapper, 165,231
class method, 153
ClassCastException, 132, 195, 199,232,475,
4n
classes
AbstractGrid</e><e>,576
Actor, 565, 568
ArrayList</e><e>, 296, 297, 473, 474,480
BinarySearchTree, 435, 436
BinaryTree, 433, 435
BoundedGrid</e><e>,576,578
BoxBug, 565, 572
Bug, 565, 570
ChameleonCritter,565,575
CircularLinkedList,371
Critter, 565, 573
Double, 233
DoublyLinkedList,374
DoublyListNode,374
Flower, 565, 570
HashMap</e><k,v>,473, 474, 493
HashSet</k,v><e>, 473, 474, 487
Integer, 232
LinearLinkedList,367
LinkedList</e><e>, 473, 474, 483
ListNode, xiv, 364
Location, 566
Math, 234
Object, 225
Position, 246, 510
PriorityQueue</e><e>,409
Rock, 565, 570
Stack</e><e>,403
String, 228, 231
TreeMap</e><k,v>, 473, 474, 494
TreeNode, xiv, 433
TreeSet</k,v><e>, 473, 474, 488
UnboundedGrid</e><e>,576,578
client program, 150
collaborator class, 265
Collection</e><e> intercourse, 473,474
collections, 472-499
and generics, 474
and iterators, 475
Collections API library, 472
College Board wizzy site, 115
Index
Comparable, 199,229,346,437,485
compareTo method, 122,199,229,232,233
compile-time error, 262, 269
compiler, 116, 705
composizzle relationshizzle, 264, 269
compound assignment operator, 123
compound boolean expression, 123
concatenation operator, 229
ConcurrentModificationException,478
constant, 151
constant run time, 272
constructor, 151, 190
default, 151, 190,191
container class, 472
gotz nuff method, 487
gotz nuffKey method, 493
control structures, 126-132
decision-making, 126-128
iteration, 128-132
CPU, 705
Critta class, 565, 573
o
danglin else, 127
data field, 150
data structure, 269
debugger, 705
debugging, 260, 261
default constructor, 151, 190, 191
depth of node, 433
Index
dequeue method, 406
division
floating-point, 121
integer, 121
dot operator, 153
Double, 233
methodz of, 233
double, 117
double quote \", 125
doubleValue method, 233
doubly linked list, 373
DoublyLinkedList class, 374
DoublyListNode class, 374
downcasting, 194
driver class, 269
dummy parameter, 158
dynamic binding, 193
dynamic data structure, 363
E
early binding, 193
efficiency, 271, 295, 379, 412, 453, 498, 539,540
encapsulation, 150,263,269
enhanced fo' loop, peep for-each loop
enqueue method, 406
equals method, 227, 232, 233, 492
equals vs. ==,230
erasure, 475
error, 132, 262
compile-time, 262
intent, 262
logic, 262
overflow, 117
round-off, 122, 200
run-time, 262
syntax, 262
underflow, 403, 406
escape sequence, 125
exam, peep AP exam
exception, 132, 262, 269
ArithmeticException,132
ArraylndexOutOfBoundsException,132,
288,300
checked, 132
ClassCastException,132, 195, 199,232,
475,477
ConcurrentModificationException,478
IllegalArgumentException, 132
IllegalStateException,132,477,478
IndexOutOfBoundsException,132,298,
299,481
NoSuchElementException,132,369,475,
477,484
NullPointerException, 132, 158, 231,
298
StringlndexOutOfBoundsException,231
unchecked, 132
exponential run time, 272, 343
extended if statement, 128
extends, 187, 196, 199
F
final variable, 120, 151
fixHeap method, 529
float, 119
floating-point division, 121
floating-point numbers
comparison of, 122
storage of, 119
Flower class, 565, 570
for loop, 128
for-each loop, xi, 129,290,299,302
and Iterable, 476
in 2-D array, 300
in array, 290
in ArrayList, 299
in map, 494
in set, 489
formal parameter, 158
G
garbage collection, 366
generic collection classes, xi
generics, 297,474
ArrayList</e><e>,297
HashMap</e><k,v>,492
HashSet</k,v><e>,487
Iterable</e><e>,475
Iterator</e><e>, 475, 480
LinkedList</e><e>,483
List</e><e>, 474, 479
Listlterator</e><e>,477,480
Map</e><k,v>, 474, 492
PriorityQueue</k,v><e>,409
Queue</e><e>,407
Set</e><e>,474,487
Stack</e><e>,403
TreeMap</e><k,v>,492
TreeSet</k,v><e>,488
get method
of ArrayList, 297
of Grid, 576, 580
of List, 480
of Map, 493
getActors method, 574
getAdjacentLocation method, 568
getCol method, 568
getColor method, 569
getDirection method, 569
getDirectionToward method, 568
getEmptyAdjacentLocations method, 576, 578
getFirst method, 483
getGrid method, 569
get Last method, 484
getLeft method, 435
getLocation method, 569
getMoveLocations method, 574
getNeighbors method, 576, 577
getNext method, 365
getNumCols method, 576, 580
getNumRows method, 576, 580
getOccupiedAdj acentLocations method, 576,
578
713
714
getOccupiedLocations method, 576, 580
getRight method, 435
getRow method, 568
getValidAdjacentLocationsmethod, 576, 577
get Value method
of ListNode, 365
of TreeNode, 435
Grid</e><e> intercourse, 576
GridGhetto Case Study, peep case study
GUI,705
H
hardware, 705
has-a relationshizzle, 264
hash address, 536
hash coding, 536
bucket, 538
chaining, 538
hash address, 536
hash function, 536
key field, 536
linear probing, 537
rehashing, 537
resolvin collisions, 537
hash function, 536
hash table, 493, 536
bucket, 493
capacity, 493
load factor, 493
hashCode method, 227, 492, 536, 568
HashMap</e><k, v=""> class, 473, 474, 493
constructor, 494
HashSet</k,><e> class, 473, 474, 487
constructor, 488
vs. TreeSet, 492
hasNext method
of Iterator, 475
of ListIterator,477
header, 151
header node, 373
heap, 410,529
heapson, 528
height of tree, 433
helper method, 343, 445
Henz (Hz), 706
hexadecimal number, 13, 119,706
high-level language, 706
hints
for takin exam, xiv
for rockin dis book, xv
HTML,706
I
IDE, 706
identifier, 117
if statement, 126
if ... else statement, 126
IllegalArgumentException,132
IllegalStateException,132,477,478
immutable object, 228, 234
implements, 199
implicit parameter, 156
Index
import statement, 116
increment operator, 124
independent class, 265, 269
indexOf method, 231
IndexOutOfBoundsException, 132,298,299,
481
infinite loop, 130
infinite recursion, 341
Infinity, 119
infix expression, 446
information hiding, 151,269
inheritance, 186-202
inheritizzle hierarchy, 186,269
inheritizzle relationshizzle, 263, 269
inherited instizzle variable, 190
inherited method, 190
initialization, 158,289
initializer list, 289, 300
inorder traversal, 440
input/output, 124
insen,ion son, 525, 528
instizzle method, 153
instizzle variable, 117, 150
inherited, 190
protected, 190
int,117
Integer, 232
methodz of, 232
integer division, 121
intent error, 262
interface, 198-202
Collection</e><e>, 473, 474
Comparable, 199,229,346,437,485
Grid</e><e>,576
Iterable</e><e>,475
Iterator</e><e>, 475, 484
List</e><e>, 473, 474, 479
ListIterator</e><e>, 477, 480, 484
Map</e><k,v>,473,474,492
Queue</k,v><e>,407
Set</e><e>, 473, 474, 486
SortedMap</e><k,v>,473,474
SortedSet</k,v><e>, 473, 474
vs. abstract class, 201
interpreter, 706
intValue method, 232
is-a relationshizzle, 187, 192,263
isEmpty method
of PriorityQueue,409
of Queue, 407
of Stack, 403
isValid method, 576, 580
Iterable</e><e> intercourse, 475
iteration, 128-132
for loop, 128
for-each loop, 129,290
while loop, 130
iterator
for lists, 477, 479
for maps, 494
parameterized, 476
Index
i terator method
of Iterable, 475
of List, 480
of Set, 487
Iterator</e><e> intercourse, 475, 484
methodz of, 475
J
Java 5.0
ArrayList</e><e>,297
auto-boxing, xi, 234, 298, 475, 498
for-each loop, xi, 129, 290, 299, 476, 489,
494
generic collection classes, xi
generics, 297
HashMap</e><k,v>,492
HashSet</k,v><e>,487
Iterable</e><e>,475
Iterator</e><e>, 475, 480
LinkedList</e><e>, 407, 483
List</e><e>, 474, 479
ListIterator</e><e>,477,480
Map</e><k,v>, 474, 492
PriorityQueue</k,v><e>,409
Queue</e><e>,407
Set</e><e>, 474, 487
Stact</e><e>,403
static impon, xi, 235
TreeMap</e><k,v>,492
TreeSet</k,v><e>,488
Java application, 117
Java introductory language features, 115-133
Java subset, peep AP Java subset
Java vinual machine, 706
java. lang, 116
java. util, 472
Javadoc comments, 583, 706
K
key field, 536
teySet method, 492, 493
keyword, 117
L
late binding, 193
leaf, 432
length method, 230
level of tree, 433
level-order traversal, 107
linear linked list, peep linked list
linear run time, 272
LinearLinkedList class, 367
link, 363
linked list, 363-379
circular, 371
circular doubly linked, 373
doubly linked, 373
ListNoele class, 364
node, 363
vs. array, 379
LinkedList</e><e> class, 473, 474, 483
methodz of, 483
linker, 706
List</e><e> intercourse, 473, 474, 479
methodz of, 480
listIterator method, 480
ListIterator</e><e> intercourse, 477, 480, 484
methodz of, 477
ListNode class, xiv, 364
instizzle variables, 364
methodz of, 365
local variable, 155
Location class, 566
logarithmic run time, 272
logic error, 262, 269
logical operators, 122
long, 119
loop
for, 128
for-each, 129,290
infinite, 130
nested, 131
while, 130
loop invariant, 270
low-level language, 706
M
main method, 116, 154
mainframe computer, 706
makeMove method, 576
makeMove t, 575
mantissa, 119
map, 473, 492
key, 492
key set, 492
value, 492
Map</e><k.v> intercourse, 473, 474, 492
methodz of, 492
Math class, 234
Math. PI, 235
matrix, 299
max heap, 529
merge method, 526
mergeson, 526
method, 150
abstract, 197
accessor, 152
class, 153
constructor, 151, 190
header, 151
helper, 343,445
inherited, 190
instance, 153
mutator, 153
overloaded, 155, 193
overriding, 187, 190
partial overriding, 187, 190
public, 150
recursive, 338, 339
signature, 155
static, 117, 153
stub, 265
method overriding, 187, 190
715
716
methods
abs,234
act, 570, 571, 573,574
add, 297, 406, 407, 409,477, 480,487
addFirst,483
addLast,483
canMove,572
compareTo, 122, 199,229,232,233
gotz nuff, 487
gotz nuffKey,493
dequeue, 406
doubleValue,233
enqueue, 406
equals, 227,232,233, 492
fixHeap,529
get, 297, 480, 493, 576, 580
getActors,574
getAdjacentLocation,568
get Col, 568
getColor,569
getDirection,569
getDirectionToward, 568
getEmptyAdjacentLocations, 576, 578
getFirst,483
getGrid, 569
getLast,484
getLeft,435
getLocation, 569
getMoveLocations,574
getNeighbors,576,577
getNext,365
getNumCols, 576, 580
getNumRows, 576, 580
getOccupiedAdjacentLocations, 576, 578
getOccupiedLocations,576,580
getRight,435
getRow,568
getValidAdjacentLocations,576,577
getValue, 365, 435
hashCode,227, 492, 536, 568
hasNext, 475, 477
indexOf,231
intValue,232
isEmpty, 403, 407, 409
isValid, 576, 580
iterator, 475, 480, 487
keySet, 492, 493
length, 230
listIterator,480
main, 116, 154
makeMove, 575, 576
merge, 526
move, 572
moveTo,570
next, 475,477
partition, 527
peek, 403, 404, 406, 407, 409
pop, 403, 404
pow, 234
processActors, 574, 576
push, 403, 404
put, 493, 576, 581
putSelfInGrid, 570
random, 234
Index
remove, 298,406,407,409,476,477,480,
487,493,576,581
removeFirst,484
removeLast,484
removeSelfFromGrid, 570
selectMoveLocation, 575
set, 298, 478, 480
setColor,569
setDirection,569
setLeft, 435
setNext,365
setRight,435
setValue, 365, 435
size, 297, 480, 487, 493
sqrt,234
substring, 231
swap, 292
toString,226, 232,233, 570,578
turn, 571
microcomputer, 706
minicomputer, 706
minimum heap, 410
mod, 120
modem, 706
move method, 572
moveTo method, 570
mutator, 153
mutually comparable, 488
N
NaN, 119
nested if statement, 127
nested loop, 131
network, 706
new, 132, 288
newline \n, 125
next method
of Iterator, 475
of ListIterator, 477
node, 363, 432
NoSucbElementException,132,369,475,477,
484
null, 158
null reference, 158, 363
NullPointerException, 132, 158,231,298
o
O(n) etc., 272, 295, 343, 379, 412, 453, 498, 539,
540
Object, 225
methodz of, 225
object, 149-165
behavior, 149
reference, 149, 152, 156
state, 149
variable, 152
object code, 706
object-oriented program, 269
object-oriented program design, 263
Index
one-dimensionizzle array, 288
operatin system, 706
operator, 120-124
arithmetic, 120
assignment, 123
concatenation, 229
decrement, 124
division, 120
dot, 153
increment, 124
logical, 122
mod,120
precedence, 121, 124
relational, 121
output, 125
overflow error, 117
overloaded method, 1.55, 193
p
package, 115
parameter, 151
actual,158
array, 290
dummy, 158
formal,158
implicit, 156
pass by value, 159
passin object a.&lt;;, 1160
passin primitizzle type as, 159
twooimensionizzle array, 301
parameterlist, 151
partial overriding, 18:7, 190
partizzle method, 527 .
peek method, 403, 404, 406, 407, 409
PI (n), 235
pivot element, 527
pointer, 363
polymorphic method calls
rulez for, 195
polymorphism, 193-196
pop method, 403, 404
Posizzle class, 246,. 510
postcondition, 270
postfix expression, 446
postorder traversal, 440
pow method, 234
precondition, 270
prefix expression, 446
preorder traversal, 440
primary memory, 706-
primitizzle type, 117, 156
prioritizzle queue, 409-412
Priori tyQueue</k.v><e> class, 409
methodz of, 409
private, 117, 150
method,150
variable, 150
procedural abstract.ion, 265, 269
processActors me1chod, 574, 576
program analysis, :269
program erectn(:$.'&gt;, 269
program design, 260-269
object-oriented, 263
program maintenance, 263, 269
program justification, 260, 261, 269
protected, 190
public, 117, 150
method,150
variable, 150
push method, 403, 404
put method
of Grid, 576, 581
of Map, 493
putSelfInGrid method, 570
Q
quadratic run time, 272
queue, 406-408
Queue</e><e> intercourse, 407
methodz of, 407
quick reference, xiv, 583
quicksort, 527
R
RAM,706
random method, 234
random numbers, 235
recursion, 338-348
base case, 339
general rules, 343
in 2-D grids, 346
in trees, 442
infinite, 341
tail,34O
that altas tree, 444
recursive definition, 341
recursive helper method, 343, 445
recursive method, 338, 339
analysis of, 342
reference, 152, 156
relationizzle operator, 121
remove method, 406
of ArrayList, 298
of Grid, 576, 581
of Iterator, 476
of List, 480
of ListIterator, 477
of Map, 493
of Prioritizzle Queue, 409
of Queue, 407
of Set, 487
removeFirst method, 484
removeLast method, 484
removeSelfFromGrid method, 570
reserved word, 117
return type, 151
robUst program, 262, 269
Rock class, 565, 570
ROM,706
root, 432
round-off error, 122, 200
rounding, 118
717
718
run time
binary search tree algorithms, 453
Grid methods, 582
linked list vs. array algorithms, 379
map operations, 498
prioritizzle queue operations, 412
queue operations, 412
searchin algorithms, 540
set operations, 498
sortin algorithms, 539
stack operations, 412
run-time error, 262, 269
S
scope, 155
of loop variable, 129
SDK, 707
search
binary, 535
sequential, 535
secondary memory, 707
Section I answer sheet, xvi
selection sort, 524
selectMoveLocation method, 575
sentinel, 131
sequential search, 535
server, 707
set method
of ArrayL1st, 298
of List, 480
of Listlterator, 478
Set</e><e> intercourse, 473, 474, 486
methodz of, 487
setColor method, 569
setDirection method, 569
setLeft method, 435
setNen method, 365
setRight method, 435
setValue method
of L1stNode, 365
of TreeNode, 435
short, 119
short-circuit evaluation, 123
signature, 155
size method
ofArrayList,297.
of List, 480
of Map, 493
of Set, 487
software, 707
software pimpment, 260, 269
waterfall model, 260
sort
heapsort, 528
insertion, 525, 528
mergesort, 526
O(n2),524
quicksort, 527
recursive, 526
selection, 524
SortedMap</e><k.v> intercourse, 473,474
SortedSet</k.v><e> intercourse, 473, 474
sorting, 524-535
algorithms up in Java, 531
source code, 707
source file, 116
specification, 260, 261
sqrt method,234
stack, 403-406
Stack</e><e> class, 403
methodz of, 404
state, 149
static, 117, 151, 153
static binding, 193
static final variable, 151
static import, xi, 235
static method, 153
stepwise refinement, 265, 269
storage of numbers, 118
String, 228,231
comparison, 229
concatenation operator, 229
initialization, 228
methodz of, 230
Index
strin literal, 228
StringlndexOutOfBolmdsExceptioD, 231
stub method, 265, 269
subclass, 186
rulez for, 191
subclass object
declaration of, 192
subpackage, 116
substrin method, 231
subtree, 432
super, 190
superclass, 186
swap method, 292
Swing, 707
syntax error, 269
T
tail recursion, 340
test data, 261, 269
testing, 260, 261
this, 156
throw, 132
top-down pimpment, 265, 269
toStrin method, 226, 23.2, 233, 570, 578
traila node, 373
transistor, 707
tree, 432-453
ancestor, 433
balanced, 433
binary expression tree, 446
binary tree, 432
child,433
complete binary tree, .433, 529
depth of node, 433
descendant, 433
height, 433
inorder traversal, 440
leaf,432
Index
level,433
level-Qrder traversal, 107
node, 432
parent, 433
slick binary tree, 433, 528
postorder traversal, 440
preorder traversal, 440
recursive algorithms, 442
root, 432
subtree, 432
traversal, 440
tree traversal, 440
TreeMap</e><k, v=""> class, 473, 474, 494
constructor, 494
TreeNode class, xiv, 433
instizzle variables, 434
methodz of, 434
TreeSet</k,><e> class, 473, 474, 488
constructor, 488
turn method, 571
two-dimensionizzle array, 299-302
as parameter, 301
type, 117
boolean, 117
built-in, 117
double, 117
int, 117
primitive, 117, 156
type compatibility, 194
U
UML diagram, 264, 269
UnboundedGrid</e><e> class, 576, 578
underflow error, 403, 406
URL,707
user-defined constant, 120
V
variable, 117, 150
final, 120, 151
instance, 117, 150
local, 155
public, 150
variable declaration, 117
void, 151
W
"hile loop, 130
workstation, 707
worst case, 271
wrapper class, 165,231-234
719
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I
I

COMPUTER SCIENCE
Levels A n' AB
2008-2009
4TH EDITION
 Four full-length AP practice exams,
two each fo' Levels A n' AB
 Two practice exams presented as
diagnostic tests, wit charts detailing
the topics fo' each question
 Extensive subject review on Java
5.0 n' all topics covered up in both
the Level A n' Level AB exams
 New up in dis edition: Da GridWorld
Case Study
ISBN-13: 978-0-7641 -3709-9
ISBN- l 0: 0-7641 -3709-3
~ I Pt III 51 69 9&gt;
9 " "" "",. Pt II $16.99 www.barro nse duc .com
</e></string></integer></type></type></type></actor></candidate></candidate></candidate></candidate></actor></candidate></candidate></actor></string></w~2></string></string></string></string></hlimensionizzle></e></location,></i></location></location></location></location></actor></location></oparam,></e></e></e></e></e></e></location></location,></e></e></e></e></e></e></e></e></e></e></e></e></e></e></e></e></e></e></e></location></location></location></e></e></e></e></e></e></e></e></e></e></e></location></location></location></location></e></e></e></e></e></e></actor></location></location></actor></actor></actor></actor></number></const></const»></fill></fill></gradstudent></gradstudent></b></a></type></type></type></type></type></type></type></type></string,></game></string></string></game></position,></position,></string,></string,></student></gradstudent></gradstudent></string></string></string></string></string></string></string></string></string></string></string,></string,></elementtype></elementtype></string,></string,></integer></integer></integer></integer></string></string></string></string></string></string></string></string></integer></integer></integer></e></e></e></student></someclass></someclass></someclass></e></e></k.></k.></e></e></e></string,></k,></string,></string,></string,></string,></string,></string,></string,></string,></string,></string,></string,></ic,></ic,></keytype></k,></k,></k,></k,></k,></k,></k,></k></k,></k,></k,></k,></k,></k,></string></string></string></string></string></string></string></string></string></string></string></string></string></string></string></string></string></string></string></string></string></string></string></string></string></string></string></string></string></string></string></string></e></e></e></e></e></e></e></e></e></e></e></e></e></e></e></integer></integer></e></e></e></e></e></string></string></integer></integer></integer></e></integer></integer></integer></integer></integer></integer></integer></e></e></e></e></e></e></e></e></string></string></string></string></string></objecttype></e></e></e></sometype></sometype></string></string></string></string></string></string></e></e></e></e></e></e></clown,></clown></k,></e></e></k.></k.></k.></e></e></e></e></e></e></itemtype></itemtype></itemtype></itemtype></integer></integer></e></e></string></string></t></t></t></string></string></integer></integer></integer></integer></string></string></someclass></someclass></someclass></someclass></someclass></string></string></e></e></e></e></e></e></patient></patient></e></e></e></e></string></string></string></string></string></string></e></e></e></string></string></string></string></string></e></e></e></e></e></e></e></d></e></e></more></coin></coin></comparable></integer></string></string></comparable></comparable></int></int></string></string></e></integer></integer></integer></e></process></e></data></student></student></student></list></grade></average></record></data></scores></list></user></menu></list></e></integer></integer></integer></boolean></your></game></game></game></game></game></actor></string,></scrabbleplayer,></actor></actor></actor></location></location></location></treenode></treenode></string,></string.></sometype></sometype></sometype></sometype></sometype></sometype></sometype></sometype></sometype></string,></string,></type></type></type></type></type></type></type></type></type></type></type></type></digitalclock></digitalclock></digitalclock></digitalclock></string></string></string></bug></actor></bug></bug></bug></actor></bug></mystocklist></t~f.'":':'.i":~""f)~"'it!'\,~~.></actor></bug></actor></bug></actor></bug></actor></bug></i></integer></integer></integer></integer></integer></sometype></quadrilateral></clown></e></e></e></e></k,></k,></k,></k,></k,></e></e></e></e></e></i></e></e></e></e></e></e></e></e></e></e></e></e><div id="naptha_container0932014_0707"></div></body><span class="gr__tooltip"><span class="gr__tooltip-content"></span><i class="gr__tooltip-logo"></i><span class="gr__triangle"></span></span></html>
